// Base Projectile Class
class AetheriusBaseProjectileZSC : AetheriusBaseZSC
{
	//mixin AtkTypeChecker;
	const MACELDLDMGMULTI = 5;

	// General
	const SKILL_VERY_EASY = 0;
	const SKILL_EASY = 1;
	const SKILL_NORMAL = 2;
	const SKILL_HARD = 3;
	const SKILL_VERY_HARD = 4;
	const SKILL_EXTREME = 5;
	const SKILL_HORRIBLE = 6;
	const SKILL_IMPOSSIBLE = 7;
	const SKILL_OMEGA = 8;

	bool IsACrisisAttack;
	
	int Fuse;
	int timesrippedoverall;
	int maxtimesrippedoverall;
	int FuseDone;
	int user_BaseDamage;
	int user_DamageError;
	int user_BaseExplodeDamage;
	int user_ExplodeDamageError;
	int user_Fuse;
	int user_fusemax;
	int user_seek;
	int user_seekmax1;
	int user_crisistimer;
	int user_misctimer1;
	int user_misctimer2;
	int user_misctimer3;
	int user_misctimer4;

	int user_randompain;
	int tic;
	int finaldamagedealt;
	int finaldamagedealt2;
	int MeleeImpactRad;
	int QuakeIntensity;
	int QuakeDuration;
	int QuakeTremRad;
	int VortStrength;
	int VortDistance;
	int VortDistance2;
	int VortDmgRad;
	int VortDmgRad2;
	actor OriginalActor;
	string OriginalActorType;
	bool REFLECTEDMONSTERPROJ;

	int InitRenderType;
	double InitAlpha;

	int BFGTracerAngle;
	int BFGTracerVAngle;
	int BFGTracerRange;
	int BFGTracers;
	int ishellcoreproj;
	
	private class<Inventory> APPackToken, APPackCheck, APPackCheck2, APPackCheck3, APPackCheck4, iDTech1Check, iDTech1Check2, iDTech1Check3, iDTech1Check4;
	
	property ishellcore: ishellcoreproj;
	
	override void BeginPlay()
	{
		super.BeginPlay();
	}
	
	override void PostBeginPlay()
	{
		AetheriusPlayerPawn playpawn;
		playpawn = AetheriusPlayerPawn(target);
		if (playpawn)
		{
			angle = playpawn.angle;
			pitch = playpawn.pitch;
		}

		/*
		STYLE_None (0)
		STYLE_Normal (1)
		STYLE_Fuzzy (2)
		STYLE_SoulTrans (3)
		STYLE_OptFuzzy (4)
		STYLE_Stencil (5)
		STYLE_Translucent (6)
		STYLE_Add (7)
		STYLE_Shaded (8)
		STYLE_TranslucentStencil (9)
		STYLE_Shadow (10)
		STYLE_Subtract (11)
		STYLE_AddStencil (12)
		STYLE_AddShaded (13)
		*/
		InitRenderType = GetRenderStyle();
		InitAlpha = Alpha;

		if (ishellcoreproj)
		{
			if (InitRenderType != 6) A_SetRenderStyle((InitAlpha*dvds_hellcoreprojalpha),6);
			else alpha = InitAlpha * dvds_hellcoreprojalpha;
			if (dvdsdebug_projectiledisplays) Console.Printf("%.8f", alpha);
		}

		if (dvdsdebug_projectiledisplays) Console.Printf("InitRenderType: %d (InitAlpha: %.8f) [Name: %s]", InitRenderType, InitAlpha, GetClassName());
		
		if (GetClassName() == "ReviveProj2")
		{
			if (target) { bFRIENDLY = target.BFRIENDLY; }
		}
		
		Super.PostBeginPlay();
	}
	
	override void Tick()
	{
		if (GetAge() == 1)
		{
			if (ishellcoreproj)
			{
				if (InitRenderType != 6) A_SetRenderStyle((InitAlpha*dvds_hellcoreprojalpha),6);
				else alpha = InitAlpha * dvds_hellcoreprojalpha;
				if (dvdsdebug_projectiledisplays) Console.Printf("%.8f", alpha);
			}
		}
		//Console.Printf("pitch: %.8f", pitch);
		Super.Tick();
	}

	override bool CanCollideWith(Actor other, bool passive)
	{
		AetheriusPlayerPawn playpawn;
		AetheriusPlayerPawn playpawn2;
		AetheriusMonsterZSC DVDSActor;
		AetheriusMonsterZSC DVDSActor2;
		playpawn = AetheriusPlayerPawn(target);
		playpawn2 = AetheriusPlayerPawn(other);
		DVDSActor = AetheriusMonsterZSC(target);
		DVDSActor2 = AetheriusMonsterZSC(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer() > 0) return false;
					if (A_CheckFriendCollisionProjTypePlayer2() > 0) return false;
				}
			}
			else
			if (DVDSActor && DVDSActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1() > 0) return false;
				}
			}
			else 
			{
				if (GetClassName() == "HubbleBubbleSmall" || GetClassName() == "HubbleBubbleLarge") return false;
			}
		}
		// We don't really care about others making the check.
		return true;
	}

	int A_GetPlayerAttackDamage(int type = 0, int puff = 0)
	{
		string nm;
		int debugplayeratkinfo = dvdsdebug_showplayeratkinformation;
		int flagchecktype = 0;
		int baserand1, baserand2;
		int damage, extradmg1, extradmg2, extradmg3, extradmg4, extradmg5, extradmg6, finaldmg;
		int rand1, rand2;
		double perkfactor = 1.00;
		double chargefactor = 1.00;
		int playershot = 0;
		int PlayerAeonPts = CallACS("MiscVarCheckDECORATE",25);
		int PlayerAGL = CallACS("MiscVarCheckDECORATE",31);
		int PlayerDEF = CallACS("MiscVarCheckDECORATE",32);
		int PlayerDFT = CallACS("MiscVarCheckDECORATE",33);
		int PlayerSOR = CallACS("MiscVarCheckDECORATE",34);
		int PlayerSTR = CallACS("MiscVarCheckDECORATE",35);
		int PlayerTHE = CallACS("MiscVarCheckDECORATE",36);
		int PlayerLVL = CallACS("StatCheck",0);
		int MagiUpPerkLevel = CallACS("MiscVarCheckDECORATE",10003);
		int MagiUpEXPerkLevel = CallACS("MiscVarCheckDECORATE",10004);
		int BulletAccuracyPerkLevel = CallACS("MiscVarCheckDECORATE",10019);
		int BulletAccuracyEXPerkLevel = CallACS("MiscVarCheckDECORATE",10020);
		int PelletAccuracyPerkLevel = CallACS("MiscVarCheckDECORATE",10021);
		int PelletAccuracyEXPerkLevel = CallACS("MiscVarCheckDECORATE",10022);
		int PlasmaAccuracyPerkLevel = CallACS("MiscVarCheckDECORATE",10023);
		int PlasmaAccuracyEXPerkLevel = CallACS("MiscVarCheckDECORATE",10024);
		int DemolitionsExpertPerkLevel = CallACS("MiscVarCheckDECORATE",10025);
		int DemolitionsExpertEXPerkLevel = CallACS("MiscVarCheckDECORATE",10026);
		int KarasawaAttunementPerkLevel = CallACS("MiscVarCheckDECORATE",10027);
		int KarasawaAttunementEXPerkLevel = CallACS("MiscVarCheckDECORATE",10028);
		int BFGAttunementPerkLevel = CallACS("MiscVarCheckDECORATE",10029);
		int BFGAttunementEXPerkLevel = CallACS("MiscVarCheckDECORATE",10030);
		int ArcheryMasteryPerkLevel = CallACS("MiscVarCheckDECORATE",10031);
		int ArcheryMasteryEXPerkLevel = CallACS("MiscVarCheckDECORATE",10032);
		int SoulMasteryPerkLevel = CallACS("MiscVarCheckDECORATE",10033);
		int SoulMasteryEXPerkLevel = CallACS("MiscVarCheckDECORATE",10034);
		int WandMasteryPerkLevel = CallACS("MiscVarCheckDECORATE",10053);
		int WandMasteryEXPerkLevel = CallACS("MiscVarCheckDECORATE",10054);
		int ismagicalatk;
		int isfirearmatk;
		int ishybridatk;

		perkfactor = 1.00;
		// Bullet
		if (type == 1 ||
				type == 2 ||
				type == 5 ||
				type == 6 ||
				type == 60)
				perkfactor += ((BulletAccuracyPerkLevel * 0.05) + (BulletAccuracyEXPerkLevel * 0.125));
		// Pellet
		if (type == 3 || 
				type == 4 ||
				type == 60)
				perkfactor += ((PelletAccuracyPerkLevel * 0.05) + (PelletAccuracyEXPerkLevel * 0.125));
		// Plasma
		if (type == 7 || 
				type == 10 || 
				type == 11 || 
				type == 12 || 
				type == 13 ||
				type == 48 ||
				type == 49 ||
				(type >= 53 && type <= 56) ||
				type == 58)
				perkfactor += ((PlasmaAccuracyPerkLevel * 0.05) + (PlasmaAccuracyEXPerkLevel * 0.125));
		// Demolition
		if (type == 8 ||
				type == 9 ||
				type == 69 ||
				type == 70)
				perkfactor += ((DemolitionsExpertPerkLevel * frandom(0.07,0.14)) + (DemolitionsExpertEXPerkLevel * frandom(0.175,0.35)));
		// Karasawa
		if (type == 16 || 
				type == 17)
				perkfactor += ((PlasmaAccuracyPerkLevel * 0.05) + (PlasmaAccuracyEXPerkLevel * 0.125));
				perkfactor += ((KarasawaAttunementPerkLevel * 0.5) + (KarasawaAttunementEXPerkLevel * 1.25));
		// BFG
		if (type == 12 || 
				type == 13 || 
				type == 14 || 
				type == 15)
				perkfactor += ((PlasmaAccuracyPerkLevel * 0.05) + (PlasmaAccuracyEXPerkLevel * 0.125));
				perkfactor += ((BFGAttunementPerkLevel * 0.5) + (BFGAttunementEXPerkLevel * 1.25));
		// Archery
		if (type >= 18 && type <= 20)
				perkfactor += ((ArcheryMasteryPerkLevel * 0.125) + (ArcheryMasteryEXPerkLevel * 0.3125));
		// Ethereal Crossbow
		if (type == 21 || 
				type == 22 || 
				type == 23)
				perkfactor += ((ArcheryMasteryPerkLevel * 0.125) + (ArcheryMasteryEXPerkLevel * 0.3125));
		// Strife Crossbow
		if (type == 25 ||
				type == 26)
				perkfactor += ((ArcheryMasteryPerkLevel * 0.125) + (ArcheryMasteryEXPerkLevel * 0.3125));
		// Impaler Crossbow [Strange Aeons]
		if (type == 63 || type == 64)
		{
				perkfactor += ((MagiUpPerkLevel * 0.075) + (MagiUpEXPerkLevel * 0.1875)); // MagiUp
				perkfactor += ((WandMasteryPerkLevel * 0.05) + (WandMasteryEXPerkLevel * 0.125)); // Wand/Staff Mastery
				perkfactor += ((ArcheryMasteryPerkLevel * 0.25) + (ArcheryMasteryEXPerkLevel * 0.625));
		}
		// Heretic Magic Weapons
		if (type == 24 || 
				(type >= 27 && type <= 43))
				perkfactor += ((WandMasteryPerkLevel * 0.10) + (WandMasteryEXPerkLevel * 0.25));
		// Sapphire Wand(s) [Flora] & Serpent Staff(ves) [Ailish]
		if (type == 44 || 
				type == 45 ||
				type == 57)
				perkfactor += ((WandMasteryPerkLevel * 0.125) + (WandMasteryEXPerkLevel * 0.3125));
		// Hubble Bubbles
		if (type == 46 || 
				type == 47)
				perkfactor += ((WandMasteryPerkLevel * 0.15) + (WandMasteryEXPerkLevel * 0.375));
		// Unmaker Lasers
		if (type == 50 || type == 51)
		{
				perkfactor += ((MagiUpPerkLevel * 0.075) + (MagiUpEXPerkLevel * 0.1875));
				perkfactor += ((SoulMasteryPerkLevel * 0.10) + (SoulMasteryEXPerkLevel * 0.25));
				perkfactor += ((WandMasteryPerkLevel * 0.05) + (WandMasteryEXPerkLevel * 0.125));
		}
		// Hell Warrior Shield Fireballs
		if (type == 52)
		{
				perkfactor += ((MagiUpPerkLevel * 0.075) + (MagiUpEXPerkLevel * 0.1875)); // MagiUp
				perkfactor += ((SoulMasteryPerkLevel * 0.05) + (SoulMasteryEXPerkLevel * 0.125)); // Soul Mastery
				perkfactor += ((WandMasteryPerkLevel * 0.05) + (WandMasteryEXPerkLevel * 0.125)); // Wand/Staff Mastery
		}
		// Soul Scepter
		if (type >= 65 && type <= 68) // Soul Scepter
		{
			perkfactor += ((MagiUpPerkLevel * 0.0375) + (MagiUpEXPerkLevel * 0.09375)); // MagiUp
			perkfactor += ((SoulMasteryPerkLevel * 0.10) + (SoulMasteryEXPerkLevel * 0.25)); // Soul Mastery
			perkfactor += ((WandMasteryPerkLevel * 0.025) + (WandMasteryEXPerkLevel * 0.0625)); // Wand/Staff Mastery
		}
		
		
		// Main Definitions
		if (type == 1) // Pistol [Single]
		{
			damage = random(1,4) * random(5,7); // 5 to 28
			extradmg1 = PlayerAGL * 1.50; // 150% of Agility
			extradmg2 = PlayerSTR * 0.35; // 35% of Strength
		}
		if (type == 2) // Pistol [Dual]
		{
			damage = random(2,4) * random(6,7); // 12 to 28
			extradmg1 = PlayerAGL * 1.75; // 175% of Agility
			extradmg2 = PlayerSTR * 0.40; // 40% of Strength
		}
		if (type == 3) // Shotgun
		{
			damage = random(2,3) * 5; // 10 to 15
			extradmg1 = PlayerAGL * 2.00; // 200% of Agility
			extradmg2 = PlayerSTR * 0.175; // 17.5% of Strength
		}
		if (type == 4) // Super Shotgun
		{
			damage = random(2,3) * random(5,6); // 10 to 18
			extradmg1 = PlayerAGL * 2.50; // 175% of Agility
			extradmg2 = PlayerSTR * 0.25; // 25% of Strength
		}
		if (type == 5) // Chaingun
		{
			damage = random(2,4) * random(5,7); // 10 to 28
			extradmg1 = PlayerAGL * 1.75; // 175% of Agility
			extradmg2 = PlayerSTR * 0.40; // 40% of Strength 
		}
		if (type == 6) // Minigun
		{
			damage = random(3,4) * random(6,7); // 18 to 28
			extradmg1 = PlayerAGL * 2.00; // 175% of Agility
			extradmg2 = PlayerSTR * 0.50; // 40% of Strength 
		}
		if (type == 7) // Repeater
		{
			baserand1 = 1 + (PlasmaAccuracyPerkLevel * 0.50);
			baserand2 = 3 + PlasmaAccuracyPerkLevel + (PlasmaAccuracyEXPerkLevel * 1.50);
			
			damage = random(baserand1,baserand2) * 6; // 6 to 18
			extradmg1 = PlayerAGL * 3.00; // 300% of Agility
			extradmg2 = PlayerSTR * 0.75; // 75% of Strength 
		}
		if (type == 8) // Rocket/Grenade [main hit]
		{
			baserand1 = 1 + DemolitionsExpertPerkLevel;
			baserand2 = 8 + (DemolitionsExpertPerkLevel * 0.50) + (DemolitionsExpertEXPerkLevel * 1.25);
			
			damage = random(baserand1,baserand2) * 20; // 20 to 160
			extradmg1 = PlayerAGL * 2.50; // 250% of Agility
			extradmg2 = PlayerSTR * 1.125; // 112.5% of Strength 
		}
		if (type == 9) // Rocket/Grenade [explosion]
		{
			damage = 128 + (DemolitionsExpertPerkLevel * 12) + (DemolitionsExpertEXPerkLevel * 30);
			extradmg1 = PlayerAGL * 2.50; // 250% of Agility
			extradmg2 = PlayerSTR * 1.125; // 112.5% of Strength 
		}
		if (type == 10) // Repeater [explosion]
		{
			damage = 7 + (PlasmaAccuracyPerkLevel * 4) + (PlasmaAccuracyEXPerkLevel * 10); // 7
			extradmg1 = PlayerAGL * 0.40; // 40% of Agility
			extradmg2 = PlayerSTR * 0.1428282829; // 14.28~% of Strength 
		}

		if (type == 11) // Plasma
		{
			baserand1 = 1 + PlasmaAccuracyPerkLevel;
			baserand2 = 8 + (PlasmaAccuracyPerkLevel * 0.5) + (PlasmaAccuracyEXPerkLevel * 1.25);
			damage = random(baserand1,baserand2) * 5; // 5 to 40
			extradmg1 = PlayerAGL * 0.9334; // 93.34% of Agility
			extradmg2 = PlayerSTR * 0.45; // 45% of Strength 
		}
		if (type == 12) // Plasma1 [BFG2704]
		{
			baserand1 = 1 + PlasmaAccuracyPerkLevel;
			baserand2 = 8 + (PlasmaAccuracyPerkLevel * 0.5) + (PlasmaAccuracyEXPerkLevel * 1.25);
			damage = random(baserand1,baserand2) * 4; // 4 to 32
			extradmg1 = PlayerAGL * 1.00; // 100% of Agility
			extradmg2 = PlayerSTR * 0.55; // 55% of Strength 
		}
		if (type == 13) // Plasma2 [BFG2704]
		{
			baserand1 = 1 + PlasmaAccuracyPerkLevel;
			baserand2 = 8 + (PlasmaAccuracyPerkLevel * 0.5) + (PlasmaAccuracyEXPerkLevel * 1.25);
			damage = random(baserand1,baserand2) * 4; // 4 to 32
			extradmg1 = PlayerAGL * 1.10; // 110% of Agility
			extradmg2 = PlayerSTR * 0.50; // 50% of Strength 
		}

		if (type == 14) // BFG [Main]
		{
			baserand1 = (PlasmaAccuracyPerkLevel * 2);
			if (BFGAttunementPerkLevel <= 0) baserand1 += 2;
			if (BFGAttunementPerkLevel == 1) baserand1 += 4;
			if (BFGAttunementPerkLevel >= 2) baserand1 += 8;
			baserand2 = PlasmaAccuracyPerkLevel + (PlasmaAccuracyEXPerkLevel * 1.5);
			if (BFGAttunementPerkLevel <= 0) baserand2 += 16;
			if (BFGAttunementPerkLevel == 1) baserand2 += 17;
			if (BFGAttunementPerkLevel >= 2) baserand2 += 20;
			damage = random(baserand1,baserand2) * 50; // 100 to 800
			extradmg1 = (PlayerAGL * 11); // 1100% of Agility
			if (BFGAttunementPerkLevel == 1) extradmg1 = (PlayerAGL * 12); // 1200% of Agility
			if (BFGAttunementPerkLevel == 2) extradmg1 = (PlayerAGL * 15); // 1500% of Agility
			extradmg2 = (PlayerSTR * 5.5); // 550% of Strength 
			if (BFGAttunementPerkLevel == 1) extradmg2 = (PlayerSTR * 6); // 600% of Strength 
			if (BFGAttunementPerkLevel == 2) extradmg2 = (PlayerSTR * 7.5); // 750% of Strength 
		}
		if (type == 15) // BFG [Tracer]
		{
			baserand1 =( PlasmaAccuracyPerkLevel * 1.5);
			if (BFGAttunementPerkLevel <= 0) baserand1 += 1;
			if (BFGAttunementPerkLevel == 1) baserand1 += 2;
			if (BFGAttunementPerkLevel >= 2) baserand1 += 3;
			baserand2 = (PlasmaAccuracyPerkLevel * 0.75) + (PlasmaAccuracyEXPerkLevel * 1.375);
			if (BFGAttunementPerkLevel <= 0) baserand2 += 8;
			if (BFGAttunementPerkLevel == 1) baserand2 += 9;
			if (BFGAttunementPerkLevel >= 2) baserand2 += 10;
	
			damage = random(baserand1,baserand2) + 15; // 100 to 800
			if (BFGAttunementPerkLevel == 1) damage = random(baserand1,baserand2) + 18; // 20 to 37
			if (BFGAttunementPerkLevel == 2) damage = random(baserand1,baserand2) + 22; // 25 to 32
			extradmg1 = (PlayerAGL * 2.2); // 220% of Agility
			if (BFGAttunementPerkLevel == 1) extradmg1 = (PlayerAGL * 2.4); // 240% of Agility
			if (BFGAttunementPerkLevel == 2) extradmg1 = (PlayerAGL * 3); // 300% of Agility
			extradmg2 = (PlayerSTR * 1); // 100% of Strength 
			if (BFGAttunementPerkLevel == 1) extradmg2 = (PlayerSTR * 1.75); // 175% of Strength 
			if (BFGAttunementPerkLevel == 2) extradmg2 = (PlayerSTR * 2.5); // 250% of Strength 
		}
		if (type == 16 || type == 17) // KSawBolt
		{
			baserand1 = 1 + (PlasmaAccuracyPerkLevel * 0.5) + (PlasmaAccuracyEXPerkLevel * 1.25);
			baserand2 = 8 + (PlasmaAccuracyPerkLevel * 1.0) + (PlasmaAccuracyEXPerkLevel * 2.5);
			damage = random(baserand1,baserand2) * 15; // 15 to 120
			extradmg1 = (PlayerAGL * 4.4); // 440% of Agility
			extradmg2 = (PlayerSTR * 2); // 200% of Strength
		}
		if (type >= 18 && type <= 20) // DiarisHolyArrows
		{
			damage = 384 + random(-48,192); // 336 to 576 damage
			
			if (CountInv("LongbowZoom", AAPTR_PLAYER1) == 1) damage *= 1.5;
			if (CountInv("LongbowZoom", AAPTR_PLAYER1) == 2) damage *= 2.25;
			if (CountInv("LongbowZoom", AAPTR_PLAYER1) == 3) damage *= 3.375;
	
			if (type == 18) // DiarisHolyArrow [native]
			{
				extradmg1 = (PlayerAGL * 5); // 500% of Agility
				extradmg2 = (PlayerSTR * 0.4); // 40% of Strength 
			}
			if (type == 19) // DiarisHolyArrow2XDmg [native]
			{
				damage *= 2;
				extradmg1 = ((PlayerAGL * 6.25) * 2); // 625% of Agility
				extradmg2 = ((PlayerSTR * 0.5) * 2); // 50% of Strength 
			}
			if (type == 20) // DiarisHolyArrow3XDmg [native]
			{
				damage *= 3;
				extradmg1 = ((PlayerAGL * 7.5) * 3); // 750% of Agility
				extradmg2 = ((PlayerSTR * 0.6) * 3); // 60% of Strength 
			}
			
			damage /= 2;
			extradmg1 /= 2;
			extradmg2 /= 2;
		}
		if (type == 21) // CrossbowFX1New [HERETIC]
		{
			damage = 45 + random(-22,22); // 23 to 67 damage
			extradmg1 = (PlayerAGL * 2.50); // 250% of Agility
			extradmg2 = (PlayerSTR * 0.10); // 10% of Strength 
		}
		if (type == 22) // CrossbowFX2New [HERETIC]
		{
			damage = 27 + random(-13,13); // 14 to 40 damage
			extradmg1 = (PlayerAGL * 1.50); // 150% of Agility
			extradmg2 = (PlayerSTR * 0.06); // 6% of Strength 
		}
		if (type == 23) // CrossbowFX3New [HERETIC]
		{
			damage = 9 + random(-4,4); // 5 to 13 damage
			extradmg1 = (PlayerAGL * 0.50); // 50% of Agility
			extradmg2 = (PlayerSTR * 0.02); // 2% of Strength 
		}
		if (type == 24) // RipperNew [HERETIC] <MAGIC TYPE>
		{
			damage = 1 * random(1,8);
			extradmg1 = ((PlayerSOR * 0.125) * random(1,8)); // 12.5% of Sorcery
			extradmg2 = ((PlayerTHE * 0.0325) * random(1,8)); // 3.25% of Therapeusis
			ismagicalatk = 1;
		}
		if (type == 25) // ElectricBoltNew [STRIFE]
		{
			damage = 25 + random(-12,12); // 10 to 40 damage
			extradmg1 = (PlayerAGL * 4.0); // 400% of Agility
			extradmg2 = (PlayerSTR * 0.125); // 12.5% of Strength 
		}
		if (type == 26) // PoisonBoltNew [STRIFE]
		{
			damage = 25 + random(-12,12); // 10 to 40 damage
			extradmg1 = (PlayerAGL * 4.0); // 400% of Agility
			extradmg2 = (PlayerSTR * 0.125); // 12.5% of Strength 
		}
		if (type == 27) // BlasterPuffNew [HERETIC] <MAGIC TYPE>
		{
			damage = 18 + random(-9,9); // 4 to 32 damage
			extradmg1 = (PlayerSOR * 0.5); // 50% of Sorcery
			extradmg2 = (PlayerTHE * 0.125); // 12.5% of Therapeusis
			ismagicalatk = 1;
		}
		if (type == 28) // BlasterFX1New [HERETIC] <MAGIC TYPE>
		{
			damage = 9 + random(-4,4); // 2 to 16 damage
			extradmg1 = (PlayerSOR * 0.125); // 12.5% of Sorcery
			extradmg2 = (PlayerTHE * 0.0325); // 3.125% of Therapeusis
			ismagicalatk = 1;
		}
		if (type == 29) // GoldWandPuff1New [HERETIC] <MAGIC TYPE>
		{
			damage = 8 + random(1,6); // 9-14
			extradmg1 = (PlayerSOR * 0.5); // 50% of Sorcery
			extradmg2 = (PlayerTHE * 0.2); // 20% of Therapeusis
			ismagicalatk = 1;
		}
		if (type == 30) // GoldWandPuff2New [HERETIC] <MAGIC TYPE>
		{
			damage = 5 + random(-3,3); // 2 to 8
			extradmg1 = (PlayerSOR * 0.3334); // 33.34% of Sorcery
			extradmg2 = (PlayerTHE * 0.13334); // 13.33~% of Therapeusis
			ismagicalatk = 1;
		}
		if (type == 31) // HornRodFX1New [HERETIC] <MAGIC TYPE>
		{
			damage = 14 + random(-7,8); // 7 to 22
			extradmg1 = (PlayerSOR * 0.1667); // 16.67% of Sorcery
			extradmg2 = (PlayerTHE * 0.041667); // 4.1667% of Therapeusis
			ismagicalatk = 1;
		}
		if (type == 32) // HornRodFX2New [HERETIC] <MAGIC TYPE>
		{
			damage = 45 + random(-22,22); // 10 to 80
			extradmg1 = (PlayerSOR * 0.3334); // 33.3% of Sorcery
			extradmg2 = (PlayerTHE * 0.141414); // 14.1414% of Therapeusis
			ismagicalatk = 1;
		}
		if (type == 33) // PhoenixFX1New [HERETIC] <MAGIC TYPE>
		{
			damage = 45 + random(-22,22); // 10 to 80
			extradmg1 = (PlayerSOR * 0.667); // 66.7% of Sorcery
			extradmg2 = (PlayerTHE * 0.28571); // 28.571% of Therapeusis
			ismagicalatk = 1;
		}
		if (type == 34) // PhoenixFX2New [HERETIC] <MAGIC TYPE>
		{
			damage = 9 + random(-4,4); // 2 to 16 damage
			extradmg1 = (PlayerSOR * 0.0667); // 6.7% of Sorcery
			extradmg2 = (PlayerTHE * 0.028571); // 2.8571% of Therapeusis
			ismagicalatk = 1;
		}
		if (type == 35) // MaceFX1New [HERETIC] <MAGIC TYPE>
		{
			damage = 9 + random(-4,4); // 2 to 16 damage
			extradmg1 = (PlayerSOR * 0.067); // 6.7% of Sorcery
			extradmg2 = (PlayerTHE * 0.027778); // 2.7778% of Therapeusis
			ismagicalatk = 1;
		}
		if (type == 36) // MaceFX2New [HERETIC] <MAGIC TYPE>
		{
			damage = 27 + random(-13,13); // 6 to 48
			extradmg1 = (PlayerSOR * 0.2); // 20% of Sorcery
			extradmg2 = (PlayerTHE * 0.0833); // 8.333% of Therapeusis
			ismagicalatk = 1;
		}
		if (type == 37) // MaceFX3New [HERETIC] <MAGIC TYPE>
		{
			damage = 18 + random(-9,9); // 4 to 32
			extradmg1 = (PlayerSOR * 0.10); // 10% of Sorcery
			extradmg2 = (PlayerTHE * 0.041666); // 4.1666% of Therapeusis
			ismagicalatk = 1;
		}
		if (type == 38) // MaceFX4New [HERETIC] <MAGIC TYPE>
		{
			damage = 96 + random(-48,-48); // 18 to 144
			extradmg1 = (PlayerSOR * 0.8333); // 83.333% of Sorcery
			extradmg2 = (PlayerTHE * 0.285714); // 28.5714% of Therapeusis
			ismagicalatk = 1;
		}
		if (type == 39) // Sorcerer2FX1Player [HERETIC] <MAGIC TYPE>
		{
			damage = 45 + random(-22,22); // 10 to 80
			extradmg1 = ((PlayerSOR * 12) / 2); // 600% of Sorcery
			extradmg2 = ((PlayerTHE * 16) / 7); // 228.57% of Therapeusis
			ismagicalatk = 1;
		}
		if (type == 40) // Sorcerer2FX3 [HERETIC] <MAGIC TYPE>
		{
			damage = 45 + random(-22,22); // 10 to 80
			extradmg1 = (PlayerSOR * 3); // 300% of Sorcery
			extradmg2 = (PlayerTHE * 1.142856); // 114.2856% of Therapeusis
			ismagicalatk = 1;
		}
		if (type == 41) // GoldWandFX1New [HERETIC] <MAGIC TYPE>
		{
			damage = 9 + random(-4,4); // 5 to 13 damage
			extradmg1 = (PlayerSOR * 0.3334); // 33.3% of Sorcery
			extradmg2 = (PlayerTHE * 0.1334); // 13.34% of Therapeusis
			ismagicalatk = 1;
		}
		if (type == 42) // GoldWandFX2New [HERETIC] <MAGIC TYPE>
		{
			damage = 5 + random(-3,3); // 2 to 8 damage
			extradmg1 = (PlayerSOR * 0.1667); // 16.67% of Sorcery
			extradmg2 = (PlayerTHE * 0.0667); // 6.67% of Therapeusis
			ismagicalatk = 1;
		}
		if (type == 43) // RainPillarNew [HERETIC] <MAGIC TYPE>
		{
			damage = 23 + random(-11,11); // 12 to 34 damage
			extradmg1 = (PlayerSOR * 0.1667); // 16.67% of Sorcery
			extradmg2 = (PlayerTHE * 0.0667); // 6.67% of Therapeusis
			ismagicalatk = 1;
		}
		if (type == 44 || type == 45) // MageWandMissileNew & MageWandMissile2New <MAGIC TYPE>
		{
			damage = (6 + random(-3,3)) + random(-WandMasteryPerkLevel,WandMasteryPerkLevel);
			extradmg1 = (PlayerSOR * 0.625); // 62.5% of Sorcery
			extradmg2 = (PlayerTHE * 0.1667); // 16.67% of Therapeusis
			ismagicalatk = 1;
		}
		if (type == 46) // HubbleBubbleSmall [main] <MAGIC TYPE>
		{
			damage = (10 + random(-3,4));
			extradmg1 = (PlayerSOR * 1.25); // 125% of Sorcery
			extradmg2 = (PlayerTHE * 0.380952); // 38.0952% of Therapeusis
			ismagicalatk = 1;
		}
		if (type == 47) // HubbleBubbleLarge [main] <MAGIC TYPE>
		{
			damage = (30 + random(-9,12));
			extradmg1 = (PlayerSOR * 3.75); // 375% of Sorcery
			extradmg2 = (PlayerTHE * 1.1428); // 114.28% of Therapeusis
			ismagicalatk = 1;
		}
		if (type == 48) // A. Christina Blast
		{
			damage = random(176,293); //234); //
			extradmg1 = (PlayerSOR * 3.0); // 300% of Sorcery
			extradmg2 = (PlayerSTR * 2.0); // 200% of Strength
		}
		if (type == 49) // A. Christina Long Range Blast (Weak)
		{
			damage = random(54,91); //125); //
			extradmg1 = (PlayerSOR * 3.0); // 300% of Sorcery
			extradmg2 = (PlayerSTR * 2.0); // 200% of Strength
		}
		if (type == 50) // Unmaker Laser (Marines & Petra)
		{
			damage = random(1,8) * 10; // 10 to 80
			extradmg1 = (PlayerAGL * 1.0); // 100% of Agility
			extradmg2 = (PlayerSTR * 0.5); // 50% of Strength 
		}
		if (type == 51) // Unmaker Laser (Flora & Ailish)
		{
			damage = random(1,8) * 10; // 10 to 80
			extradmg1 = (PlayerAGL * 1.0); // 100% of Agility
			extradmg2 = (PlayerSTR * 0.5); // 50% of Strength 
		}
		if (type == 52) // Hell Warrior Shield Fireball <MAGIC TYPE>
		{
			damage = random(1,8) * 2; // 2 to 16
			extradmg1 = (PlayerSOR * 0.8); // 80.0% of Sorcery
			extradmg2 = (PlayerTHE * 0.4); // 40.0% of Therapeusis 
			ismagicalatk = 1;
		}
		if (type == 53) // A. Christina Long Range Blast (Normal)
		{
			damage = random(136,228); //182); //
			extradmg1 = (PlayerSOR * 3.0); // 300% of Sorcery
			extradmg2 = (PlayerSTR * 2.0); // 200% of Strength
		}
		if (type == 54) // A. Christina Long Range Blast (Finale)
		{
			damage = random(340,570); //353); //
			extradmg1 = (PlayerSOR * 3.0); // 300% of Sorcery
			extradmg2 = (PlayerSTR * 2.0); // 200% of Strength
		}
		if (type == 55) // A. Christina Bouncing Shot (Weak)
		{
			damage = random(54,90) * 0.16667; //353); //
			extradmg1 = (PlayerSOR * 3.0); // 300% of Sorcery
			extradmg2 = (PlayerSTR * 2.0); // 200% of Strength
		}
		if (type == 56) // A. Christina Bouncing Shot (Normal)
		{
			damage = random(135,225) * 0.16667; //353); //
			extradmg1 = (PlayerSOR * 3.0); // 300% of Sorcery
			extradmg2 = (PlayerSTR * 2.0); // 200% of Strength
		}
		if (type == 57) // CStaffMissileNew (Serpent Staff projectile) <MAGIC TYPE>
		{
			damage = (random(1,8) * 5) + random(-WandMasteryPerkLevel,WandMasteryPerkLevel);
			extradmg1 = (PlayerSOR * 0.625); // 62.5% of Sorcery
			extradmg2 = (PlayerTHE * 0.1667); // 16.67% of Therapeusis
			ismagicalatk = 1;
		}
		if (type == 58) // Railgun [Player]
		{
			damage = random(9,11) * 5; // 45 to 55
			extradmg1 = (PlayerAGL * 3.75); // 375% of Agility
			extradmg2 = (PlayerSTR * 1.8); // 180% of Strength 
		
			chargefactor = ( ( (CountInv("RailgunCharge", AAPTR_PLAYER1) * 2) + (CountInv("RailgunCharge", AAPTR_PLAYER1) * 0.3334) ) * 0.10);
			damage = damage * chargefactor;
			extradmg1 *= chargefactor;
			extradmg2 *= chargefactor;
			playershot += 1;
		}
		if (type == 59) // Thrown Poison Needle [Player]
		{
			int strengthcounter;
			damage = random(6,12);
			int stamdamagefactor = CallACS("MiscVarCheckDECORATE",317);
			damage = (damage * (2 + stamdamagefactor) / 2);
			int PlayerSTR = CallACS("StatCheck",7);
			for (strengthcounter = 0; strengthcounter < PlayerSTR; strengthcounter++)
			{
				damage += random(0,2);
				damage += random(0,1);
			}

			if (CountInv("AetheriusPowerStrength", AAPTR_PLAYER1) > 0) damage = damage * 10;

			if (CountInv("FalconKnifeEarrings", AAPTR_PLAYER1) > 0) Damage = Damage * 4 / 3; // +33.3~% Punch Damage
			if (CountInv("AnubisCufflinks", AAPTR_PLAYER1) > 0) Damage = Damage * 7 / 4; // +75% Punch Damage
			
			int MartialArtsMastery = CallACS("MiscVarCheckDECORATE",10035);
			int MartialArtsMasteryEX = CallACS("MiscVarCheckDECORATE",10036);
			if (MartialArtsMastery > 0)
			{
				int temp1 = 0;
				if (MartialArtsMastery == 1) temp1 = 25;
				if (MartialArtsMastery == 2) temp1 = 75;
				if (MartialArtsMastery == 3) temp1 = 225;
				if (MartialArtsMastery == 4) temp1 = 675;
				if (MartialArtsMastery >= 5) temp1 = 2025;
				int temp2 = 0;
				if (MartialArtsMasteryEX == 1) temp2 = 500;
				if (MartialArtsMasteryEX == 2) temp2 = 1000;
				PerkFactor = 1000 + (temp1 + temp2);
				damage = damage * PerkFactor / 1000;
			}
			
			int StamUpPerkLevel = CallACS("MiscVarCheckDECORATE",10005);
			int StamUpEXPerkLevel = CallACS("MiscVarCheckDECORATE",10006);
			if (StamUpPerkLevel > 0)
			{
				PerkFactor = ((StamUpPerkLevel * 30) + (StamUpEXPerkLevel * 75)) + 400;
				damage = damage * PerkFactor / 400;
			}
			
			damage /= random(10,20);
		}
		if (type == 60) // KDIZD Rifle Shell [Player]
		{
			damage = (random(3,5) * 25); //
			extradmg1 = PlayerAGL * 3.25; // 325% of Agility
			extradmg2 = PlayerSTR * 0.758333; // 0.758333% of Strength
		}
		if (type == 61) // Sorcerer2FX1Player (Explosion) [HERETIC] <MAGIC TYPE>
		{
			damage = 128 + random(-24,-24); // 104 to 152
			extradmg1 = ((PlayerSOR * 12) / 4); // 300% of Sorcery
			extradmg2 = ((PlayerTHE * 16) / 14); // 114.28% of Therapeusis
			ismagicalatk = 1;
		}
		if (type == 62) // PhoenixFX1New (Explosion) [HERETIC] <MAGIC TYPE>
		{
			damage = 128 + random(-24,24); // 104 to 152
			extradmg1 = (PlayerSOR * 1.334); // 133.4% of Sorcery
			extradmg2 = (PlayerTHE * 0.57142); // 57.142% of Therapeusis
			ismagicalatk = 1;
		}
		if (type == 63) // SonicNail [Strange Aeons]
		{
			damage = 16 + random(-8,8); // 8 to 24 damage
			nm = "ImpalerBowZoom"; APPackToken = nm;
			if (CountInv(APPackToken, AAPTR_PLAYER1) == 1) damage *= 1.25;
			if (CountInv(APPackToken, AAPTR_PLAYER1) == 2) damage *= 1.625;
			if (CountInv(APPackToken, AAPTR_PLAYER1) == 3) damage *= 2.5625;
			extradmg1 = (PlayerAGL * 3.0); // 300% of Agility
			extradmg2 = (PlayerSTR * 0.625); // 62.5% of Strength
			extradmg3 = (PlayerSOR * 1.25); // 125% of Sorcery
			extradmg4 = (PlayerTHE * 0.75); // 75% of Therapeusis
		}
		if (type == 64) // SonicNail AoE [Strange Aeons]
		{
			damage = 16 + random(-8,8); // 8 to 24 damage
			nm = "ImpalerBowZoom"; APPackToken = nm;
			if (CountInv(APPackToken, AAPTR_PLAYER1) == 1) damage *= 1.25;
			if (CountInv(APPackToken, AAPTR_PLAYER1) == 2) damage *= 1.625;
			if (CountInv(APPackToken, AAPTR_PLAYER1) == 3) damage *= 2.5625;
			extradmg1 = (PlayerAGL * 3.0); // 300% of Agility
			extradmg2 = (PlayerSTR * 0.625); // 62.5% of Strength
			extradmg3 = (PlayerSOR * 1.25); // 125% of Sorcery
			extradmg4 = (PlayerTHE * 0.75); // 75% of Therapeusis
		}
		if (type >= 65 && type <= 68) // Soul Scepter
		{
			damage = 3 * random(1,3); // 3 to 9 damage
			extradmg1 = (PlayerSOR * 1.125); // 225% of Sorcery
			extradmg2 = (PlayerTHE * 0.875); // 175% of Therapeusis
			extradmg3 = (PlayerDEF * 1.50); // 300% of Defense
			extradmg4 = (PlayerDFT * 0.75); // 150% of Deftness
			double frand = frandompick(0.334,0.5,0.667);
			damage *= frand;
			extradmg1 *= frand;
			extradmg2 *= frand;
			extradmg3 *= frand;
			extradmg4 *= frand;
			if ((type == 65 && CallACS("StatCheck",14) <= 1) || (type == 66 && CallACS("StatCheck",14) <= 2) || (type == 67 && CallACS("StatCheck",14) <= 2) || (type == 68 && CallACS("StatCheck",14) <= 4))
			{
				damage /= 4;
				extradmg1 /= 4;
				extradmg2 /= 4;
				extradmg3 /= 4;
				extradmg4 /= 4;
			}
		}
		if (type == 69) // RockBomb Shard Projectile [direct hit]
		{
			baserand1 = 1 + DemolitionsExpertPerkLevel;
			baserand2 = 8 + (DemolitionsExpertPerkLevel * 0.50) + (DemolitionsExpertEXPerkLevel * 1.25);

			damage = random(baserand1,baserand2) * 10; // 10 to 80
			extradmg1 = PlayerAGL * 1.25; // 125% of Agility
			extradmg2 = PlayerSTR * 0.5625; // 56.25% of Strength
		}
		if (type == 70) // RockBomb Shard Projectile [base explosion]
		{
			damage = 64 + (DemolitionsExpertPerkLevel * 6) + (DemolitionsExpertEXPerkLevel * 15);
			extradmg1 = PlayerAGL * 1.25; // 125% of Agility
			extradmg2 = PlayerSTR * 0.5625; // 56.25% of Strength
		}
		if (type == 71) // UnmakerLaser [direct hit]
		{
			perkfactor += (MagiUpPerkLevel * 0.05) + (MagiUpEXPerkLevel * 0.125);
			baserand1 = 10 + (MagiUpPerkLevel * 0.625) + (MagiUpEXPerkLevel * 1.5625);
			extradmg5 = PlayerLVL * 1.25; // 125% of Level

			if (CountInv("UnmakerAmmoType",AAPTR_PLAYER1) == 0) // MP
			{
				perkfactor += (WandMasteryPerkLevel * 0.025) + ( WandMasteryEXPerkLevel * 0.0625);
				baserand1 += (WandMasteryPerkLevel * 0.625) + ( WandMasteryEXPerkLevel * 1.5625);
				extradmg1 = PlayerAGL * 0.625; // 62.5% of Agility
				extradmg2 = PlayerSTR * 0.3125; // 31.25% of Strength
				extradmg3 = PlayerSOR * 1.25; // 125% of Sorcery
				extradmg4 = PlayerTHE * 0.625; // 62.5% of Therapeusis
			}
			else
			if (CountInv("UnmakerAmmoType",AAPTR_PLAYER1) == 1) // Hellcore/Cells
			{
				if (CallACS("CheckCharacterClass") == 2) // Hellcore
				{
					perkfactor += (SoulMasteryPerkLevel * 0.025) + (SoulMasteryEXPerkLevel * 0.0625);
					baserand1 += (SoulMasteryPerkLevel * 0.0625) + (SoulMasteryEXPerkLevel * 0.15625);
					extradmg1 = PlayerAGL * 0.625; // 62.5% of Agility
					extradmg2 = PlayerSTR * 0.3125; // 31.25% of Strength
					extradmg3 = PlayerSOR * 1.25; // 125% of Sorcery
					extradmg4 = PlayerTHE * 0.625; // 62.5% of Therapeusis
				}
				else // Cells
				{
					perkfactor += (PlasmaAccuracyPerkLevel * 0.025) + (PlasmaAccuracyEXPerkLevel * 0.0625);
					baserand1 += (PlasmaAccuracyPerkLevel * 0.0625) + (PlasmaAccuracyEXPerkLevel * 0.15625);
					extradmg1 = PlayerAGL * 1.25; // 125% of Agility
					extradmg2 = PlayerSTR * 0.625; // 62.5% of Strength
					extradmg3 = PlayerSOR * 0.625; // 62.5% of Sorcery
					extradmg4 = PlayerTHE * 0.3125; // 31.25% of Therapeusis
				}
			}
			else
			if (CountInv("UnmakerAmmoType",AAPTR_PLAYER1) == 2) // MP & Hellcore/Cells
			{
				perkfactor += (WandMasteryPerkLevel * 0.025) + (WandMasteryEXPerkLevel * 0.0625);
				baserand1 += (WandMasteryPerkLevel * 0.9375) + (WandMasteryEXPerkLevel * 2.34375);
				if (CallACS("CheckCharacterClass") == 2)
				{
					perkfactor += ((SoulMasteryPerkLevel * 0.025) + (SoulMasteryEXPerkLevel * 0.0625));
					baserand1 += (SoulMasteryPerkLevel * 0.9375) + (SoulMasteryEXPerkLevel * 2.34375);
				}
				else
				{
					perkfactor += (PlasmaAccuracyPerkLevel * 0.025) + (PlasmaAccuracyEXPerkLevel * 0.0625);
					baserand1 += (PlasmaAccuracyPerkLevel * 0.9375) + (PlasmaAccuracyEXPerkLevel * 2.34375);
				}
				extradmg1 = PlayerAGL * 1.25; // 125% of Agility
				extradmg2 = PlayerSTR * 0.625; // 62.5% of Strength
				extradmg3 = PlayerSOR * 1.25; // 125% of Sorcery
				extradmg4 = PlayerTHE * 0.625; // 62.5% of Therapeusis
				extradmg1 *= 1.25;
				extradmg2 *= 1.25;
				extradmg3 *= 1.25;
				extradmg4 *= 1.25;
				extradmg5 *= 1.25;
				extradmg6 *= 1.25;
			}
			damage = baserand1 * random(1,8);

			double randmult = frandompick(0.0375,0.05,0.625);
			double numupgrades = ((CountInv("UnmakerUpgrades",AAPTR_PLAYER1) * 4) / 3);
			double totalartfiactmulti = (randmult * numupgrades);
			damage *= (1.0 + totalartfiactmulti);
			extradmg1 *= (1.0 + totalartfiactmulti);
			extradmg2 *= (1.0 + totalartfiactmulti);
			extradmg3 *= (1.0 + totalartfiactmulti);
			extradmg4 *= (1.0 + totalartfiactmulti);
			extradmg5 *= (1.0 + totalartfiactmulti);
			extradmg6 *= (1.0 + totalartfiactmulti);
		}
		
		
		if (!(type == 14 || type == 15 || type == 59))
		{
			if (damage > 0) damage *= perkfactor;
			if (extradmg1 > 0) extradmg1 *= perkfactor;
			if (extradmg2 > 0) extradmg2 *= perkfactor;
			if (extradmg3 > 0) extradmg3 *= perkfactor;
			if (extradmg4 > 0) extradmg4 *= perkfactor;
			if (extradmg5 > 0) extradmg5 *= perkfactor;
			if (extradmg6 > 0) extradmg6 *= perkfactor;
		}

		string actorname = GetClassName();
		AetheriusPlayerPawn playpawn;
		if (target) playpawn = AetheriusPlayerPawn(target);
		if (playpawn || puff == 1 || playershot > 0)
		{
			if (debugplayeratkinfo) Console.Printf("Player Shot: %s", actorname);
			
			if (type == 45) // Reduce Sapphire Alt-Fire damage by 33%
			{
				damage *= 0.667;
				extradmg1 *= 0.667;
				extradmg2 *= 0.667;
				extradmg3 *= 0.667;
				extradmg4 *= 0.667;
				extradmg5 *= 0.667;
				extradmg6 *= 0.667;
			}
			
			rand1 = (extradmg1 + extradmg2 + extradmg3 + extradmg4 + extradmg5 + extradmg6) * 0.75;
			rand2 = (extradmg1 + extradmg2 + extradmg3 + extradmg4 + extradmg5 + extradmg6) * 1.25;
			finaldmg = damage + random(rand1,rand2);
			finaldmg *= (1.0 + (PlayerAeonPts * 0.002));
			
			int misc1 = 1000;
			if (ismagicalatk)
			{
				if (CountInv("EvenstarNecklace", AAPTR_PLAYER1) > 0) misc1 += 125;
				if (CountInv("BalrogRing", AAPTR_PLAYER1) > 0) misc1 += 125;
				finaldmg = (finaldmg * misc1) / 1000;
			}
			
			int misc2 = 1000;
			if (type == 52)
			{
				if (CountInv("SauronHelmet", AAPTR_PLAYER1) > 0) misc2 += 125;
				if (CountInv("SauronGauntletsItem", AAPTR_PLAYER1) > 0) misc2 += 125;
				if (CountInv("TheOneRing", AAPTR_PLAYER1) > 0) misc2 += 500;
				finaldmg = (finaldmg * misc2) / 1000;
			}

			// Tries to Guarantee Poison Needles inflict at least 1 base damage
			if (type == 59)
			{
				if (finaldmg < 1) finaldmg = 1;
			}

			if (debugplayeratkinfo) Console.Printf("Actor Class: %s, Type#: %d, Puff?: %d, Base Dmg: %d, Extra Dmg #1: %d, Extra Dmg #2: %d, Extra Dmg #3: %d, Extra Dmg #4: %d, Extra Dmg #5: %d, Extra Dmg #6: %d, Random: %d - %d, BaseRandom: %d - %d, Perkfactor: %.8f, ChargeFactor: %.8f, Misc1: %d, Misc2: %d, \cyFinal Damage: %d\c-", 
											 												actorname, type, puff,
																							damage, extradmg1, extradmg2, extradmg3, extradmg4, extradmg5, extradmg6,
																							rand1, rand2,
																							baserand1, baserand2,
																							perkfactor, chargefactor,
																							misc1, misc2,
																							finaldmg);
		}
		else
		{
			if (debugplayeratkinfo) Console.Printf("Non-Player Shot: %s", actorname);
			finaldmg = damage;
			
			if (debugplayeratkinfo) Console.Printf("Actor Class: %s, Type#: %d, Puff?: %d, Base Dmg: %d, \cyFinal Damage: %d\c-", 
																							actorname, type, puff,
																							damage, finaldmg);
		}
		
		if (CallACS("MiscVarCheckDECORATE",166) > 0)
		{
			int preboostdmg = finaldmg;
			finaldmg *= frandom(1.05,1.15);
			if (debugplayeratkinfo) Console.Printf("[Dash] PreBoost: %d, Total: %d", preboostdmg, finaldmg);
		}
		
		finaldamagedealt = finaldmg;
		return finaldmg;
	}

	int A_GetPunchDamage(int altfire = 0, int shockwave = 0)
	{
		let weapon = target.player.ReadyWeapon;
		string weaponname = weapon.GetClassName();
		string actorname = GetClassName();
		int damage;
		int previousdamage;
		int strengthcounter;
		int CharacterClass = CallACS("CheckCharacterClass");
		int debugmelee = dvdsdebug_showmeleeinformation;
		String nm, nn, no, np;
		nm = "FistAilish"; APPackCheck = nm;
		nn = "FistPetra"; APPackCheck2 = nn;
		no = "SauronGauntletsAilish"; APPackCheck3 = no;
		np = "SauronGauntletsPetra"; APPackCheck4 = np;

		// Character Check [base damage]
		If (weapon is "FistDeggaris" || weapon is "FistIllucia" || weapon is "FistFlora" || weapon is nm || weapon is nn)
		{
			if (altfire == 0)
			{
				if (CharacterClass == 0) damage = random(18,24);
				if (CharacterClass == 1) damage = random(10,16);
				if (CharacterClass == 2) damage = random(6,12);
				if (CharacterClass == 9) damage = random(6,12);
			}
			else
			if (altfire == 1)
			{
				if (CharacterClass == 0) damage = random(126,148);
				if (CharacterClass == 1) damage = random(70,112);
				if (CharacterClass == 2) damage = random(42,84);
				if (CharacterClass == 9) damage = random(42,84);
			}
		}
		else
		{
			if (CharacterClass == 0) damage = random(18,24);
			if (CharacterClass == 1) damage = random(10,16);
			if (CharacterClass == 2) damage = random(6,12);
			if (CharacterClass == 9) damage = random(6,12);
		}
		if (debugmelee) Console.Printf("BaseDmg: %d", damage);

		// Gauntlet Check #1 [base damage]
		previousdamage = damage;
		If (weapon is "SauronGauntlets" || weapon is "SauronGauntletsIllucia" || weapon is "SauronGauntletsFlora" || weapon is no || weapon is np)
		{
			if (CharacterClass == 0) damage += random(14,18);
			if (CharacterClass == 1) damage += random(10,14);
			if (CharacterClass == 2) damage += random(8,12);
			if (CharacterClass == 9) damage += random(8,12);

			if (debugmelee) Console.Printf("GauntDmg: %d - (Previous Dmg: %d)", damage, previousdamage);
		}
		
		// [STRIFE] Stamina Upgrades
		int stamdamagefactor = CallACS("MiscVarCheckDECORATE",317);
		previousdamage = damage;
		damage = (damage * (2 + stamdamagefactor) / 2);
		if (debugmelee) Console.Printf("StaminaDmg: %d, StamUpgrades: %d - (Previous Dmg: %d)", damage, stamdamagefactor, previousdamage);

		// Strength Stat Check [7 pts = roughly double the character's base punch damage]
		int PlayerSTR = CallACS("StatCheck",7);
		previousdamage = damage;
		for (strengthcounter = 0; strengthcounter < PlayerSTR; strengthcounter++)
		{
			If (weapon is "FistDeggaris" || weapon is "FistIllucia" || weapon is "FistFlora" || weapon is nm || weapon is nn)
			{
				if (altfire == 0)
				{
					if (CharacterClass == 0) damage += random(1,3);
					if (CharacterClass == 1) damage += random(1,2);
					if (CharacterClass == 2) damage += random(0,2);
					if (CharacterClass == 9) damage += random(0,2);
				}
				if (altfire == 1)
				{
					if (CharacterClass == 0) damage += random(8,12);
					if (CharacterClass == 1) damage += random(8,11);
					if (CharacterClass == 2) damage += random(6,10);
					if (CharacterClass == 9) damage += random(6,10);
				}
			}
			else
			{
				if (CharacterClass == 0) damage += random(1,3);
				if (CharacterClass == 1) damage += random(1,2);
				if (CharacterClass == 2) damage += random(0,2);
				if (CharacterClass == 9) damage += random(0,2);
			}
		}
		if (debugmelee) Console.Printf("StrDmg: %d - (Strength: %d) - (Previous Dmg: %d)", damage, PlayerSTR, previousdamage);
		
		// Gauntlet Check #2 [strength stat check] [7 pts = roughly double the character's base gauntlet punch damage]
		previousdamage = damage;
		If (weapon is "SauronGauntlets" || weapon is "SauronGauntletsIllucia" || weapon is "SauronGauntletsFlora" || weapon is no || weapon is np)
		{
			for (strengthcounter = 0; strengthcounter < PlayerSTR; strengthcounter++)
			{
				if (CharacterClass == 0) damage += random(2,3);
				if (CharacterClass == 1) damage += random(1,3);
				if (CharacterClass == 2) damage += random(1,2);
				if (CharacterClass == 9) damage += random(1,2);
			}
			if (debugmelee) Console.Printf("Gaunt2Dmg: %d - (Strength: %d) - (Previous Dmg: %d)", damage, PlayerSTR, previousdamage);
		}
	
		// Berserk Check
		previousdamage = damage;
		if (CountInv("AetheriusPowerStrength", AAPTR_PLAYER1) > 0) damage = damage * 10;
		if (debugmelee) Console.Printf("BerserkDmg: %d - (Previous Dmg: %d)", damage, previousdamage);
		
		// Flora Armor Checks
		previousdamage = damage;
		if (CharacterClass == 2) 
		{
			if (CountInv("FalconKnifeEarrings", AAPTR_PLAYER1) > 0) Damage = Damage * 4 / 3; // +33.3~% Punch Damage
			if (CountInv("AnubisCufflinks", AAPTR_PLAYER1) > 0) Damage = Damage * 7 / 4; // +75% Punch Damage
			if (debugmelee) Console.Printf("FloArmorDmg: %d - (Previous Dmg: %d)", damage, previousdamage);
		}
	
		// Gauntlet Check #3
		previousdamage = damage;
		If (weapon is "SauronGauntlets" || weapon is "SauronGauntletsIllucia" || weapon is "SauronGauntletsFlora" || weapon is no || weapon is np)
		{
			if (altfire == 0) damage *= 10;
			if (altfire == 1) damage *= 25;
			if (debugmelee) Console.Printf("Gaunt3Dmg: %d - (Strength: %d) - (Previous Dmg: %d)", damage, PlayerSTR, previousdamage);
		}
		
		int PerkFactor;
		int temp1, temp2;
		
		int MartialArtsMastery = CallACS("MiscVarCheckDECORATE",10035);
		int MartialArtsMasteryEX = CallACS("MiscVarCheckDECORATE",10036);
		previousdamage = damage;
		if (shockwave > 0)
		{
			if (altfire == 0) damage = damage / 6;
			if (altfire == 1) damage = damage / 5;
			if (debugmelee) Console.Printf("MeleeDmg [Shockwave]: (%s) %d - (Previous Dmg: %d [Martial Arts Mastery Perk (Shockwave) (Lvl: %d + %d)]", weaponname, damage, previousdamage, MartialArtsMastery, MartialArtsMasteryEX);

			previousdamage = damage;
			if (MartialArtsMastery > 0)
			{
				temp1 = 0;
				if (MartialArtsMastery == 1) temp1 = 50;
				if (MartialArtsMastery == 2) temp1 = 150;
				if (MartialArtsMastery == 3) temp1 = 450;
				if (MartialArtsMastery == 4) temp1 = 1350;
				if (MartialArtsMastery >= 5) temp1 = 4050;
				temp2 = 0;
				if (MartialArtsMasteryEX == 1) temp2 = 1500;
				if (MartialArtsMasteryEX == 2) temp2 = 3000;
				PerkFactor = 1000 + (temp1 + temp2);
				damage = damage * PerkFactor / 1000;
				if (debugmelee) Console.Printf("MeleeDmg [Shockwave]: (%s) %d - (Previous Dmg: %d [Martial Arts Mastery Perk (Shockwave) (Lvl: %d + %d)]", weaponname, damage, previousdamage, MartialArtsMastery, MartialArtsMasteryEX);
			}
		}
		else
		{
			previousdamage = damage;
			if (MartialArtsMastery > 0)
			{
				temp1 = 0;
				if (MartialArtsMastery == 1) temp1 = 25;
				if (MartialArtsMastery == 2) temp1 = 75;
				if (MartialArtsMastery == 3) temp1 = 225;
				if (MartialArtsMastery == 4) temp1 = 675;
				if (MartialArtsMastery >= 5) temp1 = 2025;
				temp2 = 0;
				if (MartialArtsMasteryEX == 1) temp2 = 500;
				if (MartialArtsMasteryEX == 2) temp2 = 1000;
				PerkFactor = 1000 + (temp1 + temp2);
				damage = damage * PerkFactor / 1000;
				if (debugmelee) Console.Printf("MeleeDmg: (%s) %d - (Previous Dmg: %d [Martial Arts Mastery Perk (Lvl: %d + %d)]", weaponname, damage, previousdamage, MartialArtsMastery, MartialArtsMasteryEX);
			}
		}
		
		previousdamage = damage;
		If (weapon is "FistDeggaris" || weapon is "FistIllucia" || weapon is "FistFlora" || weapon is nm || weapon is nn)
		{
			if (altfire == 0) damage = damage;
			//if (altfire == 1) damage = damage / 4;
		}
		
		if (debugmelee && altfire == 0) Console.Printf("MeleeDmgAltCheck: (%s) %d - (Previous Dmg: %d) [Punch]", weaponname, damage, previousdamage);
		if (debugmelee && altfire == 1) Console.Printf("MeleeDmgAltCheck: (%s) %d - (Previous Dmg: %d) [Uppercut]", weaponname, damage, previousdamage);
		
		// StamUp Check
		previousdamage = damage;
		int StamUpPerkLevel = CallACS("MiscVarCheckDECORATE",10005);
		int StamUpEXPerkLevel = CallACS("MiscVarCheckDECORATE",10006);
		if (StamUpPerkLevel > 0)
		{
			PerkFactor = ((StamUpPerkLevel * 30) + (StamUpEXPerkLevel * 75)) + 400;
			damage = damage * PerkFactor / 400;
		}
		
		if (debugmelee && altfire == 0) Console.Printf("FinalMeleeDmg: (Weapon: %s - Puff: %s) %d - (Previous Dmg: %d) [Punch]", weaponname, actorname, damage, previousdamage);
		if (debugmelee && altfire == 1) Console.Printf("FinalMeleeDmg: (Weapon: %s - Puff: %s) %d - (Previous Dmg: %d) [Uppercut]", weaponname, actorname, damage, previousdamage);

		return damage;
	}

	int A_GetKickDamage(int altfire = 0, int shockwave = 0)
	{
		let weapon = target.player.ReadyWeapon;
		string weaponname = weapon.GetClassName();
		string actorname = GetClassName();
		int damage;
		int previousdamage;
		int strengthcounter;
		int CharacterClass = CallACS("CheckCharacterClass");
		int debugmelee = dvdsdebug_showmeleeinformation;
		
		if (CharacterClass == 0) damage = random(45,60); // 2.5x
		if (CharacterClass == 1) damage = random(25,40); // 2.5x
		if (CharacterClass == 2) damage = random(26,51); // 4.25x
		if (CharacterClass == 8) damage = random(21,46); // 4.25x
		if (CharacterClass == 9) damage = random(35,60); // 
		if (debugmelee) Console.Printf("BaseDmg: %d", damage);

		// [STRIFE] Stamina Upgrades
		int stamdamagefactor = CallACS("MiscVarCheckDECORATE",317);
		previousdamage = damage;
		damage = (damage * (4 + (stamdamagefactor * 3)) / 4);
		if (debugmelee) Console.Printf("StaminaDmg: %d, StamUpgrades: %d - (Previous Dmg: %d)", damage, stamdamagefactor, previousdamage);
		
		// Strength Stat Check [7 pts = roughly double the character's base punch damage]
		int PlayerSTR = CallACS("StatCheck",7);
		previousdamage = damage;
		for (strengthcounter = 0; strengthcounter < PlayerSTR; strengthcounter++)
		{
			if (CharacterClass == 0) damage += random(2,8); // 2.5x
			if (CharacterClass == 1) damage += random(2,5); // 2.5x
			if (CharacterClass == 2) damage += random(3,9); // 4.25x
			if (CharacterClass == 8) damage += random(2,8); // 4.25x
			if (CharacterClass == 9) damage += random(4,12); //
		}
		if (debugmelee) Console.Printf("StrDmg: %d - (Strength: %d) - (Previous Dmg: %d)", damage, PlayerSTR, previousdamage);
	
		// Reduce Check
		previousdamage = damage;
		if (altfire == 0) damage = (damage * random(5,6)) / 5;
		if (debugmelee) Console.Printf("ReduceDmg: %d - (Previous Dmg: %d)", damage, previousdamage);
	
		// Berserk Check
		previousdamage = damage;
		if (CountInv("AetheriusPowerStrength", AAPTR_PLAYER1) > 0) damage = damage * 10;
		if (debugmelee) Console.Printf("BerserkDmg: %d - (Previous Dmg: %d)", damage, previousdamage);
		
		// Flora Armor Checks
		previousdamage = damage;
		if (CharacterClass == 2) 
		{
			if (CountInv("FalconKnifeEarrings", AAPTR_PLAYER1) > 0) Damage = Damage * 4 / 3; // +33.3~% Kick Damage
			if (CountInv("SafeTeaShoes", AAPTR_PLAYER1) > 0) Damage = Damage * 7 / 4; // +75% Kick Damage
			if (debugmelee) Console.Printf("FloArmorDmg: %d - (Previous Dmg: %d)", damage, previousdamage);
		}
		
		int PerkFactor;
		int temp1, temp2;
		
		int MartialArtsMastery = CallACS("MiscVarCheckDECORATE",10035);
		int MartialArtsMasteryEX = CallACS("MiscVarCheckDECORATE",10036);
		previousdamage = damage;
		if (shockwave > 0)
		{
			if (altfire == 0) damage = damage / 6;
			if (altfire == 1) damage = damage / 5;
			if (debugmelee) Console.Printf("MeleeDmg [Shockwave]: (%s) %d - (Previous Dmg: %d [Martial Arts Mastery Perk (Shockwave) (Lvl: %d + %d)]", weaponname, damage, previousdamage, MartialArtsMastery, MartialArtsMasteryEX);

			previousdamage = damage;
			if (MartialArtsMastery > 0)
			{
				temp1 = 0;
				if (MartialArtsMastery == 1) temp1 = 50;
				if (MartialArtsMastery == 2) temp1 = 150;
				if (MartialArtsMastery == 3) temp1 = 450;
				if (MartialArtsMastery == 4) temp1 = 1350;
				if (MartialArtsMastery >= 5) temp1 = 4050;
				temp2 = 0;
				if (MartialArtsMasteryEX == 1) temp2 = 1500;
				if (MartialArtsMasteryEX == 2) temp2 = 3000;
				PerkFactor = 1000 + (temp1 + temp2);
				damage = damage * PerkFactor / 1000;
				if (debugmelee) Console.Printf("MeleeDmg [Shockwave]: (%s) %d - (Previous Dmg: %d [Martial Arts Mastery Perk (Shockwave) (Lvl: %d + %d)]", weaponname, damage, previousdamage, MartialArtsMastery, MartialArtsMasteryEX);
			}
		}
		else
		{
			previousdamage = damage;
			if (MartialArtsMastery > 0)
			{
				temp1 = 0;
				if (MartialArtsMastery == 1) temp1 = 25;
				if (MartialArtsMastery == 2) temp1 = 75;
				if (MartialArtsMastery == 3) temp1 = 225;
				if (MartialArtsMastery == 4) temp1 = 675;
				if (MartialArtsMastery >= 5) temp1 = 2025;
				temp2 = 0;
				if (MartialArtsMasteryEX == 1) temp2 = 500;
				if (MartialArtsMasteryEX == 2) temp2 = 1000;
				PerkFactor = 1000 + (temp1 + temp2);
				damage = damage * PerkFactor / 1000;
				if (debugmelee) Console.Printf("MeleeDmg: (%s) %d - (Previous Dmg: %d [Martial Arts Mastery Perk (Lvl: %d + %d)]", weaponname, damage, previousdamage, MartialArtsMastery, MartialArtsMasteryEX);
			}
		}
		
		previousdamage = damage;
		if (altfire == 0) damage = damage;
		if (altfire == 1) damage = damage / 4;
		if (debugmelee && altfire == 0) Console.Printf("MeleeDmgAltCheck: (%s) %d - (Previous Dmg: %d) [Kick]", weaponname, damage, previousdamage);
		if (debugmelee && altfire == 1) Console.Printf("MeleeDmgAltCheck: (%s) %d - (Previous Dmg: %d) [Roundhouse Kick]", weaponname, damage, previousdamage);
		
		// StamUp Check
		previousdamage = damage;
		int StamUpPerkLevel = CallACS("MiscVarCheckDECORATE",10005);
		int StamUpEXPerkLevel = CallACS("MiscVarCheckDECORATE",10006);
		if (StamUpPerkLevel > 0)
		{
			PerkFactor = ((StamUpPerkLevel * 30) + (StamUpEXPerkLevel * 75)) + 400;
			damage = damage * PerkFactor / 400;
		}
		
		if (debugmelee && altfire == 0) Console.Printf("FinalMeleeDmg: (Weapon: %s - Puff: %s) %d - (Previous Dmg: %d) [Kick]", weaponname, actorname, damage, previousdamage);
		if (debugmelee && altfire == 1) Console.Printf("FinalMeleeDmg: (Weapon: %s - Puff: %s) %d - (Previous Dmg: %d) [Roundhouse Kick]", weaponname, actorname, damage, previousdamage);

		return damage;
	}

	int A_GetSceptreDamage(int attacktype = 0, int attacklevel = 0, int shockwave = 0)
	{
		let weapon = target.player.ReadyWeapon;
		string weaponname = weapon.GetClassName();
		string actorname = GetClassName();
		int damage;
		int previousdamage;
		int strengthcounter;
		int sceptrestrbase;
		int sceptrestrmin;
		int sceptrestrmax;
		int PerkFactor;

		int SceptreActualLevel = CallACS("OtherVarCheckDECORATE",11);
		int CharacterClass = CallACS("CheckCharacterClass");
		int debugmelee = dvdsdebug_showmeleeinformation;
		
		if (SceptreActualLevel <= 0) damage = random(275,325); // Base Damage Range
		if (SceptreActualLevel == 1) damage = random(280,330); // +5 Damage Range
		if (SceptreActualLevel == 2) damage = random(290,340); // +10 Damage Range
		if (SceptreActualLevel == 3) damage = random(320,370); // +30 Damage Range
		if (SceptreActualLevel == 4) damage = random(340,390); // +20 Damage Range
		if (SceptreActualLevel == 5) damage = random(365,415); // +25 Damage Range
		if (SceptreActualLevel == 6) damage = random(425,475); // +60 Damage Range
		if (SceptreActualLevel == 7) damage = random(425,475); // +0 Damage Range
		if (SceptreActualLevel == 8) damage = random(545,595); // +120 Damage Range
		if (SceptreActualLevel == 9) damage = random(590,640); // +45 Damage Range
		if (SceptreActualLevel == 10) damage = random(640,690); // +50 Damage Range
		if (SceptreActualLevel == 11) damage = random(750,800); // +110 Damage Range
		if (SceptreActualLevel == 12) damage = random(810,860); // +60 Damage Range
		if (SceptreActualLevel == 13) damage = random(875,925); // +65 Damage Range
		if (SceptreActualLevel == 14) damage = random(1015,1065); // +140 Damage Range
		if (SceptreActualLevel == 15) damage = random(1015,1065); // +0 Damage Range
		if (SceptreActualLevel >= 16) damage = random(1255,1305); // +240 Damage Range
		if (debugmelee) Console.Printf("BaseDmg: %d", damage);
		
		// [STRIFE] Stamina Upgrades
		int stamdamagefactor = CallACS("MiscVarCheckDECORATE",317);
		previousdamage = damage;
		damage = (damage * (4 + stamdamagefactor) / 4);
		if (debugmelee) Console.Printf("StaminaDmg: %d, StamUpgrades: %d - (Previous Dmg: %d)", damage, stamdamagefactor, previousdamage);
		
		// Strength Stat Check [7 pts = roughly double the character's base punch damage]
		int PlayerSTR = CallACS("StatCheck",7);
		previousdamage = damage;
		for (strengthcounter = 0; strengthcounter < PlayerSTR; strengthcounter++)
		{
			sceptrestrbase = ((SceptreActualLevel * (4 + (PlayerSTR / 32))) + (16 + (SceptreActualLevel * (2 + (PlayerSTR / 64)))));
			sceptrestrmin = sceptrestrbase - (16 + (SceptreActualLevel * (2 + (PlayerSTR / 64))));
			sceptrestrmax = sceptrestrbase + (16 + (SceptreActualLevel * (2 + (PlayerSTR / 64)))); 

			if (debugmelee) Console.Printf("StrBase: %d, StrMin: %d, StrMax: %d", sceptrestrbase, sceptrestrmin, sceptrestrmax);

			damage += random(sceptrestrmin,sceptrestrmax);
		}
		if (debugmelee) Console.Printf("StrDmg: %d - (Strength: %d) - (Previous Dmg: %d)", damage, PlayerSTR, previousdamage);
		
		if (attacktype == 1) damage = damage * 5 / 2; // If performing the Aireal Attack
		if (attacktype == 2)
		{
			if (attacklevel < 0)
			{
				if (SceptreActualLevel <= 0) attacklevel = 0;
				if (SceptreActualLevel == 1) attacklevel = 0;
				if (SceptreActualLevel == 2) attacklevel = 0;
				if (SceptreActualLevel == 3) attacklevel = 0;
				if (SceptreActualLevel == 4) attacklevel = 0;
				if (SceptreActualLevel == 5) attacklevel = 1;
				if (SceptreActualLevel == 6) attacklevel = 1;
				if (SceptreActualLevel == 7) attacklevel = 1;
				if (SceptreActualLevel == 8) attacklevel = 1;
				if (SceptreActualLevel == 9) attacklevel = 1;
				if (SceptreActualLevel == 10) attacklevel = 2;
				if (SceptreActualLevel == 11) attacklevel = 2;
				if (SceptreActualLevel == 12) attacklevel = 2;
				if (SceptreActualLevel == 13) attacklevel = 2;
				if (SceptreActualLevel == 14) attacklevel = 2;
				if (SceptreActualLevel == 15) attacklevel = 3;
				if (SceptreActualLevel >= 16) attacklevel = 3;
			}
		
			if (attacklevel == 0) damage = damage / 2; // If performing the Spinning Attack [50%]
			else if (attacklevel == 1) damage = damage * 3 / 4; // If performing the Spinning Attack [75%]
			else if (attacklevel == 2) damage = damage * 7 / 8; // If performing the Spinning Attack [87.5%]
			else if (attacklevel == 3) damage = damage * 15 / 16; // If performing the Spinning Attack [93.25%]
		
			damage = damage / 4;
		}
		if (debugmelee) Console.Printf("BaseDmg: %d", damage);
		
		// Berserk Check
		previousdamage = damage;
		if (CountInv("AetheriusPowerStrength", AAPTR_PLAYER1) > 0) damage = damage * 10;
		if (debugmelee) Console.Printf("BerserkDmg: %d - (Previous Dmg: %d)", damage, previousdamage);
		
		if (shockwave == 1) damage = damage / 6;
		if (debugmelee) Console.Printf("ShockWave: (%s) %d", weaponname, damage);
		
		// StamUp Check
		previousdamage = damage;
		int StamUpPerkLevel = CallACS("MiscVarCheckDECORATE",10005);
		int StamUpEXPerkLevel = CallACS("MiscVarCheckDECORATE",10006);
		if (StamUpPerkLevel > 0)
		{
			PerkFactor = ((StamUpPerkLevel * 30) + (StamUpEXPerkLevel * 75)) + 400;
			damage = damage * PerkFactor / 400;
		}

		if (debugmelee) Console.Printf("FinalMeleeDmg: (Weapon: %s - Puff: %s) %d - (Previous Dmg: %d) [Sceptre]", weaponname, actorname, damage, previousdamage);

		return damage;
	}

	int A_GetRagingSpiritDMG(int type = 0)
	{
		int lowcap = 1;
		int lowcaprand = 2;
		int damagedivider;
		int CharacterClass = CallACS("CheckCharacterClass");
		int DivineAvatarTimer = CallACS("GetBuffTimer",7);
		int debugplayeratkinfo = dvdsdebug_showplayeratkinformation;
		int PlayerLevel = CallACS("StatCheck",0);
		int PlayerSOR = CallACS("MiscVarCheckDECORATE",34);
		int PlayerTHE = CallACS("MiscVarCheckDECORATE",36);
		
		int basedamage; 
		int extradamage;
		if (type == 0)
		{
			basedamage = (((3 + random(0,1)) * random(3,4)));
			extradamage = (((PlayerSOR + PlayerTHE) * 0.20) * random(4,8) / 8);
		}
		else
		{
			basedamage = (((6 + random(0,2)) * random(6,8)));
			extradamage = (((PlayerSOR + PlayerTHE) * 0.40) * random(8,16) / 8);
		}
		int damage = basedamage + extradamage;
		if (DivineAvatarTimer > 0) // Divine Avatar reduces the damage divide [aka even more damage is dealt]
		{
			if (type == 0)
			{
				damagedivider = random(5,6);
				lowcap = 6; 
				lowcaprand = 9; 
			}
			else
			{
				damagedivider = random(3,5);
				lowcap = 9; 
				lowcaprand = 12; 
			}
		}
		else
		{
			if (type == 0)
			{
				damagedivider = random(10,12);
				lowcap = 2; 
				lowcaprand = 3; 
			}
			else
			{
				damagedivider = random(6,10);
				lowcap = 3; 
				lowcaprand = 4; 
			}
		}
		
		int damagedivgain;
		if (type == 0)
		{
			if (CharacterClass == 0) damagedivgain = (PlayerLevel/56);
			if (CharacterClass == 1) damagedivgain = (PlayerLevel/48);
			if (CharacterClass == 2) damagedivgain = (PlayerLevel/40);
			if (CharacterClass == 8) damagedivgain = (PlayerLevel/52);
			if (CharacterClass == 9) damagedivgain = (PlayerLevel/44);
			if (damagedivgain > 4) damagedivgain = 4;
		}
		else
		{
			if (CharacterClass == 0) damagedivgain = (PlayerLevel/44);
			if (CharacterClass == 1) damagedivgain = (PlayerLevel/36);
			if (CharacterClass == 2) damagedivgain = (PlayerLevel/28);
			if (CharacterClass == 8) damagedivgain = (PlayerLevel/40);
			if (CharacterClass == 9) damagedivgain = (PlayerLevel/32);
			if (damagedivgain > 8) damagedivgain = 8;
		}
		
		damagedivider -= damagedivgain;
		if (damagedivider < 1) damagedivider = 1;
		
		damage /= damagedivider;
		if (damage < lowcap) { damage = random(lowcap,lowcaprand); }
		int postdamage1 = damage;
		
		if (debugplayeratkinfo) Console.Printf("\cxRaging Spirit Damage (type: %d):\c- \cxFinalDamage: %d\c-, BaseDamage: %d, ExtraDamage: %d, DamageDivGain: %d, DamageDivider: %d, LowCap: %d, LowCapRand: %d, \cySeekTimer: %d / %d\c-, \cwFuse: %d / %d\c-", type, damage, basedamage, extradamage, damagedivgain, damagedivider, lowcap, lowcaprand, user_seek, user_seekmax1, user_fuse, user_fusemax);
		finaldamagedealt = damage;
		return damage;
	}
	
	void A_GetSigilDamage(int attacktype = 0, int radiustype = 0)
	{
		int PlayerAGL = CallACS("MiscVarCheckDECORATE",31);
		int PlayerDEF = CallACS("MiscVarCheckDECORATE",32);
		int PlayerDFT = CallACS("MiscVarCheckDECORATE",33);
		int PlayerSOR = CallACS("MiscVarCheckDECORATE",34);
		int PlayerSTR = CallACS("MiscVarCheckDECORATE",35);
		int PlayerTHE = CallACS("MiscVarCheckDECORATE",36);
		int damage, extradmg1, extradmg2, extradmg3, extradmg4, extradmg5, extradmg6, prefinaldmg, finaldmg;
		int rand1, rand2;
		int perkfactor = 10000;
		int debugplayeratkinfo = dvdsdebug_showplayeratkinformation;
		
		// SpectralLightningBaseNew's A_Explode [this affects the explosive-damage/radius of most Sigil attacks]
		if (attacktype == 0)
		{
			if (radiustype == 0) // Damage Calculation
			{
				damage = 32;
				extradmg1 = (PlayerDEF * 4) / 1;		// 400% of Defense		[1 pt[s] = 4 more unit[s] of damage]
				extradmg2 = (PlayerDFT * 3) / 8;		// 37.5% of Deftness	[8 pt[s] = 3 more unit[s] of damage]
				extradmg3 = (PlayerSOR * 7) / 4;		// 150% of Sorcery		[4 pt[s] = 6 more unit[s] of damage]
			}
			else // Radius Calculation
			{
				damage = 32; 
				extradmg1 = (PlayerDEF * 2) / 1;		// 200% of Defense		[1 pt[s] = 2 more unit[s] of radius]
				extradmg2 = (PlayerDFT * 3) / 16;	// 18.75% of Deftness	[16 pt[s] = 3 more unit[s] of radius]
				extradmg3 = (PlayerSOR * 3) / 4;		// 75% of Sorcery		[4 pt[s] = 3 more unit[s] of radius]
			}
		}
		// SpectralLightningBall1New
		if (attacktype == 1)
		{
			damage = 175 + random(-87,87); // 88 to 242
			extradmg1 = (PlayerDEF * 21) / 4;		// 525% of Defense		[4 pt[s] = 21 more unit[s] of damage]
			extradmg2 = (PlayerDFT * 21) / 32;	// 65.625% of Deftness	[32 pt[s] = 21 more unit[s] of damage]
			extradmg3 = (PlayerSOR * 63) / 16;	// 393.75% of Sorcery	[16 pt[s] = 63 more unit[s] of damage]
		}
		// SpectralLightningBall2New
		if (attacktype == 2)
		{
			damage = 50 + random(-25,25); // 25 to 75
			extradmg1 = (PlayerDEF * 9) / 6;		// 150% of Defense		[6 pt[s] = 9 more unit[s] of damage]
			extradmg2 = (PlayerDFT * 9) / 48;		// 18.75% of Deftness	[48 pt[s] = 9 more unit[s] of damage]
			extradmg3 = (PlayerSOR * 27) / 24;	// 112.5% of Sorcery	[24 pt[s] = 27 more unit[s] of damage]
		}
		// SpectralLightningV1New
		if (attacktype == 3)
		{
			damage = 300 + random(-150,150); // 150 to 450
			extradmg1 = (PlayerDEF * 9) / 1;		// 900% of Defense		[1 pt[s] = 9 more unit[s] of damage]
			extradmg2 = (PlayerDFT * 9) / 8;		// 112.5% of Deftness	[8 pt[s] = 9 more unit[s] of damage]
			extradmg3 = (PlayerSOR * 27) / 4;		// 675% of Sorcery		[4 pt[s] = 27 more unit[s] of damage]
		}
		// SpectralLightningV2New
		if (attacktype == 4)
		{
			damage = 150 + random(-75,75); // 75 to 225
			extradmg1 = (PlayerDEF * 9) / 2;		// 450% of Defense		[2 pt[s] = 9 more unit[s] of damage]
			extradmg2 = (PlayerDFT * 9) / 16;		// 56.25% of Deftness	[16 pt[s] = 9 more unit[s] of damage]
			extradmg3 = (PlayerSOR * 27) / 8;		// 337.5% of Sorcery	[8 pt[s] = 27 more unit[s] of damage]
		}
		// SpectralLightningH1New
		if (attacktype == 5)
		{
			damage = 175 + random(-87,87); // 88 to 242
			extradmg1 = (PlayerDEF * 21) / 4;		// 525% of Defense		[4 pt[s] = 21 more unit[s] of damage]
			extradmg2 = (PlayerDFT * 21) / 32;	// 65.625% of Deftness	[32 pt[s] = 21 more unit[s] of damage]
			extradmg3 = (PlayerSOR * 63) / 16;	// 393.75% of Sorcery	[16 pt[s] = 63 more unit[s] of damage]
		}
		// SpectralLightningH2New
		if (attacktype == 6)
		{
			damage = 50 + random(-25,25); // 25 to 75
			extradmg1 = (PlayerDEF * 9) / 6;		// 150% of Defense		[6 pt[s] = 9 more unit[s] of damage]
			extradmg2 = (PlayerDFT * 9) / 48;		// 18.75% of Deftness	[48 pt[s] = 9 more unit[s] of damage]
			extradmg3 = (PlayerSOR * 27) / 24;	// 112.5% of Sorcery	[24 pt[s] = 27 more unit[s] of damage]
		}
		// SpectralLightningH3New
		if (attacktype == 7)
		{
			damage = 25 + random(-12,12); // 13 to 37
			extradmg1 = (PlayerDEF * 9) / 12;		// 75% of Defense		[12 pt[s] = 9 more unit[s] of damage]
			extradmg2 = (PlayerDFT * 9) / 96;		// 9.375% of Deftness	[96 pt[s] = 9 more unit[s] of damage]
			extradmg3 = (PlayerSOR * 27) / 48;	// 56.25% of Sorcery	[48 pt[s] = 27 more unit[s] of damage]
		}
		// SpectralLightningBigBall1New
		if (attacktype == 8)
		{
			damage = 325 + random(-162,162); // 163 to 387
			extradmg1 = (PlayerDEF * 10) / 1;		// 1000% of Defense		[1 pt[s] = 10 more unit[s] of damage]
			extradmg2 = (PlayerDFT * 10) / 8;		// 125% of Deftness	[8 pt[s] = 210 more unit[s] of damage]
			extradmg3 = (PlayerSOR * 30) / 4;		// 750% of Sorcery		[4 pt[s] = 30 more unit[s] of damage]
		}
		
		// Final Calculations
		int BaseSigilMaxHealth = CallACS("MiscVarCheckDECORATE",298);
		int stamdamagefactor = CallACS("MiscVarCheckDECORATE",317);
		int accudamagefactor = CallACS("MiscVarCheckDECORATE",318);
		int MaxHealthTrue = CallACS("StatCheck",1);
		string AttackerName = "NONE";
		if (target) AttackerName = target.GetClassName();
		String nm, nn, no, np;
		if (radiustype == 0) // Direct Damage is randomized
		{
			if (AttackerName == "FloraBriscoletti") // if (IsPointerEqual(AAPTR_TARGET, AAPTR_PLAYER1) == TRUE) // AAPTR_TARGET - the being who fires the shot
			{
				if (debugplayeratkinfo) Console.Printf("Player Sigil Shot (%s), %d", AttackerName, attacktype);
				
				rand1 = (extradmg1 + extradmg2 + extradmg3 + extradmg4 + extradmg5 + extradmg6) * 7 / 10;
				rand2 = (extradmg1 + extradmg2 + extradmg3 + extradmg4 + extradmg5 + extradmg6) * 13 / 10;
				finaldmg = damage + random(rand1,rand2);
				
				if (stamdamagefactor == 1) finaldmg = finaldmg * 45 / 40; // +12.5% damage
				if (stamdamagefactor == 2) finaldmg = finaldmg * 51 / 40; // +27.5% damage
				if (stamdamagefactor == 3) finaldmg = finaldmg * 58 / 40; // +45% damage
				if (stamdamagefactor == 4) finaldmg = finaldmg * 66 / 40; // +65% damage
				if (stamdamagefactor == 5) finaldmg = finaldmg * 75 / 40; // +87.5% damage
				if (stamdamagefactor == 6) finaldmg = finaldmg * 85 / 40; // +112.5% damage
				if (stamdamagefactor == 7) finaldmg = finaldmg * 96 / 40; // +140% damage
				if (stamdamagefactor == 8) finaldmg = finaldmg * 108 / 40; // +170% damage
				if (stamdamagefactor == 9) finaldmg = finaldmg * 121 / 40; // +202.5% damage
				if (stamdamagefactor == 10) finaldmg = finaldmg * 135 / 40; // +237.5% damage
			
				if (accudamagefactor == 1) finaldmg = finaldmg * 85 / 80; // +6.25% damage
				if (accudamagefactor == 2) finaldmg = finaldmg * 91 / 80; // +13.75% damage
				if (accudamagefactor == 3) finaldmg = finaldmg * 98 / 80; // +22.5% damage
				if (accudamagefactor == 4) finaldmg = finaldmg * 106 / 80; // +32.5% damage
				if (accudamagefactor == 5) finaldmg = finaldmg * 115 / 80; // +43.75% damage
				if (accudamagefactor == 6) finaldmg = finaldmg * 125 / 80; // +56.25% damage
				if (accudamagefactor == 7) finaldmg = finaldmg * 136 / 80; // +70% damage
				if (accudamagefactor == 8) finaldmg = finaldmg * 148 / 80; // +85% damage
				if (accudamagefactor == 9) finaldmg = finaldmg * 161 / 80; // +101.25% damage
				if (accudamagefactor == 10) finaldmg = finaldmg * 175 / 80; // +118.75% damage
			
				int prefinaldmg = finaldmg;
				int hpextradmg = 100;
				int hpextradmgfactor = (MaxHealthTrue * 100);
				int hpextradmg2 = (hpextradmgfactor / BaseSigilMaxHealth) / 5;
				int hpextradmg3 = (hpextradmg + hpextradmg2);
				finaldmg = (finaldmg * hpextradmg3) / 100;
			
				if (debugplayeratkinfo) Console.Printf("\cy(%s)\c-: BaseDmg: %d, Extra1: %d, Extra2: %d, Extra3: %d, Extra4: %d, Extra5: %d, Extra6: %d, Original Max HP: %d, Current Max HP: %d, hpextradmg: %d, hpextradmgfactor: %d, hpextradmg2: %d, hpextradmg3: %d, Random: %d - %d, PerkFactor: %d, Total [Pre Max HP Check] %d, \cxTotal [Post Max HP Check]: %d\c-", 
																GetClassName(), damage, extradmg1, extradmg2, extradmg3, extradmg4, extradmg5, extradmg6, 
																BaseSigilMaxHealth, MaxHealthTrue, hpextradmg, hpextradmgfactor, hpextradmg2, hpextradmg3, 
																rand1, rand2, perkfactor, prefinaldmg, finaldmg);
			}
			else // If something that's NOT the player shoots it...
			{
				if (debugplayeratkinfo) Console.Printf("Non-Player/Spectre/Entity Sigil Shot (%s), %d", AttackerName, attacktype);

				prefinaldmg = damage;
				finaldmg = damage;
				if (attacktype != 0) finaldmg = finaldmg * random(1,4); // +STRIFEDAMAGE calculation
				nm = "EntityBossNew"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = finaldmg * 6 / 4;
				nm = "EntitySecondNew"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = finaldmg * 6 / 4;
				nm = "EntityAscended"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = finaldmg * 9 / 4;

				if (debugplayeratkinfo) Console.Printf("\cy(%s)\c-: BaseDmg: %d, PreTotal: %d, \cxTotal: %d\c-", GetClassName(), damage, prefinaldmg, finaldmg);
			}
		}
		else // Radius is NOT randomized
		{
			if (debugplayeratkinfo) Console.Printf("\cy(%s)\c-: BaseDmg: %d, Extra1: %d, Extra2: %d, Extra3: %d, Extra4: %d, Extra5: %d, Extra6: %d, PerkFactor: %d, \cxTotal: %d\c-", 
															GetClassName(), damage, extradmg1, extradmg2, extradmg3, extradmg4, extradmg5, extradmg6, perkfactor, finaldmg);
		}
		if (radiustype == 0) 
		{
			finaldamagedealt = finaldmg;
			if (debugplayeratkinfo) Console.Printf("\cxSigil Damage Total: %d (%d)\c-", finaldmg, finaldamagedealt);
		}
		if (radiustype == 1) 
		{
			finaldamagedealt2 = finaldmg;
			if (debugplayeratkinfo) Console.Printf("\cxSigil Radius Total: %d (%d)\c-", finaldmg, finaldamagedealt2);
		}
	}
	
	int A_GetMiscDMG(int type = 0)
	{
		int damage;
		string actorname = GetClassName();
		int miscdmgdebug = dvdsdebug_showmiscdmginformation;
		
		if (type == 1) // Minor Magic Missile [particle]
		{
			if (random(1,1000) > 667) damage = (1 + random(-1,0));
													else damage = (2 + random(-1,1));
		}
		
		if (type == 2) // Magic Missile [particle]
		{
			if (random(1,1000) > 667) damage = (6 + random(-1,2));
													else damage = (10 + random(-3,3));
		}
		
		if (type == 3) // Major Magic Missile [particle]
		{
			if (random(1,1000) > 667) damage = (12 + random(-3,4));
													else damage = (20 + random(-7,8));
		}
		
		if (type == 4) // Ultra Magic Missile [particle]
		{
			if (random(1,1000) > 667) damage = (24 + random(-13,14));
													else damage = (40 + random(-22,23));
		}
		
		if (miscdmgdebug) Console.Printf("MM Particle Dmg: (%s) %d", actorname, damage);
		finaldamagedealt = damage;
		return damage;
	}

	double A_GetBFGTracerAngle()
	{
		int debugplayeratkinfo = dvdsdebug_showplayeratkinformation;
		int result = 90;
		int BFGAttunementPerkLevel = CallACS("MiscVarCheckDECORATE",10029);
		int BFGAttunementEXPerkLevel = CallACS("MiscVarCheckDECORATE",10030);
		if (BFGAttunementPerkLevel >= 1) result += 22;
		if (BFGAttunementPerkLevel >= 2) result += 23;
		if (BFGAttunementEXPerkLevel >= 1) result += 33;
		if (BFGAttunementEXPerkLevel >= 2) result += 34;
		if (debugplayeratkinfo) Console.Printf("BFG Tracer Angle: %d (Perks: %d - %d)", result, BFGAttunementPerkLevel, BFGAttunementEXPerkLevel);

		BFGTracerAngle = result;
		return result;
	}
	
	double A_GetBFGTracerVAngle()
	{
		int debugplayeratkinfo = dvdsdebug_showplayeratkinformation;
		int result = 32;
		int BFGAttunementPerkLevel = CallACS("MiscVarCheckDECORATE",10029);
		int BFGAttunementEXPerkLevel = CallACS("MiscVarCheckDECORATE",10030);
		if (BFGAttunementPerkLevel >= 1) result += 8;
		if (BFGAttunementPerkLevel >= 2) result += 8;
		if (BFGAttunementEXPerkLevel >= 1) result += 12;
		if (BFGAttunementEXPerkLevel >= 2) result += 12;
		if (debugplayeratkinfo) Console.Printf("BFG Tracer Vertical Angle: %d (Perks: %d - %d)", result, BFGAttunementPerkLevel, BFGAttunementEXPerkLevel);

		BFGTracerVAngle = result;
		return result;
	}
	
	double A_GetBFGTracerDistance()
	{
		int debugplayeratkinfo = dvdsdebug_showplayeratkinformation;
		int result = 1024;
		int BFGAttunementPerkLevel = CallACS("MiscVarCheckDECORATE",10029);
		int BFGAttunementEXPerkLevel = CallACS("MiscVarCheckDECORATE",10030);
		if (BFGAttunementPerkLevel >= 1) result += 256;
		if (BFGAttunementPerkLevel >= 2) result += 256;
		if (BFGAttunementEXPerkLevel >= 1) result += 384;
		if (BFGAttunementEXPerkLevel >= 2) result += 384;
		if (debugplayeratkinfo) Console.Printf("BFG Tracer Range: %d (Perks: %d - %d)", result, BFGAttunementPerkLevel, BFGAttunementEXPerkLevel);

		BFGTracerRange = result;
		return result;
	}
	
	int A_GetBFGTracers()
	{
		int debugplayeratkinfo = dvdsdebug_showplayeratkinformation;
		int result = 40;
		int BFGAttunementPerkLevel = CallACS("MiscVarCheckDECORATE",10029);
		int BFGAttunementEXPerkLevel = CallACS("MiscVarCheckDECORATE",10030);
		if (BFGAttunementPerkLevel >= 1) result += 8;
		if (BFGAttunementPerkLevel >= 2) result += 8;
		if (BFGAttunementEXPerkLevel >= 1) result += 12;
		if (BFGAttunementEXPerkLevel >= 2) result += 12;
		if (debugplayeratkinfo) Console.Printf("BFG Tracers: %d (Perks: %d - %d)", result, BFGAttunementPerkLevel, BFGAttunementEXPerkLevel);

		BFGTracers = result;
		return result;
	}
	
	int A_MeleeImpactRadius(int attacktype)
	{
		double radius;
		double radiuserror;
		int ClassicDoomType = CallACS("OtherVarCheckDECORATE",7);
		int SceptreActualLevel = CallACS("OtherVarCheckDECORATE",11);
		int PlayerSTR = CallACS("MiscVarCheckDECORATE",35);
		int stamdamagefactor = CallACS("MiscVarCheckDECORATE",317);
		int CharacterClass = CallACS("CheckCharacterClass");
		int debugmelee = dvdsdebug_showmeleeinformation;

		if (attacktype == 0) // Sceptre [Normal]
		{
			radius = ((80 + (5 * SceptreActualLevel)) + (PlayerSTR * (32 + SceptreActualLevel) / 32));
			radiuserror = frandom(0.375,0.625);
		}
		else
		if (attacktype == 1) // Sceptre [Aireal]
		{
			radius = ((80 + (5 * SceptreActualLevel)) + (PlayerSTR * (32 + SceptreActualLevel) / 32));
			radiuserror = frandom(0.375,0.625);
		}
		else
		if (attacktype == 2) // Sceptre [Spinning]
		{
			radius = ((20 + (1.25 * SceptreActualLevel)) + (PlayerSTR * (128 + SceptreActualLevel) / 128));
			radiuserror = frandom(0.375,0.625);
		}
		else
		if (attacktype == 3) // Punch [unarmed] (normal)
		{
			radius = 16 + (PlayerSTR / 8);
			radiuserror = frandom(0.84375,1.15625);
		}
		else
		if (attacktype == 4) // Punch [unarmed] (alt-fire)
		{
			radius = 24 + (PlayerSTR / 6);
			radiuserror = frandom(0.84375,1.15625);
		}
		else
		if (attacktype == 5) // Punch [w/ Gauntlets] (normal)
		{
			radius = 40 + (PlayerSTR / 3);
			radiuserror = frandom(0.84375,1.15625);
		}
		else
		if (attacktype == 6) // Punch [w/ Gauntlets] (alt-fire)
		{
			radius = 64 + (PlayerSTR / 2);
			radiuserror = frandom(0.84375,1.15625);
		}
		else
		if (attacktype == 7) // Thrust Kick
		{
			radius = 24 + (PlayerSTR / 4);
			radiuserror = frandom(0.84375,1.15625);
		}
		else
		if (attacktype == 8) // Spinning/Roundhouse Kick
		{
			radius = 36 + (PlayerSTR / 3);
			radiuserror = frandom(0.84375,1.15625);
		}
		radius *= radiuserror;
		int baseradius = radius;
		//****************
		if (debugmelee) Console.Printf("EXPLRadius [Base]: %d [RadError: %.8f]", radius, radiuserror);

		if (stamdamagefactor > 0) radius = (radius * (16 + (stamdamagefactor * 3.2)) / 16);
		if (debugmelee) Console.Printf("EXPLRadius [StaminaUpgrades]: %d", radius);

		if (CharacterClass == 0) radius = radius * 5 / 4;
		if (CharacterClass == 1) radius = radius * 9 / 8;
		if (debugmelee) Console.Printf("EXPLRadius [Class-Check]: %d", radius);
		
		if (CallACS("GetBuffTimer",7) > 0) 
		{
			radius = radius * 6 / 5; // 1.2x Radius [Divine Avatar]
			if (debugmelee) Console.Printf("EXPLRadius [Divine]: %d", radius);
		}

		if (CountInv("AetheriusPowerStrength",AAPTR_PLAYER1) > 0) 
		{
			radius = radius * 11 / 8; // 1.375x Radius [Berserk]
			if (debugmelee) Console.Printf("EXPLRadius [Berserk]: %d", radius);
		}
		
		if (ClassicDoomType == 5)
		{
			radius = radius * 6 / 5; // 1.2x in Doom64 due to scaling up of general maps, etc :V
			if (debugmelee) Console.Printf("EXPLRadius [Final]: %d [Base: %d]", radius, baseradius);
		}

		MeleeImpactRad = radius;
		return radius;
	}

	// Quake tremor effects
	int A_QuakeMeleeIntensity(int attacktype = 0)
	{
		int intensity;
		int ClassicDoomType = CallACS("OtherVarCheckDECORATE",7);
		int SceptreActualLevel = CallACS("OtherVarCheckDECORATE",11);
		int PlayerSTR = CallACS("MiscVarCheckDECORATE",35);
		int stamdamagefactor = CallACS("MiscVarCheckDECORATE",317);
		int CharacterClass = CallACS("CheckCharacterClass");
		int debugmelee = dvdsdebug_showmeleeinformation;

		if (attacktype == 0) // Sceptre [Normal]
		{
			if (SceptreActualLevel <= 0) intensity = 1;
			if (SceptreActualLevel == 1) intensity = 1;
			if (SceptreActualLevel == 2) intensity = 1;
			if (SceptreActualLevel == 3) intensity = 1;
			if (SceptreActualLevel == 4) intensity = 1;
			if (SceptreActualLevel == 5) intensity = 1;
			if (SceptreActualLevel == 6) intensity = 1;
			if (SceptreActualLevel == 7) intensity = 1;
			if (SceptreActualLevel == 8) intensity = 2;
			if (SceptreActualLevel == 9) intensity = 2;
			if (SceptreActualLevel == 10) intensity = 2;
			if (SceptreActualLevel == 11) intensity = 2;
			if (SceptreActualLevel == 12) intensity = 2;
			if (SceptreActualLevel == 13) intensity = 2;
			if (SceptreActualLevel == 14) intensity = 2;
			if (SceptreActualLevel == 15) intensity = 2;
			if (SceptreActualLevel >= 16) intensity = 3;
			intensity = intensity + (PlayerSTR / 12);
		}
		else
		if (attacktype == 1) // Sceptre [Aireal]
		{
		}
		else
		if (attacktype == 2) // Sceptre [Spinning]
		{
			if (SceptreActualLevel <= 0) intensity = 0;
			if (SceptreActualLevel == 1) intensity = 0;
			if (SceptreActualLevel == 2) intensity = 0;
			if (SceptreActualLevel == 3) intensity = 0;
			if (SceptreActualLevel == 4) intensity = 0;
			if (SceptreActualLevel == 5) intensity = 0;
			if (SceptreActualLevel == 6) intensity = 0;
			if (SceptreActualLevel == 7) intensity = 0;
			if (SceptreActualLevel == 8) intensity = 0;
			if (SceptreActualLevel == 9) intensity = 0;
			if (SceptreActualLevel == 10) intensity = 0;
			if (SceptreActualLevel == 11) intensity = 0;
			if (SceptreActualLevel == 12) intensity = 0;
			if (SceptreActualLevel == 13) intensity = 0;
			if (SceptreActualLevel == 14) intensity = 0;
			if (SceptreActualLevel == 15) intensity = 0;
			if (SceptreActualLevel >= 16) intensity = 0;
			intensity = intensity + (PlayerSTR / 32);
		}
		else
		if (attacktype == 3) // Punch [unarmed] (normal)
		{
			intensity = 0 + (PlayerSTR / 32);
		}
		else
		if (attacktype == 4) // Punch [unarmed] (alt-fire/uppercut)
		{
			intensity = 0 + (PlayerSTR / 24);
		}
		else
		if (attacktype == 5) // Punch [w/ Gauntlets] (normal)
		{
			intensity = 1 + (PlayerSTR / 12);
		}
		else
		if (attacktype == 6) // Punch [w/ Gauntlets] (alt-fire)
		{
			intensity = 1 + (PlayerSTR / 8);
		}
		else
		if (attacktype == 7) // Thrust Kick
		{
			intensity = 0 + (PlayerSTR / 16);
		}
		else
		if (attacktype == 8) // Spinning/Roundhouse Kick
		{
			intensity = 0 + (PlayerSTR / 12);
		}

		int baseintensity = intensity;
		if (debugmelee) Console.Printf("Intensity [Base]: %d", intensity);

		if (stamdamagefactor > 0) intensity += (stamdamagefactor / 4);
		if (debugmelee) Console.Printf("Intensity [StaminaUpgrades]: %d", intensity);

		if (CharacterClass == 0) intensity = intensity * 3 / 2;
		if (CharacterClass == 1) intensity = intensity * 5 / 4;
		if (debugmelee) Console.Printf("Intensity [CharacterCheck]: %d", intensity);
		
		if (CountInv("AetheriusPowerStrength",AAPTR_PLAYER1) > 0)
		{
			if (intensity <= 0) intensity += 1; else intensity = (intensity * 3) / 2;
			if (debugmelee) Console.Printf("Intensity [Berserk]: %d", intensity);
		}
		
		if (debugmelee) Console.Printf("Intensity [Final]: %d, [Base: %d]", intensity, baseintensity);

		QuakeIntensity = intensity;
		return intensity;
	}
	
	int A_QuakeMeleeDuration(int attacktype = 0)
	{
		int duration;
		int ClassicDoomType = CallACS("OtherVarCheckDECORATE",7);
		int SceptreActualLevel = CallACS("OtherVarCheckDECORATE",11);
		int PlayerSTR = CallACS("MiscVarCheckDECORATE",35);
		int stamdamagefactor = CallACS("MiscVarCheckDECORATE",317);
		int CharacterClass = CallACS("CheckCharacterClass");
		int debugmelee = dvdsdebug_showmeleeinformation;

		if (attacktype == 0) // Sceptre [Normal]
		{
			if (SceptreActualLevel <= 0) duration = 8;
			if (SceptreActualLevel == 1) duration = 8;
			if (SceptreActualLevel == 2) duration = 9;
			if (SceptreActualLevel == 3) duration = 9;
			if (SceptreActualLevel == 4) duration = 10;
			if (SceptreActualLevel == 5) duration = 10;
			if (SceptreActualLevel == 6) duration = 11;
			if (SceptreActualLevel == 7) duration = 11;
			if (SceptreActualLevel == 8) duration = 12;
			if (SceptreActualLevel == 9) duration = 12;
			if (SceptreActualLevel == 10) duration = 13;
			if (SceptreActualLevel == 11) duration = 13;
			if (SceptreActualLevel == 12) duration = 14;
			if (SceptreActualLevel == 13) duration = 14;
			if (SceptreActualLevel == 14) duration = 15;
			if (SceptreActualLevel == 15) duration = 15;
			if (SceptreActualLevel >= 16) duration = 16;
			duration = duration + (PlayerSTR / 10);
		}
		else
		if (attacktype == 1) // Sceptre [Aireal]
		{
		}
		else
		if (attacktype == 2) // Sceptre [Spinning]
		{
			if (SceptreActualLevel <= 0) duration = 2;
			if (SceptreActualLevel == 1) duration = 2;
			if (SceptreActualLevel == 2) duration = 2;
			if (SceptreActualLevel == 3) duration = 2;
			if (SceptreActualLevel == 4) duration = 2;
			if (SceptreActualLevel == 5) duration = 2;
			if (SceptreActualLevel == 6) duration = 2;
			if (SceptreActualLevel == 7) duration = 2;
			if (SceptreActualLevel == 8) duration = 3;
			if (SceptreActualLevel == 9) duration = 3;
			if (SceptreActualLevel == 10) duration = 3;
			if (SceptreActualLevel == 11) duration = 3;
			if (SceptreActualLevel == 12) duration = 3;
			if (SceptreActualLevel == 13) duration = 3;
			if (SceptreActualLevel == 14) duration = 3;
			if (SceptreActualLevel == 15) duration = 3;
			if (SceptreActualLevel >= 16) duration = 4;
			duration = duration + (PlayerSTR / 40);
		}
		else
		if (attacktype == 3) // Punch [unarmed] (normal)
		{
			duration = 2;
			duration = duration + (PlayerSTR / 40);
		}
		else
		if (attacktype == 4) // Punch [unarmed] (alt-fire)
		{
			duration = 3;
			duration = duration + (PlayerSTR / 28);
		}
		else
		if (attacktype == 5) // Punch [w/ Gauntlets] (normal)
		{
			duration = 6;
			duration = duration + (PlayerSTR / 14);
		}
		else
		if (attacktype == 6) // Punch [w/ Gauntlets] (alt-fire)
		{
			duration = 8;
			duration = duration + (PlayerSTR / 10);
		}
		else
		if (attacktype == 7) // Thrust Kick
		{
			duration = 4;
			duration = duration + (PlayerSTR / 20);
		}
		else
		if (attacktype == 8) // Spinning/Roundhouse Kick
		{
			duration = 6;
			duration = duration + (PlayerSTR / 14);
		}
		int baseduration = duration;
		
		if (stamdamagefactor > 0) duration = (duration * (16 + (stamdamagefactor * 3.2)) / 16);
		int stamduration = duration;
		if (CharacterClass == 0) duration = duration * 3 / 2;
		if (CharacterClass == 1) duration = duration * 5 / 4;
		int charduration = duration;
		
		if (CallACS("GetBuffTimer",7) > 0) duration = duration * 3 / 2;
		int dvavduration = duration;
		
		if (CountInv("AetheriusPowerStrength",AAPTR_PLAYER1) > 0) duration *= 4;
		int bersduration = duration;
		
		if (debugmelee) 
		{
			Console.Printf("Duration [Base]: %d, Duration [StaminaUpgrades]: %d, Duration [CharacterCheck]: %d, Duration [DivineAvatar]: %d, Duration [Berserk]: %d, \cxDuration [Final]: %d\c-", baseduration, stamduration, charduration, dvavduration, bersduration, duration);
		}
		
		QuakeDuration = duration;
		return duration;
	}
	
	int A_QuakeMeleeTremrad(int attacktype = 0)
	{
		int tremrad;
		int ClassicDoomType = CallACS("OtherVarCheckDECORATE",7);
		int SceptreActualLevel = CallACS("OtherVarCheckDECORATE",11);
		int PlayerSTR = CallACS("MiscVarCheckDECORATE",35);
		int stamdamagefactor = CallACS("MiscVarCheckDECORATE",317);
		int CharacterClass = CallACS("CheckCharacterClass");
		int debugmelee = dvdsdebug_showmeleeinformation;

		if (attacktype == 0) // Sceptre [Normal]
		{
			if (SceptreActualLevel <= 0) tremrad = 512;
			if (SceptreActualLevel == 1) tremrad = 544;
			if (SceptreActualLevel == 2) tremrad = 576;
			if (SceptreActualLevel == 3) tremrad = 608;
			if (SceptreActualLevel == 4) tremrad = 640;
			if (SceptreActualLevel == 5) tremrad = 672;
			if (SceptreActualLevel == 6) tremrad = 704;
			if (SceptreActualLevel == 7) tremrad = 736;
			if (SceptreActualLevel == 8) tremrad = 768;
			if (SceptreActualLevel == 9) tremrad = 800;
			if (SceptreActualLevel == 10) tremrad = 832;
			if (SceptreActualLevel == 11) tremrad = 864;
			if (SceptreActualLevel == 12) tremrad = 896;
			if (SceptreActualLevel == 13) tremrad = 928;
			if (SceptreActualLevel == 14) tremrad = 960;
			if (SceptreActualLevel == 15) tremrad = 992;
			if (SceptreActualLevel >= 16) tremrad = 1024;
			tremrad = tremrad + (PlayerSTR * 4);
		}
		else
		if (attacktype == 1) // Sceptre [Aireal]
		{
		}
		else
		if (attacktype == 2) // Sceptre [Spinning]
		{
			if (SceptreActualLevel <= 0) tremrad = 128;
			if (SceptreActualLevel == 1) tremrad = 136;
			if (SceptreActualLevel == 2) tremrad = 144;
			if (SceptreActualLevel == 3) tremrad = 152;
			if (SceptreActualLevel == 4) tremrad = 160;
			if (SceptreActualLevel == 5) tremrad = 168;
			if (SceptreActualLevel == 6) tremrad = 176;
			if (SceptreActualLevel == 7) tremrad = 184;
			if (SceptreActualLevel == 8) tremrad = 192;
			if (SceptreActualLevel == 9) tremrad = 200;
			if (SceptreActualLevel == 10) tremrad = 208;
			if (SceptreActualLevel == 11) tremrad = 216;
			if (SceptreActualLevel == 12) tremrad = 224;
			if (SceptreActualLevel == 13) tremrad = 232;
			if (SceptreActualLevel == 14) tremrad = 240;
			if (SceptreActualLevel == 15) tremrad = 248;
			if (SceptreActualLevel >= 16) tremrad = 256;
			tremrad = tremrad + (PlayerSTR);
		}
		else
		if (attacktype == 3) // Punch [unarmed] (normal)
		{
			tremrad = 256;
			tremrad = tremrad + (PlayerSTR);
		}
		else
		if (attacktype == 4) // Punch [unarmed] (alt-fire)
		{
			tremrad = 320;
			tremrad = tremrad + ((PlayerSTR * 5) / 4);
		}
		else
		if (attacktype == 5) // Punch [w/ Gauntlets] (normal)
		{
			tremrad = 844;
			tremrad = tremrad + (PlayerSTR * 13 / 4);
		}
		else
		if (attacktype == 6) // Punch [w/ Gauntlets] (alt-fire)
		{
			tremrad = 1024;
			tremrad = tremrad + (PlayerSTR * 4);
		}
		else
		if (attacktype == 7) // Thrust Kick
		{
			tremrad = 384;
			tremrad = tremrad + ((PlayerSTR * 7) / 4);
		}
		else
		if (attacktype == 8) // Spinning/Roundhouse Kick
		{
			tremrad = 480;
			tremrad = tremrad + ((PlayerSTR * 13) / 4);
		}
		int basetremrad = tremrad;
		
		if (stamdamagefactor > 0) tremrad = (tremrad * (16 + (stamdamagefactor * 3.2)) / 16);
		int stamtremrad = tremrad;
		
		if (CharacterClass == 0) tremrad = tremrad * 3 / 2;
		if (CharacterClass == 1) tremrad = tremrad * 5 / 4;
		int chartremrad = tremrad;
		
		if (CallACS("GetBuffTimer",7) > 0) tremrad = tremrad * 3 / 2;
		int dvavtremrad = tremrad;
		
		if (CountInv("AetheriusPowerStrength",AAPTR_PLAYER1) > 0) tremrad *= 8;
		int berstremrad = tremrad;
		
		if (debugmelee)
		{
			Console.Printf("TremRad [Base]: %d, TremRad [StaminaUpgrades]: %d, TremRad [CharacterCheck]: %d, TremRad [DivineAvatar]: %d, TremRad [Berserk]: %d, \cxTremRad [Final]: %d\c-", basetremrad, stamtremrad, chartremrad, dvavtremrad, berstremrad, tremrad);
		}

		QuakeTremRad = tremrad;
		return tremrad;
	}
	
	int A_GetPoisonCloudDMG(int level)
	{
		int basedamage;
		int damage;
		int extradamage;
		int postdamage1;
		int postdamage2;
		int postdamage3;
		int lowcap;
		int lowcaprand;
		int CharacterClass = CallACS("CheckCharacterClass");
		int DivineAvatarTimer = CallACS("GetBuffTimer",7);
		int debugplayeratkinfo = dvdsdebug_showplayeratkinformation;
		int PlayerLevel = CallACS("StatCheck",0);
		int PlayerSOR = CallACS("MiscVarCheckDECORATE",34);
		int PlayerTHE = CallACS("MiscVarCheckDECORATE",36);
		int poisonclouddebug;
		
		if (Level == 0) { basedamage = random(16,24); lowcap = 8; } // Minor
		if (Level == 1) { basedamage = random(36,48); lowcap = 16; } // Normal
		if (Level == 2) { basedamage = random(72,88); lowcap = 32; } // Major
		
		if (Level == 3) { basedamage = random(4,6); lowcap = 2; } // Minor [left]
		if (Level == 4) { basedamage = random(9,12); lowcap = 4; } // Normal [left]
		if (Level == 5) { basedamage = random(18,22); lowcap = 8; } // Major [left]
		lowcaprand = lowcap * 3 / 2;
		damage = basedamage;
		
		if (CharacterClass == 0) postdamage1 = damage * 32 / 10;
		if (CharacterClass == 1) postdamage1 = damage * 21 / 10;
		if (CharacterClass == 2) postdamage1 = damage * 10 / 10;
		if (CharacterClass == 8) postdamage1 = damage * 24 / 10;
		if (CharacterClass == 9) postdamage1 = damage * 16 / 10;
		damage = postdamage1;
		
		if (CharacterClass == 0) extradamage = damage * (PlayerSOR / 2) / 60;
		if (CharacterClass == 1) extradamage = damage * (PlayerSOR / 2) / 68;
		if (CharacterClass == 2) extradamage = damage * (PlayerSOR / 2) / 76;
		if (CharacterClass == 8) extradamage = damage * (PlayerSOR / 2) / 64;
		if (CharacterClass == 9) extradamage = damage * (PlayerSOR / 2) / 70;
		damage += extradamage;
		
		if (damage < lowcap) damage = random(lowcap,lowcaprand);
		
		string actorname = GetClassName();

		if (debugplayeratkinfo) Console.Printf("\Poison Cloud Damage (%s):\c- FinalDamage: %d, BaseDamage: %d, ExtraDamage: %d, PostDamage1: %d, LowCap: %d, LowCapRand: %d", actorname, damage, basedamage, extradamage, postdamage1, lowcap, lowcaprand);
		finaldamagedealt = damage;

		if (debugplayeratkinfo) Console.Printf("PoisonCloudDmg: %d", finaldamagedealt);
		return damage;
	}
	
	int A_GetPSNCloudVortexSTR(int CloudSize = 0, int radtype = 0)
	{
		int poisonclouddebug;
		int debugplayeratkinfo = dvdsdebug_showplayeratkinformation;
		int PlayerSOR = CallACS("MiscVarCheckDECORATE",34);
		int PlayerTHE = CallACS("MiscVarCheckDECORATE",36);

		int VortexStrength = 256;
		int Extra;
		if (CloudSize == 0) // Minor
		{
			if (radtype == 1)
			{
				VortexStrength = 64; // 25%
				Extra = (PlayerSOR * 1) + (PlayerTHE / 2);
			}
			else
			{
				VortexStrength = 256; // 100%
				Extra = (PlayerSOR * 4) + (PlayerTHE * 2);
			}
		}
		
		if (CloudSize == 1) // Normal
		{
			if (radtype == 1)
			{
				VortexStrength = 128; // 50%
				Extra = (PlayerSOR * 2) + (PlayerTHE * 1);
			}
			else
			{
				VortexStrength = 512; // 200%
				Extra = (PlayerSOR * 8) + (PlayerTHE * 4);
			}
		}
		
		if (CloudSize == 2) // Major
		{
			if (radtype == 1)
			{
				VortexStrength = 256; // 100%
				Extra = (PlayerSOR * 4) + (PlayerTHE * 2);
			}
			else
			{
				VortexStrength = 1024; // 400%
				Extra = (PlayerSOR * 16) + (PlayerTHE * 8);
			}
		}
		
		VortexStrength += Extra;
		VortexStrength *= -1;

		VortStrength = VortexStrength;
		if (debugplayeratkinfo) Console.Printf("VortStrength: %d", VortStrength);
		return VortexStrength;
	}
	
	int A_GetPSNCloudVortexDIST(int CloudSize = 0, int type = 0, int particlespawn = 0, int pulltype = 0)
	{
		int poisonclouddebug;
		int debugplayeratkinfo = dvdsdebug_showplayeratkinformation;
		int PlayerSOR = CallACS("MiscVarCheckDECORATE",34);
		int PlayerTHE = CallACS("MiscVarCheckDECORATE",36);

		int VortexDistance = 80;
		int VortexDistance2;
		int Extra;
		if (CloudSize == 0) // Minor
		{
			if (pulltype == 1)
			{
				VortexDistance = 240; // 300%
				Extra = (PlayerSOR * 8) + (PlayerTHE * 4);
			}
			else
			{
				VortexDistance = 80; // 100%
				Extra = (PlayerSOR * 2) + (PlayerTHE * 1);
			}
		}
		
		if (CloudSize == 1) // Normal
		{
			if (pulltype == 1)
			{
				VortexDistance = 420; // 525%
				Extra = (PlayerSOR * 14) + (PlayerTHE * 28);
			}
			else
			{
				VortexDistance = 140; // 175%
				Extra = (PlayerSOR * 4) + (PlayerTHE * 2);
			}
		}
		
		if (CloudSize == 2) // Major
		{
			if (pulltype == 1)
			{
				VortexDistance = 780; // 975%
				Extra = (PlayerSOR * 26) + (PlayerTHE * 52);
			}
			else
			{
				VortexDistance = 260; // 325%
				Extra = (PlayerSOR * 8) + (PlayerTHE * 4);
			}
		}
		
		VortexDistance += Extra;
		if (type == 1) VortexDistance2 = VortexDistance / 2;
		
		if (particlespawn == 1) // Fixed Value
		{
			VortexDistance *= 1.0;
			//VortexDistance = VortexDistance>>16;
		}
		
		VortDistance = VortexDistance;
		VortDistance2 = VortexDistance2;
		if (debugplayeratkinfo) Console.Printf("VortDistance: %d, VortDistance2: %d, Type: %d, ParticleSpawn: %d", VortDistance, VortDistance2, type, particlespawn);
		if (type == 1) return VortexDistance2;
							else return VortexDistance;
	} 
	
	int A_GetPSNCloudDmgRad(int CloudSize = 0, int Type = 0)
	{
		int poisonclouddebug;
		int debugplayeratkinfo = dvdsdebug_showplayeratkinformation;
		int PlayerSOR = CallACS("MiscVarCheckDECORATE",34);
		int PlayerTHE = CallACS("MiscVarCheckDECORATE",36);

		int DmgRad = 40;
		int Extra;
		if (CloudSize == 0) // Minor
		{
			DmgRad = 40;
			Extra = (PlayerSOR * 1) + (PlayerTHE / 2);
		}
		if (CloudSize == 1) // Normal
		{
			DmgRad = 64;
			Extra = (PlayerSOR * 8 / 5) + (PlayerTHE * 4 / 5);
		}
		if (CloudSize == 2) // Major
		{
			DmgRad = 88;
			Extra = (PlayerSOR * 11 / 5) + (PlayerTHE * 7 / 5);
		}
		
		int DmgSmlRad = DmgRad / 4;

		if (Type == 0) 
		{
			if (debugplayeratkinfo) Console.Printf("VortDmgRad: %d", VortDmgRad);
			return DmgRad;
		}
		else 
		{
			if (debugplayeratkinfo) Console.Printf("VortDmgRad2: %d", VortDmgRad2);
			return DmgSmlRad;
		}
	}
	
	void A_GenerateCrisisParticle(int flags = SXF_TRANSFERTRANSLATION | SXF_NOCHECKPOSITION | SXF_TRANSFERSPRITEFRAME | SXF_TRANSFERSCALE | SXF_TRANSFERALPHA)
	{
		double basespread = 0.64;
		double rangexspread = 1.28;
		double rangeyspread = 1.28;
		double rangezspread = 1.28;
		A_SpawnItemEx("AetheriusCrisisParticle", 0,0,0, 0,basespread,0, 0, flags);
		A_SpawnItemEx("AetheriusCrisisParticle", 0,0,0, 0,-basespread,0, 0, flags);
		A_SpawnItemEx("AetheriusCrisisParticle", 0,0,0, 0,0,basespread, 0, flags);
		A_SpawnItemEx("AetheriusCrisisParticle", 0,0,0, 0,0,-basespread, 0, flags);

		A_SpawnItemEx("AetheriusCrisisParticle", 0,0,0, frandom(-rangexspread,rangexspread),frandom(-rangeyspread,rangeyspread),frandom(-rangezspread,rangezspread), 0, flags);
		A_SpawnItemEx("AetheriusCrisisParticle", 0,0,0, frandom(-rangexspread,rangexspread),frandom(-rangeyspread,rangeyspread),frandom(-rangezspread,rangezspread), 0, flags);
		if (random(1,4) <= 3) A_SpawnItemEx("AetheriusCrisisParticle", 0,0,0, frandom(-rangexspread,rangexspread),frandom(-rangeyspread,rangeyspread),frandom(-rangezspread,rangezspread), 0, flags);
		if (random(1,4) <= 3) A_SpawnItemEx("AetheriusCrisisParticle", 0,0,0, frandom(-rangexspread,rangexspread),frandom(-rangeyspread,rangeyspread),frandom(-rangezspread,rangezspread), 0, flags);
		if (random(1,4) <= 2) A_SpawnItemEx("AetheriusCrisisParticle", 0,0,0, frandom(-rangexspread,rangexspread),frandom(-rangeyspread,rangeyspread),frandom(-rangezspread,rangezspread), 0, flags);
		if (random(1,4) <= 2) A_SpawnItemEx("AetheriusCrisisParticle", 0,0,0, frandom(-rangexspread,rangexspread),frandom(-rangeyspread,rangeyspread),frandom(-rangezspread,rangezspread), 0, flags);
		if (random(1,4) <= 1) A_SpawnItemEx("AetheriusCrisisParticle", 0,0,0, frandom(-rangexspread,rangexspread),frandom(-rangeyspread,rangeyspread),frandom(-rangezspread,rangezspread), 0, flags);
		if (random(1,4) <= 1) A_SpawnItemEx("AetheriusCrisisParticle", 0,0,0, frandom(-rangexspread,rangexspread),frandom(-rangeyspread,rangeyspread),frandom(-rangezspread,rangezspread), 0, flags);
	}
}

// Base Normal Projectile Class
class AetheriusProjectileZSC : AetheriusBaseProjectileZSC
{
	const SHARDSPAWN_LEFT	= 1;
	const SHARDSPAWN_RIGHT	= 2;
	const SHARDSPAWN_UP		= 4;
	const SHARDSPAWN_DOWN	= 8;

	int user_noseektimer, user_seektimer; // For Magic Missiles
	int projtouchedshieldactor;
	
	override void BeginPlay()
	{
		if (GetClassName() == "MMMParticle") { A_GetMiscDMG(1); }
		if (GetClassName() == "NMMParticle") { A_GetMiscDMG(2); }
		if (GetClassName() == "BMMParticle") { A_GetMiscDMG(3); }
		if (GetClassName() == "UMMParticle") { A_GetMiscDMG(4); }

		if (GetClassName() == "RagingSpirit") { A_GetRagingSpiritDMG(0); }
		if (GetClassName() == "RagingSpirit2") { A_GetRagingSpiritDMG(1); }

		if (GetClassName() == "SpectralLightningBall1New") { A_GetSigilDamage(1); }
		if (GetClassName() == "SpectralLightningBall2New") { A_GetSigilDamage(2); }
		if (GetClassName() == "SpectralLightningBigV1New") { A_GetSigilDamage(3); }
		if (GetClassName() == "SpectralLightningBigBall1New") { A_GetSigilDamage(8); }
		if (GetClassName() == "SpectralLightningV1New") { A_GetSigilDamage(3); }
		if (GetClassName() == "SpectralLightningV2New") { A_GetSigilDamage(4); }
		if (GetClassName() == "SpectralLightningH1New") { A_GetSigilDamage(5); }
		if (GetClassName() == "SpectralLightningH2New") { A_GetSigilDamage(6); }
		if (GetClassName() == "SpectralLightningH3New") { A_GetSigilDamage(7); }
		if (GetClassName() == "NNSigilLightningBigV") { A_GetSigilDamage(3); }
		
		if (GetClassName() == "STGrenade" || GetClassName() == "STGrenadeNoAOE" || 
				GetClassName() == "RocketPlayer" || GetClassName() == "RocketPlayerNoAOE" || 
				GetClassName() == "RocketPlayerSeeking" || GetClassName() == "RocketPlayerSeekingNoAOE") { A_GetPlayerAttackDamage(8,0); }

		if (GetClassName() == "RepeaterPuffPlayer") { A_GetPlayerAttackDamage(10,0); }
		if (GetClassName() == "PlasmaBallPlayer") { A_GetPlayerAttackDamage(11,0); }
		if (GetClassName() == "PlasmaBall1Player") { A_GetPlayerAttackDamage(12,0); }
		if (GetClassName() == "PlasmaBall2Player") { A_GetPlayerAttackDamage(13,0); }
		if (GetClassName() == "BFGBallPlayer") { A_GetPlayerAttackDamage(14,0); }

		if (GetClassName() == "KsawBoltPlayer") { A_GetPlayerAttackDamage(16,0); }

		if (GetClassName() == "DiarisHolyArrow") { A_GetPlayerAttackDamage(18,0); }
		if (GetClassName() == "DiarisHolyArrow2XDmg") { A_GetPlayerAttackDamage(19,0); }
		if (GetClassName() == "DiarisHolyArrow3XDmg") { A_GetPlayerAttackDamage(20,0); }
		if (GetClassName() == "CrossbowFX1New") { A_GetPlayerAttackDamage(21,0); }
		if (GetClassName() == "CrossbowFX2New") { A_GetPlayerAttackDamage(22,0); }
		if (GetClassName() == "CrossbowFX3New") { A_GetPlayerAttackDamage(23,0); }
		if (GetClassName() == "RipperNew") { A_GetPlayerAttackDamage(24,0); }
		if (GetClassName() == "ElectricBoltNew") { A_GetPlayerAttackDamage(25,0); }
		if (GetClassName() == "PoisonBoltNew") { A_GetPlayerAttackDamage(26,0); }

		if (GetClassName() == "BlasterFX1New") { A_GetPlayerAttackDamage(28,0); }

		if (GetClassName() == "HornRodFX1New") { A_GetPlayerAttackDamage(31,0); }
		if (GetClassName() == "HornRodFX2New") { A_GetPlayerAttackDamage(32,0); }
		if (GetClassName() == "PhoenixFX1New" || GetClassName() == "PhoenixFX1NoAOE") { A_GetPlayerAttackDamage(33,0); }
		if (GetClassName() == "PhoenixFX2New") { A_GetPlayerAttackDamage(34,0); }
		if (GetClassName() == "MaceFX1New") { A_GetPlayerAttackDamage(35,0); }
		if (GetClassName() == "MaceFX2New") { A_GetPlayerAttackDamage(36,0); }
		if (GetClassName() == "MaceFX3New") { A_GetPlayerAttackDamage(37,0); }
		if (GetClassName() == "MaceFX4New") { A_GetPlayerAttackDamage(38,0); }
		if (GetClassName() == "Sorcerer2FX1Player") { A_GetPlayerAttackDamage(39,0); }
		if (GetClassName() == "Sorcerer2FX3") { A_GetPlayerAttackDamage(40,0); }
		if (GetClassName() == "GoldWandFX1New") { A_GetPlayerAttackDamage(41,0); }
		if (GetClassName() == "GoldWandFX2New") { A_GetPlayerAttackDamage(42,0); }
		if (GetClassName() == "RainPillarNew") { A_GetPlayerAttackDamage(43,0); }
		if (GetClassName() == "MageWandMissileNew") { A_GetPlayerAttackDamage(44,0); }
		if (GetClassName() == "MageWandMissile2New") { A_GetPlayerAttackDamage(45,0); }
		if (GetClassName() == "HubbleBubbleSmall") { A_GetPlayerAttackDamage(46,0); }
		if (GetClassName() == "HubbleBubbleLarge") { A_GetPlayerAttackDamage(47,0); }
		
		if (GetClassName() == "EvilWarriorShieldBall" || GetClassName() == "EvilWarriorShieldBallCrisis") { A_GetPlayerAttackDamage(52,0); }

		if (GetClassName() == "AChristinaBouncingShotWeak") { A_GetPlayerAttackDamage(55,0); }
		if (GetClassName() == "AChristinaBouncingShotStage1" || GetClassName() == "AChristinaBouncingShotStage2" || GetClassName() == "AChristinaBouncingShotStage3") { A_GetPlayerAttackDamage(56,0); }
		if (GetClassName() == "CStaffMissileNew") { A_GetPlayerAttackDamage(57,0); }

		if (GetClassName() == "PoisonNeedleProj" || GetClassName() == "PoisonNeedleProjExtra") { A_GetPlayerAttackDamage(59,0); }
		if (GetClassName() == "RockBombShardProj") { A_GetPlayerAttackDamage(69,0); }
		if (GetClassName() == "UnmakerLaser" || GetClassName() == "UnmakerLaserCrisis") { A_GetPlayerAttackDamage(71,0); }

		Super.BeginPlay(); // KEEP THIS HERE ELSE OTHER FUNCTIONS RELATED TO BeginPlay() BREAK :V
	}
	override void PostBeginPlay()
	{
		if (GetClassName() == "MMMParticle") { A_GetMiscDMG(1); }
		if (GetClassName() == "NMMParticle") { A_GetMiscDMG(2); }
		if (GetClassName() == "BMMParticle") { A_GetMiscDMG(3); }
		if (GetClassName() == "UMMParticle") { A_GetMiscDMG(4); }
		
		if (GetClassName() == "RagingSpirit") { A_GetRagingSpiritDMG(0); }
		if (GetClassName() == "RagingSpirit2") { A_GetRagingSpiritDMG(1); }

		if (GetClassName() == "SpectralLightningBall1New") { A_GetSigilDamage(1); }
		if (GetClassName() == "SpectralLightningBall2New") { A_GetSigilDamage(2); }
		if (GetClassName() == "SpectralLightningBigV1New") { A_GetSigilDamage(3); }
		if (GetClassName() == "SpectralLightningBigBall1New") { A_GetSigilDamage(8); }
		if (GetClassName() == "SpectralLightningV1New") { A_GetSigilDamage(3); }
		if (GetClassName() == "SpectralLightningV2New") { A_GetSigilDamage(4); }
		if (GetClassName() == "SpectralLightningH1New") { A_GetSigilDamage(5); }
		if (GetClassName() == "SpectralLightningH2New") { A_GetSigilDamage(6); }
		if (GetClassName() == "SpectralLightningH3New") { A_GetSigilDamage(7); }
		if (GetClassName() == "NNSigilLightningBigV") { A_GetSigilDamage(3); }

		if (GetClassName() == "STGrenade" || GetClassName() == "STGrenadeNoAOE" || 
				GetClassName() == "RocketPlayer" || GetClassName() == "RocketPlayerNoAOE" || 
				GetClassName() == "RocketPlayerSeeking" || GetClassName() == "RocketPlayerSeekingNoAOE") { A_GetPlayerAttackDamage(8,0); }

		if (GetClassName() == "RepeaterPuffPlayer") { A_GetPlayerAttackDamage(10,0); }
		if (GetClassName() == "PlasmaBallPlayer") { A_GetPlayerAttackDamage(11,0); }
		if (GetClassName() == "PlasmaBall1Player") { A_GetPlayerAttackDamage(12,0); }
		if (GetClassName() == "PlasmaBall2Player") { A_GetPlayerAttackDamage(13,0); }
		if (GetClassName() == "BFGBallPlayer") { A_GetPlayerAttackDamage(14,0); }

		if (GetClassName() == "KsawBoltPlayer") { A_GetPlayerAttackDamage(16,0); }

		if (GetClassName() == "DiarisHolyArrow") { A_GetPlayerAttackDamage(18,0); }
		if (GetClassName() == "DiarisHolyArrow2XDmg") { A_GetPlayerAttackDamage(19,0); }
		if (GetClassName() == "DiarisHolyArrow3XDmg") { A_GetPlayerAttackDamage(20,0); }
		if (GetClassName() == "CrossbowFX1New") { A_GetPlayerAttackDamage(21,0); }
		if (GetClassName() == "CrossbowFX2New") { A_GetPlayerAttackDamage(22,0); }
		if (GetClassName() == "CrossbowFX3New") { A_GetPlayerAttackDamage(23,0); }
		if (GetClassName() == "RipperNew") { A_GetPlayerAttackDamage(24,0); }
		if (GetClassName() == "ElectricBoltNew") { A_GetPlayerAttackDamage(25,0); }
		if (GetClassName() == "PoisonBoltNew") { A_GetPlayerAttackDamage(26,0); }

		if (GetClassName() == "BlasterFX1New") { A_GetPlayerAttackDamage(28,0); }

		if (GetClassName() == "HornRodFX1New") { A_GetPlayerAttackDamage(31,0); }
		if (GetClassName() == "HornRodFX2New") { A_GetPlayerAttackDamage(32,0); }
		if (GetClassName() == "PhoenixFX1New" || GetClassName() == "PhoenixFX1NoAOE") { A_GetPlayerAttackDamage(33,0); }
		if (GetClassName() == "PhoenixFX2New") { A_GetPlayerAttackDamage(34,0); }
		if (GetClassName() == "MaceFX1New") { A_GetPlayerAttackDamage(35,0); }
		if (GetClassName() == "MaceFX2New") { A_GetPlayerAttackDamage(36,0); }
		if (GetClassName() == "MaceFX3New") { A_GetPlayerAttackDamage(37,0); }
		if (GetClassName() == "MaceFX4New") { A_GetPlayerAttackDamage(38,0); }
		if (GetClassName() == "Sorcerer2FX1Player") { A_GetPlayerAttackDamage(39,0); }
		if (GetClassName() == "Sorcerer2FX3") { A_GetPlayerAttackDamage(40,0); }
		if (GetClassName() == "GoldWandFX1New") { A_GetPlayerAttackDamage(41,0); }
		if (GetClassName() == "GoldWandFX2New") { A_GetPlayerAttackDamage(42,0); }
		if (GetClassName() == "RainPillarNew") { A_GetPlayerAttackDamage(43,0); }
		if (GetClassName() == "MageWandMissileNew") { A_GetPlayerAttackDamage(44,0); }
		if (GetClassName() == "MageWandMissile2New") { A_GetPlayerAttackDamage(45,0); }
		if (GetClassName() == "HubbleBubbleSmall") { A_GetPlayerAttackDamage(46,0); }
		if (GetClassName() == "HubbleBubbleLarge") { A_GetPlayerAttackDamage(47,0); }
		
		if (GetClassName() == "EvilWarriorShieldBall" || GetClassName() == "EvilWarriorShieldBallCrisis") { A_GetPlayerAttackDamage(52,0); }

		if (GetClassName() == "AChristinaBouncingShotWeak") { A_GetPlayerAttackDamage(55,0); }
		if (GetClassName() == "AChristinaBouncingShotStage1" || GetClassName() == "AChristinaBouncingShotStage2" || GetClassName() == "AChristinaBouncingShotStage3") { A_GetPlayerAttackDamage(56,0); }
		if (GetClassName() == "CStaffMissileNew") { A_GetPlayerAttackDamage(57,0); }

		if (GetClassName() == "PoisonNeedleProj" || GetClassName() == "PoisonNeedleProjExtra") { A_GetPlayerAttackDamage(59,0); }
		if (GetClassName() == "SonicNail") { A_GetPlayerAttackDamage(63,0); }
		if (GetClassName() == "UnmakerLaser" || GetClassName() == "UnmakerLaserCrisis") { A_GetPlayerAttackDamage(71,0); }
		
		// Sometimes allow THRUGHOST projectiles to HIT ghosts when Wand Mastery is increased
		int RandCall = random(1,256);
		if (GetClassName() == "CrossbowFX3New")
		{
			if (CallACS("MiscVarCheckDECORATE",10053) <= 0 && RandCall <= 2) bTHRUGHOST = 0;
			else if (CallACS("MiscVarCheckDECORATE",10053) == 1 && RandCall <= 12) bTHRUGHOST = 0;
			else if (CallACS("MiscVarCheckDECORATE",10053) == 2 && RandCall <= 24) bTHRUGHOST = 0;
			else if (CallACS("MiscVarCheckDECORATE",10053) == 3 && RandCall <= 38) bTHRUGHOST = 0;
			else if (CallACS("MiscVarCheckDECORATE",10053) == 4 && RandCall <= 54) bTHRUGHOST = 0;
			else if (CallACS("MiscVarCheckDECORATE",10053) >= 5 && RandCall <= 72) bTHRUGHOST = 0;
		}
		if (GetClassName() == "PhoenixFX1New" || GetClassName() == "PhoenixFX1NoAOE")
		{
			if (CallACS("MiscVarCheckDECORATE",10053) <= 0 && RandCall <= 8) bTHRUGHOST = 0;
			else if (CallACS("MiscVarCheckDECORATE",10053) == 1 && RandCall <= 20) bTHRUGHOST = 0;
			else if (CallACS("MiscVarCheckDECORATE",10053) == 2 && RandCall <= 36) bTHRUGHOST = 0;
			else if (CallACS("MiscVarCheckDECORATE",10053) == 3 && RandCall <= 56) bTHRUGHOST = 0;
			else if (CallACS("MiscVarCheckDECORATE",10053) == 4 && RandCall <= 80) bTHRUGHOST = 0;
			else if (CallACS("MiscVarCheckDECORATE",10053) >= 5 && RandCall <= 108) bTHRUGHOST = 0;
		}
		if (GetClassName() == "MaceFX1New" || GetClassName() == "MaceFX2New" || GetClassName() == "MaceFX3New" || GetClassName() == "MaceFX4New")
		{
			if (CallACS("MiscVarCheckDECORATE",10053) <= 0 && RandCall <= 1) bTHRUGHOST = 0;
			else if (CallACS("MiscVarCheckDECORATE",10053) == 1 && RandCall <= 8) bTHRUGHOST = 0;
			else if (CallACS("MiscVarCheckDECORATE",10053) == 2 && RandCall <= 18) bTHRUGHOST = 0;
			else if (CallACS("MiscVarCheckDECORATE",10053) == 3 && RandCall <= 30) bTHRUGHOST = 0;
			else if (CallACS("MiscVarCheckDECORATE",10053) == 4 && RandCall <= 44) bTHRUGHOST = 0;
			else if (CallACS("MiscVarCheckDECORATE",10053) >= 5 && RandCall <= 60) bTHRUGHOST = 0;
		}

		float basexvel = vel.x;
		float baseyvel = vel.y;
		float basezvel = vel.z;
		float speedmulti;
		float speedmulti2;
		float speedmulti3;
		float monsprojboostfactor = dvds_monsprojboostfactor;
		float mprojectilevelmulti = dvds_mprojectilevelmulti;
		float pprojectilevelmulti = dvds_pprojectilevelmulti;
		let IsPlayer = PlayerPawn(target);
		if (!IsPlayer) A_ScaleVelocity(mprojectilevelmulti); else A_ScaleVelocity(pprojectilevelmulti);

		let IsAMonster = AetheriusMonsterZSC(target);
		if (IsAMonster)
		{
			OriginalActor = IsAMonster;
			OriginalActorType = IsAMonster.GetClassName();

			if (dvds_monsterprojectileboost == 1)
			{
				if (IsAMonster.user_basespeed <= 0) speedmulti = 1.0; else speedmulti = IsAMonster.speed / IsAMonster.user_basespeed;
				if (speedmulti < 1.0) speedmulti = 1.0;
				speedmulti2 = ((speedmulti - 1.0) * monsprojboostfactor) + 1.0;
				A_ScaleVelocity(speedmulti2);
			}

			speedmulti3 = 1.0;
			let IsAMonsterLegendary = IsAMonster.user_legendaryevolved;
			if (IsAMonsterLegendary) speedmulti3 = dvds_LD_projspeedmulti;
			A_ScaleVelocity(speedmulti3);
		}

		float newxvel = vel.x;
		float newyvel = vel.y;
		float newzvel = vel.z;

		if (dvdsdebug_showmiscdmginformation && IsAMonster) Console.Printf("PROJECTILE SPEED: \czXVelOld\c-: \cz%.4f\c-, \cyXVelNew\c-: \cy%.4f\c-, \czYVelOld\c-: \cz%.4f\c-, \cyYVelNew\c-: \cy%.4f\c-, \czZVelOld\c-: \cz%.4f\c-, \cyZVelNew\c-: \cy%.4f\c-, \cxSpeedMulti\c-: \cx%.4f\c-, \cwSpeedMulti2\c-: \cw%.4f\c-, \cvSpeedMulti3\c-: \cv%.4f\c-", basexvel, newxvel, baseyvel, newyvel, basezvel, newzvel, speedmulti, speedmulti2, speedmulti3);
		
		Super.PostBeginPlay(); // KEEP THIS HERE ELSE OTHER FUNCTIONS RELATED TO PostBeginPlay() BREAK :V
	}
	override void Tick()
	{
		if (GetClassName() == "MinorMagicMissile" || GetClassName() == "MinorMagicMissileSeek") user_fusemax = (140 + (CallACS("MiscVarCheckDECORATE",34) * 0.05) + (CallACS("MiscVarCheckDECORATE",36) * 0.05));
		if (GetClassName() == "MagicMissile" || GetClassName() == "MagicMissileSeek") user_fusemax = (210 + (CallACS("MiscVarCheckDECORATE",34) * 0.075) + (CallACS("MiscVarCheckDECORATE",36) * 0.075));
		if (GetClassName() == "MajorMagicMissile" || GetClassName() == "MajorMagicMissileSeek") user_fusemax = (280 + (CallACS("MiscVarCheckDECORATE",34) * 0.10) + (CallACS("MiscVarCheckDECORATE",36) * 0.10));
		if (GetClassName() == "UltraMagicMissile" || GetClassName() == "UltraMagicMissileSeek") user_fusemax = (420 + (CallACS("MiscVarCheckDECORATE",34) * 0.15) + (CallACS("MiscVarCheckDECORATE",36) * 0.15));
		
		if (user_fusemax > 0)
		{
			if (user_Fuse < user_fusemax) 
			{
				if (!(CountInv("AetheriusTimeFreezer",AAPTR_PLAYER1) || CountInv("AetheriusTimeFreezerMenu",AAPTR_PLAYER1) || isFrozen() || InStateSequence(curstate,ResolveState("Death")))) user_Fuse++;
			}
			if (user_Fuse == user_fusemax) 
			{ 
				if (!(CountInv("AetheriusTimeFreezer",AAPTR_PLAYER1) || CountInv("AetheriusTimeFreezerMenu",AAPTR_PLAYER1) || isFrozen() || InStateSequence(curstate,ResolveState("Death")))) SetStateLabel("Death");
			}
			if (user_Fuse > user_fusemax) 
			{ 
				if (!(CountInv("AetheriusTimeFreezer",AAPTR_PLAYER1) || CountInv("AetheriusTimeFreezerMenu",AAPTR_PLAYER1) || isFrozen())) user_Fuse /= 4; 
			}
		}
		
		if (OriginalActor != null) 
		{ 
			if (target != OriginalActor && target == AetheriusPlayerPawn(target)) REFLECTEDMONSTERPROJ = true; 
		}
		
		if (REFLECTEDMONSTERPROJ && bDONTREFLECT == false) 
		{
			//Console.Printf("REFLECTEDMONSTERPROJ (%d)", level.time);
			bDONTREFLECT = true;
		}
		
		Super.Tick();
	}

	void A_PlayCrisisAtkSound ()
	{
		A_StartSound("crisisattack", 9, CHANF_DEFAULT, frandom(1.25,1.5), ATTN_NORM, frandom(0.75,1.25));
		A_StartSound("crisisattack2", 10, CHANF_DEFAULT, frandom(1.25,1.5), ATTN_NORM, frandom(0.75,1.25));
	}
	
	
	void A_DVDSFire(double spawnheight = 0, double firelength = 24)
	{
		Actor dest = tracer;
		if (!dest || !target) return;
				
		// don't move it if the vile lost sight
		if (!target.CheckSight (dest, 0) ) return;

		SetOrigin(dest.Vec3Angle(firelength, dest.angle, (dest.height/2)), true);
	}

	// A_SeekerMissile that will clear its tracer pointer if the tracer is friendly.
	void A_NFSeekerMissile(int threshold, int maxturnangle, int flags = 0, int chance = 50, int distance = 10)
	{
		if ((flags & SMF_LOOK) && !tracer)
		{
			// Searches for a monster to seek, but only if it's not friendly.
			tracer = RoughMonsterSearch(distance, onlyseekable: true);
			if (tracer && target && !target.isHostile(tracer)) tracer = null;
		}
		A_SeekerMissile(threshold,maxturnangle,flags & ~SMF_LOOK,chance,distance);
	}	
	
	// A_SeekerMissile that will clear its tracer pointer if the tracer is hostile and only try to seek friendlies [for healing projectiles, etc].
	void A_FOSeekerMissile(int threshold, int maxturnangle, int flags = 0, int chance = 50, int distance = 10)
	{
		if ((flags & SMF_LOOK) && !tracer)
		{
			// Searches for a monster to seek, but only if it's friendly.
			tracer = RoughMonsterSearch(distance, onlyseekable: true);
			if (tracer && target && !target.isFriend(tracer)) tracer = null;
		}
		A_SeekerMissile(threshold,maxturnangle,flags & ~SMF_LOOK,chance,distance);
	}	
	
	void A_HealSeek(int maxtime = 2)
	{
		user_seektimer += 1;
		if (user_seektimer >= maxtime) 
		{
			A_FOSeekerMissile(90,90,SMF_LOOK|SMF_PRECISE|SMF_CURSPEED,256,64); 
			user_seektimer = 0;
		}
		//A_LogInt(user_seektimer);
	}
	
	/**
	 * Sets the calling actor's Angle and Pitch to match its velocity vector, so that it is looking in exactly the same direction as it is traveling. Used by A_SelectSeekTarget.
	 */
	action void A_FaceVel()
	{
		// Math from https://forum.zdoom.org/viewtopic.php?f=15&t=59726&hilit=PitchTo#p1044007
		let dir = Vel.Unit();
		Angle = atan2(dir.Y, dir.X);
		Pitch = -asin(dir.Z);
	}
	
	/**
	 * Selects a target for A_SeekerMissile or A_SuperSeekerMissile, based on where the source of this projectile (that is, the target pointer) is currently aiming.
	 *
	 * This should be called when a projectile is first fired. If this is used, then in subsequent calls to A_SuperSeekerMissile, the retarget parameter should be the opposite of the value returned by this method. Example:
	 *
	 *	private bool specificTarget;
	 *	states {
	 *		Spawn:
	 *			TNT1 A 0 nodelay { invoker.specificTarget = A_SelectSeekTargetByShooterAim(); }
	 *			MISL A 1 A_SuperSeekerMissile(1, 1, retarget: !specificTarget);
	 *			wait;
	 *	}
	 *
	 * @param seekEnemies Whether to seek actors hostile to the source of this projectile. Defaults to true.
	 * @param seekFriends Whether to seek actors friendly to the source of this projectile. Defaults to false.
	 * @param range How far out to look. Defaults to PLAYERMISSILERANGE, the maximum range of player hitscans.
	 * @return true if a valid target was selected; false otherwise.
	 */
	action bool A_SelectSeekTargetByShooterAim(bool seekEnemies = true, bool seekFriends = false, double range = PLAYERMISSILERANGE)
	{
		if (!target)
		{
			Console.Printf("\cg%s.A_SelectSeekTargetByShooterAim called, but this actor's target field is null!", GetClassName());
			return false;
		}
		
		FLineTraceData result;
		if (LineTrace(target.Angle, range, target.Pitch, data: result) && result.HitActor)
		{
			let a = result.HitActor;
			if 
			(
				a != target &&
				a.bShootable && !a.bDormant && !a.bNeverTarget &&
				(
					(!seekEnemies && !seekFriends) ||
					(seekEnemies && target.isHostile(a)) ||
					(seekFriends && target.isFriend(a))
				)
			)
			{
				tracer = a;
				return true;
			}
		}
		
		return false;
	}
	
	/**
	 * Selects a target for A_SeekerMissile or A_SuperSeekerMissile.
	 *
	 * @param seekEnemies Whether to seek actors hostile to the source of this projectile. Defaults to true.
	 * @param seekFriends Whether to seek actors friendly to the source of this projectile. Defaults to false.
	 * @param lookDistance How far to look all around for a target.
	 */
	action void A_SelectSeekTarget(bool seekEnemies = true, bool seekFriends = false, double lookDistance = MISSILERANGE)
	{
		invoker.SuperSeekerMissileLastTargetingAttempt = gametic;
		
		A_FaceVel();
		
		Vector2 bestAimCorrection = (180, 180);
		Actor bestTarget = null;
		
		// Searches for a monster to seek.
		for (let i = BlockThingsIterator.Create(invoker, lookDistance); i.Next();)
		if 
		(
			i.thing != target &&
			i.thing.bShootable && !i.thing.bDormant && !i.thing.bNeverTarget &&
			(
				(!seekEnemies && !seekFriends) || !target ||
				(seekEnemies && target.isHostile(i.thing)) ||
				(seekFriends && target.isFriend(i.thing))
			)
		)
		{
			let dirTo = Vec3To(i.thing).Unit();
			let aimCorrection = (
				abs(atan2(dirTo.y, dirTo.x) - Angle),
				abs(asin(dirTo.z) - Pitch)
			);
			
			// Save the visibility check for last. It's quite expensive.
			if (aimCorrection.Length() < bestAimCorrection.Length() && IsVisible(i.thing, true))
			{
				bestAimCorrection = aimCorrection;
				bestTarget = i.thing;
			}
		}
		
		if (bestTarget)
			tracer = bestTarget;
	}
	
	/**
	 * The most recent tic when A_SelectSeekTarget was executed.
	 *
	 * This is used to limit how often A_SuperSeekerMissile searches for a seek target when it doesn't already have one. Searching for a seek target is an expensive operation, so it shouldn't be done on every tic.
	 *
	 * The longer ago the last attempt was made, the more probable it is that another attempt will be made on this tic, reaching 100% probability after 32 tics. In other words, seeker missile targeting will happen every 16 tics on average, but it's randomized so that not all seeker missiles in flight will try targeting on the same tic.
	 */
	private int SuperSeekerMissileLastTargetingAttempt;
	
	/**
	 * Custom replacement for A_SeekerMissile that actually works correctly, and without the quirks. Always behaves as though SMF_PRECISE and SMF_CURSPEED were given.
	 *
	 * @param maxYaw How far the missile is allowed to yaw in one tic.
	 * @param maxPitch How far the missile is allowed to pitch in one tic.
	 * @param retarget If true, the missile will occasionally look for new, better targets even if it already has one.
	 * @param seekEnemies Whether to seek actors hostile to the source of this projectile. Defaults to true.
	 * @param seekFriends Whether to seek actors friendly to the source of this projectile. Defaults to false.
	 * @param lookDistance How far the missile will look for targets. If  0, missile will not look for targets at all, and will simply seek the current tracer (if any).
	 */
	action void A_SuperSeekerMissile(double maxYaw, double maxPitch, bool retarget = true, bool seekEnemies = true, bool seekFriends = false, double lookDistance = MISSILERANGE, int faceFlags = 0)
	{
		if 
		(
			tracer && (
				!invoker.CanSeek(tracer) ||
				!tracer.bShootable ||
				(!(random() & 31) && !IsVisible(tracer, true))
			)
		)
			tracer = null; // Forget about targets that are no longer valid.
		
		if 
		(
			(!tracer && (
				// If A_SelectSeekTarget has never run before, then definitely run it.
				(invoker.SuperSeekerMissileLastTargetingAttempt == 0) ||
				// Otherwise, avoid running it on every tic; it's an expensive operation.
				(gametic - invoker.SuperSeekerMissileLastTargetingAttempt) > (random() & 31)
			)) ||
			(retarget && !(random() & 127))
		)
			A_SelectSeekTarget(seekEnemies: seekEnemies, seekFriends: seekFriends, lookDistance: lookDistance);
		
		if (tracer)
		{
			let curSpeed = Vel.Length();
			let curAngles = (Angle, Pitch);
			A_FaceTracer(maxYaw, maxPitch, flags: faceFlags);
			Vel3DFromAngle(curSpeed, Angle, Pitch);
		}
	}
	
	action void A_DrunkMissile(double maxYaw, double maxPitch)
	{
		let curSpeed = Vel.Length();
		Angle = Normalize180(Angle + random(-maxYaw, maxYaw));
		Pitch = clamp(Pitch + random(-maxPitch, maxPitch), -90., 90.);
		Vel3DFromAngle(curSpeed, Angle, Pitch);
	}

	void A_CharmSeek(int maxtime = 2)
	{
		user_seektimer += 1;
		if (user_seektimer >= maxtime) 
		{
			A_NFSeekerMissile(90,90,SMF_LOOK|SMF_PRECISE|SMF_CURSPEED,256,64); 
			user_seektimer = 0;
		}
		//A_LogInt(user_seektimer);
	}

	void A_MMSeek(int maxtime = 2)
	{
		user_seektimer += 1;
		if (user_seektimer >= maxtime) 
		{
			A_NFSeekerMissile(22,44,SMF_LOOK|SMF_PRECISE|SMF_CURSPEED,128,16);
			user_seektimer = 0;
		}
		//A_LogInt(user_seektimer);
	}

	void A_HealCheckNoSeekTimer(int maxchance = 16, int healseek = 2)
	{
		user_noseektimer -= 1;
		if (random(1,maxchance) == 1) 
		{ 
			A_HealSeek(healseek);
			user_noseektimer += 1;
		}
		//A_LogInt(user_noseektimer);
	}
	
	void A_CharmCheckNoSeekTimer(int maxchance = 16, int charmseek = 2)
	{
		user_noseektimer -= 1;
		if (random(1,maxchance) == 1) 
		{ 
			A_CharmSeek(charmseek);
			user_noseektimer += 1;
		}
		//A_LogInt(user_noseektimer);
	}
	
	void A_MMCheckNoSeekTimer(int maxchance = 16, int mmseek = 2)
	{
		user_noseektimer -= 1;
		if (random(1,maxchance) == 1) 
		{ 
			A_MMSeek(mmseek);
			user_noseektimer += 1;
		}
		//A_LogInt(user_noseektimer);
	}

	void A_MMSeekerClearBounce(int timerset = 6, int randomset = 0)
	{
		if (user_noseektimer <= 0) 
		{ 
			user_noseektimer = timerset + random(-randomset,randomset);
			A_RearrangePointers(AAPTR_DEFAULT, AAPTR_DEFAULT, AAPTR_NULL);
			//A_LogInt(user_noseektimer);
		} 
	}



	// Customizable version of A_Tracer, allowing you to change the puff and smoke, as well as the tracing angle.
	void A_CustomTracer(double traceang = 16.875, string pufftype = "BulletPuff", string smoketype = "RevenantTracerSmoke")
	{
		// killough 1/18/98: this is why some missiles do not have smoke
		// and some do. Also, internal demos start at random gametics, thus
		// the bug in which revenants cause internal demos to go out of sync.
		//
		// killough 3/6/98: fix revenant internal demo bug by subtracting
		// levelstarttic from gametic:
		//
		// [RH] level.time is always 0-based, so nothing special to do here.

		if (level.time & 3)	return;
	
		// spawn a puff of smoke behind the rocket
		SpawnPuff (pufftype, pos, angle, angle, 3);
		Actor smoke = Spawn ("RevenantTracerSmoke", Vec3Offset(-Vel.X, -Vel.Y, 0.), ALLOW_REPLACE);
	
		if (smoke != null)
		{
			smoke.Vel.Z = 1.;
			smoke.tics -= random[Tracer](0, 3);
			if (smoke.tics < 1)
				smoke.tics = 1;
		}

		// The rest of this function was identical with Strife's version, except for the angle being used.
		A_Tracer2(traceang);
	}

	void A_FlameDie()
	{
		bNoGravity = true;
		Vel.Z = random[FlameDie]() & 3;
	}

	void A_WraithFX2()
	{
		for (int i = 2; i; --i)
		{
			Actor mo = Spawn ("WraithFX2", Pos, ALLOW_REPLACE);
			if(mo)
			{
				double newangle = random[WraithFX2]() * (360 / 1024.f);
				if (random[WraithFX2]() >= 128)
				{
					newangle = -newangle;
				}
				newangle += angle;
				mo.Vel.X = ((random[WraithFX2]() / 512.) + 1) * cos(newangle);
				mo.Vel.Y = ((random[WraithFX2]() / 512.) + 1) * sin(newangle);
				mo.Vel.Z = 0;
				mo.target = self;
				mo.Floorclip = 10;
			}
		}
	}

	// D'Sparil Bolt
	void A_BlueSpark ()
	{
		for (int i = 0; i < 2; i++)
		{
			Actor mo = Spawn("Sorcerer2FXSpark", pos, ALLOW_REPLACE);
			if (mo != null)
			{
				mo.Vel.X = Random2[BlueSpark]() / 128.;
				mo.Vel.Y = Random2[BlueSpark]() / 128.;
				mo.Vel.Z = 1. + Random[BlueSpark]() / 256.;
			}
		}
	}

	void A_GenWizard ()
	{
		Actor mo = Spawn("Wizard", pos, ALLOW_REPLACE);
		if (mo != null)
		{
			mo.AddZ(-mo.Default.Height / 2, false);
			if (!mo.TestMobjLocation ())
			{ // Didn't fit
				mo.ClearCounters();
				mo.Destroy ();
			}
			else
			{ // [RH] Make the new wizards inherit D'Sparil's target
				mo.CopyFriendliness (self.target, true);

				Vel = (0,0,0);
				SetStateLabel('Death');
				bMissile = false;
				mo.master = target;
				SpawnTeleportFog(pos, false, true);
			}
		}
	}

	// Red Axe [Heretic]
	void A_DripBlood (string missiletype = "Blood")
	{
		double xo = random2[DripBlood]() / 32.0;
		double yo = random2[DripBlood]() / 32.0;
		Actor mo = Spawn (missiletype, Vec3Offset(xo, yo, 0.), ALLOW_REPLACE);
		if (mo != null)
		{
			mo.Vel.X = random2[DripBlood]() / 64.0;
			mo.Vel.Y = random2[DripBlood]() / 64.0;
			mo.Gravity = 1./8;
		}
	}

	// Ice Ball Splits
	void A_LichIceImpact(string missiletype = "HeadFX2")
	{
		for (int i = 0; i < 8; i++)
		{
			Actor shard = Spawn(missiletype, Pos, ALLOW_REPLACE);
			if (shard != null)
			{
				shard.target = target;
				shard.angle = i*45.;
				shard.VelFromAngle();
				shard.Vel.Z = -.6;
				shard.CheckMissileSpawn (radius);
			}
		}
	}

	// Lich Fire Pillar
	void A_LichFireGrow ()
	{
		health--;
		AddZ(9.);
		if (health == 0)
		{
			RestoreDamage();
			SetStateLabel("NoGrow");
		}
	}

	// Ice Shards
	void A_ShedShard()
	{
		int spawndir = special1;
		int spermcount = special2;
		Actor mo;

		if (spermcount <= 0)
		{
			return;				// No sperm left
		}
		special2 = 0;
		spermcount--;

		// every so many calls, spawn a new missile in its set directions
		if (spawndir & SHARDSPAWN_LEFT)
		{
			mo = SpawnMissileAngleZSpeed(pos.z, "FrostMissile", angle + 5, 0, (20. + 2 * spermcount), target);
			if (mo)
			{
				mo.special1 = SHARDSPAWN_LEFT;
				mo.special2 = spermcount;
				mo.Vel.Z = Vel.Z;
				mo.args[0] = (spermcount==3)?2:0;
			}
		}
		if (spawndir & SHARDSPAWN_RIGHT)
		{
			mo = SpawnMissileAngleZSpeed(pos.z, "FrostMissile",	angle - 5, 0, (20. + 2 * spermcount), target);
			if (mo)
			{
				mo.special1 = SHARDSPAWN_RIGHT;
				mo.special2 = spermcount;
				mo.Vel.Z = Vel.Z;
				mo.args[0] = (spermcount==3)?2:0;
			}
		}
		if (spawndir & SHARDSPAWN_UP)
		{
			mo = SpawnMissileAngleZSpeed(pos.z + 8., "FrostMissile", angle, 0, (15. + 2 * spermcount), target);
			if (mo)
			{
				mo.Vel.Z = Vel.Z;
				if (spermcount & 1)			// Every other reproduction
					mo.special1 = SHARDSPAWN_UP | SHARDSPAWN_LEFT | SHARDSPAWN_RIGHT;
				else
					mo.special1 = SHARDSPAWN_UP;
				mo.special2 = spermcount;
				mo.args[0] = (spermcount==3)?2:0;
			}
		}
		if (spawndir & SHARDSPAWN_DOWN)
		{
			mo = SpawnMissileAngleZSpeed(pos.z - 4., "FrostMissile", angle, 0, (15. + 2 * spermcount), target);
			if (mo)
			{
				mo.Vel.Z = Vel.Z;
				if (spermcount & 1)			// Every other reproduction
					mo.special1 = SHARDSPAWN_DOWN | SHARDSPAWN_LEFT | SHARDSPAWN_RIGHT;
				else
					mo.special1 = SHARDSPAWN_DOWN;
				mo.special2 = spermcount;
				mo.target = target;
				mo.args[0] = (spermcount==3)?2:0;
			}
		}
	}

	// Wendigo/IceLich Balls
	void A_IceGuyMissileExplode(string missiletype = "IceGuyFX2", int numshots = 8, double pitch = -0.3)
	{
		for (int i = 0; i < numshots; i++)
		{
			Actor mo = SpawnMissileAngleZ (pos.z+3, missiletype, i*45., pitch);
			if (mo)
			{
				mo.target = target;
			}
		}
	}	

	//
	void A_MntrFloorFire(string missiletype = "MinotaurFX3")
	{
		SetZ(floorz);
		double x = Random2[MntrFloorFire]() / 64.;
		double y = Random2[MntrFloorFire]() / 64.;
		
		Actor mo = Spawn(missiletype, Vec2OffsetZ(x, y, floorz), ALLOW_REPLACE);
		if (mo != null)
		{
			mo.target = target;
			mo.Vel.X = MinVel; // Force block checking
			mo.CheckMissileSpawn (radius);
		}
	}

	// Quietus Sword Flames
	void A_FSwordFlames()
	{
		for (int i = random[FSwordFlame](1, 4); i; i--)
		{
			double xo = (random[FSwordFlame]() - 128) / 16.;
			double yo = (random[FSwordFlame]() - 128) / 16.;
			double zo = (random[FSwordFlame]() - 128) / 8.;
			Spawn ("FSwordFlame", Vec3Offset(xo, yo, zo), ALLOW_REPLACE);
		}
	}

	// DragonFX2
	void A_DragonFX2(string missiletype = "DragonExplosion")
	{
		int delay = 16+(random[DragonFX2]()>>3);
		for (int i = random[DragonFX2](1, 4); i; i--)
		{
			double xo = (random[DragonFX2]() - 128) / 4.;
			double yo = (random[DragonFX2]() - 128) / 4.;
			double zo = (random[DragonFX2]() - 128) / 16.;

			Actor mo = Spawn (missiletype, Vec3Offset(xo, yo, zo), ALLOW_REPLACE);
			if (mo)
			{
				mo.tics = delay + (random[DragonFX2](0, 3)) * i*2;
				mo.target = target;
			}
		}
	}

	// WraithVerge
	void A_CHolyAttack2(string missiletype = "HolySpirit", int spiritnums = 4, int spiritfuse = 105, int spiritfusedm = 85)
	{
		for (int j = 0; j < spiritnums; j++)
		{
			Actor mo = Spawn(missiletype, Pos, ALLOW_REPLACE);
			if (!mo)
			{
				continue;
			}
			switch (j)
			{
				// float bob index

				case 0:
					mo.WeaveIndexZ = random[HolyAtk2]() & 7; // upper-left
					break;
				case 1:
					mo.WeaveIndexZ = 32 + (random[HolyAtk2]() & 7); // upper-right
					break;
				case 2:
					mo.WeaveIndexXY = 32 + (random[HolyAtk2]() & 7); // lower-left
					break;
				case 3:
					mo.WeaveIndexXY = 32 + (random[HolyAtk2]() & 7);
					mo.WeaveIndexZ = 32 + (random[HolyAtk2]() & 7);
					break;
			}
			mo.SetZ(pos.z);
			mo.angle = angle + 67.5 - 45.*j;
			mo.Thrust();
			mo.target = target;
			mo.args[0] = 10; // initial turn value
			mo.args[1] = 0; // initial look angle
			if (deathmatch)
			{
				// Ghosts last slightly less longer in DeathMatch
				mo.health = spiritfusedm;
				if (spiritfusedm <= 0) mo.health = 85;
			}
			else
			{
				mo.health = spiritfuse;
				if (spiritfuse <= 0) mo.health = 105;
			}
			if (tracer)
			{
				mo.tracer = tracer;
				mo.bNoClip = true;
				mo.bSkullFly = true;
				mo.bMissile = false;
			}
			HolyTail.SpawnSpiritTail (mo);
		}
	}

	// Sigil 1/Programmer Lightning Spawn Spot
	void A_SpectralLightning (string spawntype1 = "SpectralLightningV1", string spawntype2 = "SpectralLightningV2")
	{
		if (threshold != 0)
			--threshold;

		Vel.X += random2[Zap5](3);
		Vel.Y += random2[Zap5](3);

		double xo = random2[Zap5](3) * 50.;
		double yo = random2[Zap5](3) * 50.;
		
		class<Actor> cls;
		if (threshold > 25) cls = spawntype2;
		else cls = spawntype1;

		Actor flash = Spawn (cls, Vec2OffsetZ(xo, yo, ONCEILINGZ), ALLOW_REPLACE);

		if (flash != null)
		{
			flash.target = target;
			flash.Vel.Z = -18;
			flash.FriendPlayer = FriendPlayer;
		}

		flash = Spawn(spawntype2, (pos.xy, ONCEILINGZ), ALLOW_REPLACE);

		if (flash != null)
		{
			flash.target = target;
			flash.Vel.Z = -18;
			flash.FriendPlayer = FriendPlayer;
		}
	}

    // Player Sigil 2 Shots
	void A_SpectralLightningTail ()
	{
		Actor foo = Spawn("SpectralLightningHTail", Vec3Offset(-Vel.X, -Vel.Y, 0.), ALLOW_REPLACE);
		if (foo != null)
		{
			foo.Angle = Angle;
			foo.FriendPlayer = FriendPlayer;
		}
	}

	// Sigil5 Shots
	void A_SpectralBigBallLightning (string spawntype = "SpectralLightningH3")
	{
		Class<Actor> cls = spawntype;
		if (cls)
		{
			angle += 90.;
			SpawnSubMissile (cls, target);
			angle += 180.;
			SpawnSubMissile (cls, target);
			angle -= 270.;
			SpawnSubMissile (cls, target);
		}
	}
	
	void A_HadesSphereExplode(int basedmg = 112, int baserad = 112)
	{
		int newdmg = basedmg;
		int newrad = baserad;
		if (target)
		{
			AetheriusMonsterZSC DVDSActor;
			DVDSActor = AetheriusMonsterZSC(target);
			if (DVDSActor)
			{
				int maxhp;
				if (DVDSActor.user_MaxHP > 0) maxhp = DVDSActor.user_MaxHP;
				else maxhp = DVDSActor.SpawnHealth();
				maxhp *= (1.0 + (DVDSActor.user_monsterlevel * 0.0111111112)); // +100% damage every ~90 levels
				maxhp *= 0.25; // +100% damage every ~180 levels
				newdmg += maxhp;
				int healthleft = DVDSActor.hsexphealth;
				healthleft *= (1.0 + (DVDSActor.user_monsterlevel * 0.0222222223)); // +100% damage every ~45 levels
				healthleft *= 0.5;
				newdmg += healthleft;

				int maxhp2;
				if (DVDSActor.user_MaxHP > 0) maxhp2 = DVDSActor.user_MaxHP;
				else maxhp2 = DVDSActor.SpawnHealth();
				maxhp2 *= (1.0 + (DVDSActor.user_monsterlevel * 0.005555556)); // +100% radius every ~180 levels
				maxhp2 *= 0.125;
				newrad += maxhp2;
				int healthleft2 = DVDSActor.hsexphealth;
				healthleft2 *= (1.0 + (DVDSActor.user_monsterlevel * 0.011111112)); // +100% radius every ~90 levels
				healthleft2 *= 0.25;
				newrad += healthleft2;
				
				if (dvdsdebug_showmiscdmginformation) Console.Printf("NewDmg: %d (%d), NewRad: %d (%d), MaxHP: %d, HealthLeft: %d, MaxHP2: %d, HealthLeft2: %d", newdmg, basedmg, newrad, baserad, maxhp, healthleft, maxhp2, healthleft2);
			}
		}
		A_Explode(newdmg,newrad,0,(newrad*0.334));
	}

	void A_SpawnRck(int type = 0)
	{
		string spawntype1 = "PossessedBalloon";
		string spawntype2 = "JumpingSkull";
		if (type == 0)
		{
			Actor spawn1 = A_SpawnProjectile(spawntype1, 64, 64, 60, 0);
			Actor spawn2 = A_SpawnProjectile(spawntype1, 32, -32, 0, 0);
			Actor spawn3 = A_SpawnProjectile(spawntype1, 32, 0, 0, 0);
			Actor spawn4 = A_SpawnProjectile(spawntype2, 0, 0, 0, 0);
			if (target && target.bFRIENDLY)
			{
				
				if (spawn1) { spawn1.bFRIENDLY = true; }
				if (spawn2) { spawn2.bFRIENDLY = true; }
				if (spawn3) { spawn3.bFRIENDLY = true; }
				if (spawn4) { spawn4.bFRIENDLY = true; }
			}
		}
		
		if (type == 1)
		{
			Actor spawn1 = A_SpawnProjectile(spawntype1, 64, 64, 60, 0);
			Actor spawn2 = A_SpawnProjectile(spawntype1, 0, 0, 60, 0);
			Actor spawn3 = A_SpawnProjectile(spawntype1, 32, -32, 0, 0);
			Actor spawn4 = A_SpawnProjectile(spawntype1, 32, 0, 0, 0);
			Actor spawn5 = A_SpawnProjectile(spawntype1, 0, -32, 0, 0);
			Actor spawn6 = A_SpawnProjectile(spawntype1, 0, 32, 0, 0);
			Actor spawn7 = A_SpawnProjectile(spawntype2, 0, 0, 0, 0);
			Actor spawn8 = A_SpawnProjectile(spawntype2, 32, 0, 0, 0);
			Actor spawn9 = A_SpawnProjectile(spawntype2, 0, 32, 0, 0);
			if (target && target.bFRIENDLY)
			{
				if (spawn1) { spawn1.bFRIENDLY = true; }
				if (spawn2) { spawn2.bFRIENDLY = true; }
				if (spawn3) { spawn3.bFRIENDLY = true; }
				if (spawn4) { spawn4.bFRIENDLY = true; }
				if (spawn5) { spawn5.bFRIENDLY = true; }
				if (spawn6) { spawn6.bFRIENDLY = true; }
				if (spawn7) { spawn7.bFRIENDLY = true; }
				if (spawn8) { spawn8.bFRIENDLY = true; }
				if (spawn9) { spawn9.bFRIENDLY = true; }
			}
		}
		
	}
}

// Base FastProjectile Class
class AetheriusFastProjectileZSC : AetheriusBaseProjectileZSC
{
	Default
	{
		Projectile;
		MissileHeight 0;
	}
	
	int projtouchedshieldactor;
	
	virtual void Effect()
	{
		class<Actor> trail = MissileName;
		if (trail != null)
		{
			double hitz = pos.z - 8;

			if (hitz < floorz)
			{
				hitz = floorz;
			}
			// Do not clip this offset to the floor.
			hitz += MissileHeight;
			
			Actor act = Spawn (trail, (pos.xy, hitz), ALLOW_REPLACE);
			if (act != null)
			{
				if (bGetOwner && target != null)
					act.target = target;
				else
					act.target = self;
				
				act.angle = angle;
				act.pitch = pitch;
				
				BaseWandMissile act2;
				act2 = BaseWandMissile(self);
				if (act2 && act2.wandmissleeraseproj)
				{
					act.scale.x *= 1.25;
					act.scale.y *= 1.25;
					act.A_SetRenderStyle(act.alpha*0.667,6);
				}
			}
		}
	}
	
	//----------------------------------------------------------------------------
	//
	// AFastProjectile :: Tick
	//
	// Thinker for the ultra-fast projectiles used by Heretic and Hexen
	//
	//----------------------------------------------------------------------------

	override void Tick()
	{
		if (GetAge() == 1)
		{
			BaseWandMissile act2;
			act2 = BaseWandMissile(self);
			if (act2 && act2.wandmissleeraseproj)
			{
				scale.x *= 1.25;
				scale.y *= 1.25;
				A_SetRenderStyle(alpha*0.667,6);
			}
		}
		if (GetAge() <= 4)
		{
			if (GetClassName() == "STGrenade" || GetClassName() == "STGrenadeNoAOE" || 
					GetClassName() == "RocketPlayer" || GetClassName() == "RocketPlayerNoAOE" || 
					GetClassName() == "RocketPlayerSeeking" || GetClassName() == "RocketPlayerSeekingNoAOE") { A_GetPlayerAttackDamage(8,0); }

			if (GetClassName() == "RepeaterPuffPlayer") { A_GetPlayerAttackDamage(10,0); }
			if (GetClassName() == "PlasmaBallPlayer") { A_GetPlayerAttackDamage(11,0); }
			if (GetClassName() == "PlasmaBall1Player") { A_GetPlayerAttackDamage(12,0); }
			if (GetClassName() == "PlasmaBall2Player") { A_GetPlayerAttackDamage(13,0); }
			if (GetClassName() == "BFGBallPlayer") { A_GetPlayerAttackDamage(14,0); }

			if (GetClassName() == "KsawBoltPlayer") { A_GetPlayerAttackDamage(16,0); }

			if (GetClassName() == "DiarisHolyArrow") { A_GetPlayerAttackDamage(18,0); }
			if (GetClassName() == "DiarisHolyArrow2XDmg") { A_GetPlayerAttackDamage(19,0); }
			if (GetClassName() == "DiarisHolyArrow3XDmg") { A_GetPlayerAttackDamage(20,0); }
			if (GetClassName() == "CrossbowFX1New") { A_GetPlayerAttackDamage(21,0); }
			if (GetClassName() == "CrossbowFX2New") { A_GetPlayerAttackDamage(22,0); }
			if (GetClassName() == "CrossbowFX3New") { A_GetPlayerAttackDamage(23,0); }
			if (GetClassName() == "RipperNew") { A_GetPlayerAttackDamage(24,0); }
			if (GetClassName() == "ElectricBoltNew") { A_GetPlayerAttackDamage(25,0); }
			if (GetClassName() == "PoisonBoltNew") { A_GetPlayerAttackDamage(26,0); }

			if (GetClassName() == "BlasterFX1New") { A_GetPlayerAttackDamage(28,0); }

			if (GetClassName() == "HornRodFX1New") { A_GetPlayerAttackDamage(31,0); }
			if (GetClassName() == "HornRodFX2New") { A_GetPlayerAttackDamage(32,0); }
			if (GetClassName() == "PhoenixFX1New" || GetClassName() == "PhoenixFX1NoAOE") { A_GetPlayerAttackDamage(33,0); }
			if (GetClassName() == "PhoenixFX2New") { A_GetPlayerAttackDamage(34,0); }
			if (GetClassName() == "MaceFX1New") { A_GetPlayerAttackDamage(35,0); }
			if (GetClassName() == "MaceFX2New") { A_GetPlayerAttackDamage(36,0); }
			if (GetClassName() == "MaceFX3New") { A_GetPlayerAttackDamage(37,0); }
			if (GetClassName() == "MaceFX4New") { A_GetPlayerAttackDamage(38,0); }
			if (GetClassName() == "Sorcerer2FX1Player") { A_GetPlayerAttackDamage(39,0); }
			if (GetClassName() == "Sorcerer2FX3") { A_GetPlayerAttackDamage(40,0); }
			if (GetClassName() == "GoldWandFX1New") { A_GetPlayerAttackDamage(41,0); }
			if (GetClassName() == "GoldWandFX2New") { A_GetPlayerAttackDamage(42,0); }
			if (GetClassName() == "RainPillarNew") { A_GetPlayerAttackDamage(43,0); }
			if (GetClassName() == "MageWandMissileNew") { A_GetPlayerAttackDamage(44,0); }
			if (GetClassName() == "MageWandMissile2New") { A_GetPlayerAttackDamage(45,0); }
			if (GetClassName() == "HubbleBubbleSmall") { A_GetPlayerAttackDamage(46,0); }
			if (GetClassName() == "HubbleBubbleLarge") { A_GetPlayerAttackDamage(47,0); }
			if (GetClassName() == "EvilWarriorShieldBall" || GetClassName() == "EvilWarriorShieldBallCrisis") { A_GetPlayerAttackDamage(52,0); }
			if (GetClassName() == "SonicNail") { A_GetPlayerAttackDamage(63,0); }
			if (GetClassName() == "UnmakerLaser" || GetClassName() == "UnmakerLaserCrisis") { A_GetPlayerAttackDamage(71,0); }
		}
		// Mostly Original FastProjectile Code Beneath here.

		ClearInterpolation();
		double oldz = pos.Z;

		if (!bNoTimeFreeze)
		{
			//Added by MC: Freeze mode.
			if (isFrozen())
			{
				return;
			}
		}

		// [RH] Ripping is a little different than it was in Hexen
		FCheckPosition tm;
		tm.DoRipping = bRipper;

		int count = 8;
		if (radius > 0)
		{
			while (abs(Vel.X) >= radius * count || abs(Vel.Y) >= radius * count)
			{
				// we need to take smaller steps.
				count += count;
			}
		}

		if (height > 0)
		{
			while (abs(Vel.Z) >= height * count)
			{
				count += count;
			}
		}

		// Handle movement
		if (Vel != (0, 0, 0) || (pos.Z != floorz))
		{
			// force some lateral movement so that collision detection works as intended.
			if (bMissile && Vel.X == 0 && Vel.Y == 0 && !IsZeroDamage())
			{
				Vel.X = MinVel;
			}

			Vector3 frac = Vel / count;
			int changexy = frac.X != 0 || frac.Y != 0;
			int ripcount = count / 8;
			for (int i = 0; i < count; i++)
			{
				if (changexy)
				{
					if (--ripcount <= 0)
					{
						tm.ClearLastRipped();	// [RH] Do rip damage each step, like Hexen
					}
					
					if (!TryMove (Pos.XY + frac.XY, true, NULL, tm))
					{ // Blocked move
						if (!bSkyExplode)
						{
							let l = tm.ceilingline;
							if (l &&
								l.backsector &&
								l.backsector.GetTexture(sector.ceiling) == skyflatnum)
							{
								let posr = PosRelative(l.backsector);
								if (pos.Z >= l.backsector.ceilingplane.ZatPoint(posr.XY))
								{
									// Hack to prevent missiles exploding against the sky.
									// Does not handle sky floors.
									Destroy ();
									return;
								}
							}
							// [RH] Don't explode on horizon lines.
							if (BlockingLine != NULL && BlockingLine.special == Line_Horizon)
							{
								Destroy ();
								return;
							}
						}

						ExplodeMissile (BlockingLine, BlockingMobj);
						return;
					}
				}
				AddZ(frac.Z);
				UpdateWaterLevel();
				oldz = pos.Z;
				if (oldz <= floorz)
				{ // Hit the floor

					if (floorpic == skyflatnum && !bSkyExplode)
					{
						// [RH] Just remove the missile without exploding it
						//		if this is a sky floor.
						Destroy ();
						return;
					}

					SetZ(floorz);
					HitFloor ();
					ExplodeMissile (NULL, NULL);
					return;
				}
				if (pos.Z + height > ceilingz)
				{ // Hit the ceiling

					if (ceilingpic == skyflatnum && !bSkyExplode)
					{
						Destroy ();
						return;
					}

					SetZ(ceilingz - Height);
					ExplodeMissile (NULL, NULL);
					return;
				}
				CheckPortalTransition();
				if (changexy && ripcount <= 0) 
				{
					ripcount = count >> 3;

					// call the 'Effect' method.
					Effect();
				}
			}
		}
		if (!CheckNoDelay())
			return;		// freed itself
		// Advance the state
		if (tics != -1)
		{
			if (tics > 0) tics--;
			while (!tics)
			{
				if (!SetState (CurState.NextState))
				{ // mobj was removed
					return;
				}
			}
		}

		tic++;
	}
}

class AetheriusEffectFastProjectile : AetheriusFastProjectileZSC
{
	int user_canafflict;
	default
	{
		+HITMASTER;
	}
	
	void A_StatusEffectChecker(int basechance)
	{
		user_ailmentmaxchance = basechance;
		if (CountInv("EWShieldIdleMode",AAPTR_PLAYER1) > 0) user_ailmentmaxchance * 4;
		if (CallACS("GetBuffTimer",7) > 0) user_ailmentmaxchance * 4;

		user_canafflict = 1;
		if (master != null && master.health <= 0) { user_canafflict = 0; }
		if (CountInv("InvulnerabilitySpell",AAPTR_MASTER) > 0 || 
				CountInv("IsInvulnerable",AAPTR_MASTER) > 0 || 
				CountInv("MenuInvulnerability",AAPTR_MASTER) > 0 ||
				CountInv("EvadeAnAttack",AAPTR_MASTER) > 0 || 
				CountInv("PlayerDashing",AAPTR_MASTER) > 0) 
				{
					user_canafflict = 0;
				}

		AetheriusPlayerPawn playpawn;
		if (master) playpawn = AetheriusPlayerPawn(master);
		if (playpawn)
		{
			if (playpawn.player.cheats & CF_GODMODE2 || playpawn.player.cheats & CF_GODMODE) user_canafflict = 0;
		}
	}
}

// Base Bullet Tracer Class
class AetheriusBulletTracerZSC : AetheriusFastProjectileZSC
{
	override void PostBeginPlay()
	{
		A_ScaleVelocity(dvds_tracervelmulti);

		Super.PostBeginPlay();
	}
	
	action void A_SpawnTracerTrail(string name = "ZombieBulletTracerTrail", int extranum = 6, double spread = -2.5)
	{
		double posx = 0.0;
		A_SpawnItemEx(name,posx,0,0,0,0,0,0,128,0);
		for (int trailnum = 0; trailnum < extranum; trailnum++)
		{
			posx += spread;
			A_SpawnItemEx(name,posx,0,0,0,0,0,0,128,0);
		}
	}
}

// Base Puff Class
class AetheriusPuffZSC : AetheriusBaseProjectileZSC
{
	int user_hitsparkrand;
	int user_sparksizelevel;
	double user_sparkscalemulti;

	Default
	{
		+NOBLOCKMAP
		+NOGRAVITY
		+ALLOWPARTICLES
		+RANDOMIZE
		+ZDOOMTRANS
		RenderStyle "Translucent";
		Alpha 0.5;
		VSpeed 1;
		Mass 5;
	}

	void A_HitSparkGetSize()
	{
		user_sparksizelevel = CallACS("MiscVarCheckDECORATE",10035) + CallACS("MiscVarCheckDECORATE",10051);
		if (user_sparksizelevel <= 0) { A_SetScale(0.3125); A_FadeTo(0.6875); }
		if (user_sparksizelevel == 1) { A_SetScale(0.375); A_FadeTo(0.75); }
		if (user_sparksizelevel == 2) { A_SetScale(0.4375); A_FadeTo(0.8125); }
		if (user_sparksizelevel == 3) { A_SetScale(0.5); A_FadeTo(0.875); }
		if (user_sparksizelevel == 4) { A_SetScale(0.5625); A_FadeTo(0.9375); }
		if (user_sparksizelevel >= 5) { A_SetScale(0.625); A_FadeTo(1.0); }
		//Console.Printf("ScaleX: %.4f, ScaleY: %.4f, ALPHAZ: %.4f", self.scale.x, self.scale.y, self.alpha);
	}
	void A_HitSparkGetSize2()
	{
		user_sparkscalemulti = (CallACS("MiscVarCheckDECORATE",10005) * .05) + (CallACS("MiscVarCheckDECORATE",10006) * .125);
		user_sparkscalemulti += 1.00;
		scale.x *= user_sparkscalemulti;
		scale.y *= user_sparkscalemulti;
		//Console.Printf("ScaleX: %.4f, ScaleY: %.4f, MULTI: %.4f", self.scale.x, self.scale.y, user_sparkscalemulti);
	}

	void A_HitSparkResize()
	{
		double base;
		if (user_sparksizelevel <= 0) base = 0.25;
		if (user_sparksizelevel == 1) base = 0.275;
		if (user_sparksizelevel == 2) base = 0.30;
		if (user_sparksizelevel == 3) base = 0.325;
		if (user_sparksizelevel == 4) base = 0.35;
		if (user_sparksizelevel >= 5) base = 0.375;

		user_sparkscalemulti = frandom(base,(base*1.5));
		scale.x *= user_sparkscalemulti;
		scale.y *= user_sparkscalemulti;
		//Console.Printf("ScaleX: %.4f, ScaleY: %.4f", self.scale.x, self.scale.y);
	}

	States
	{
		Spawn:
			PUFF A 4 Bright;
			PUFF B 4;
		Melee:
			PUFF CD 4;
			Stop;
	}
}

// Base Crisis Particle
class AetheriusCrisisParticle : AetheriusBaseZSC
{
	double user_basealpha; 
	double user_basescaleX;
	double user_basescaleY;

	default
	{
		Speed 0.2;
		Vspeed -32;
		+NOBLOCKMAP
		+NOGRAVITY
		+NOTELEPORT
		+CANNOTPUSH
		+NOINTERACTION
		RenderStyle "Add";
		scale 0.67;
		Alpha 0.67;
	}

	void A_CrisisParticleInit()
	{
		alpha *= 0.67;
		scale.x *= 0.67;
		scale.y *= 0.67;
		user_basealpha = alpha * 0.10;
		user_basescaleX = scale.x * 0.10;
		user_basescaleY = scale.y * 0.10;
		//Console.Printf("BASEScaleX: %.4f, BASEScaleY: %.4f, BASEALPHAZ: %.4f", user_basescaleX, user_basescaleY, user_basealpha);
	}

	void A_CrisisParticleDo()
	{
		A_FadeOut(user_basealpha);
		self.scale.x -= user_basescaleX;
		self.scale.y -= user_basescaleY;
		//ThrustThingZ (0, 8, 0, 0);
		//Console.Printf("ScaleX: %.4f, ScaleY: %.4f, ALPHAZ: %.4f", self.scale.x, self.scale.y, self.alpha);

		if (self.scale.x < 0.00 && self.scale.y < 0.00) { A_FadeOut(2); }
	}

	States
	{
		Spawn:
			"####" "#" 0 Bright NoDelay A_CrisisParticleInit();
			goto Idle;
		Idle:
			"####" "#" 2 Bright A_CrisisParticleDo();
			loop;
	}
}
	
class AetheriusSpawnShotZSC : SpawnShot
{
	private void SpawnFlyDS(class<Actor> spawntype, sound snd)
	{
		Actor newmobj;
		Actor fog;
		Actor eye = master; // The eye is the spawnshot's master, not the target!
		Actor targ = target; // Unlike other projectiles, the target is the intended destination.
		int r;
			
		// [GZ] Should be more viable than a countdown...
		if (special2 != 0)
		{
			if (special2 > level.maptime)
				return;		// still flying
		}
		else
		{
			if (reactiontime == 0 || --reactiontime != 0)
				return;		// still flying
		}
		
		if (spawntype)
		{
			fog = Spawn (spawntype, targ.pos, ALLOW_REPLACE);
			if (fog) A_StartSound(snd, CHAN_BODY);
		}

		class<Actor> SpawnName = null;

		DropItem di;   // di will be our drop item list iterator
		DropItem drop; // while drop stays as the reference point.
		int n = 0;

		// First see if this cube has its own actor list
		drop = GetDropItems();

		// If not, then default back to its master's list
		if (drop == null && eye != null)
			drop = eye.GetDropItems();

		if (drop != null)
		{
			for (di = drop; di != null; di = di.Next)
			{
				if (di.Name != 'None')
				{
					if (di.Amount < 0)
					{
						//di.Amount = 1; // default value is -1, we need a positive value.
					}
					n += di.Amount; // this is how we can weight the list.
				}
			}
			di = drop;
			n = random[pr_spawnfly](0, n);
			while (n >= 0)
			{
				if (di.Name != 'none')
				{
					n -= di.Amount; // logically, none of the -1 values have survived by now.
				}
				if ((di.Next != null) && (n >= 0))
				{
					di = di.Next;
				}
				else
				{
					n = -1;
				}
			}
			SpawnName = di.Name;
		}
		if (SpawnName == null)
		{
			// Randomly select monster to spawn.
			r = random(1,256); // r = random[pr_spawnfly](0, 255);

			// Probability distribution (kind of :),
			// decreasing likelihood.
			if (r < 16)  SpawnName = "Zombieman";		// 16/256
			else if (r < 32)  SpawnName = "ShotgunGuy";  	// 16/256 
			else if (r < 48)  SpawnName = "ChaingunGuy";	// 16/256 
			else if (r < 72)  SpawnName = "DoomImp";  		// 24/256 
			else if (r < 96)  SpawnName = "Demon";  		// 24/256 
			else if (r < 108) SpawnName = "PainElemental";	// 12/256
			else if (r < 132) SpawnName = "Cacodemon";		// 24/256
			else if (r < 144) SpawnName = "Revenant";		// 12/256
			else if (r < 168) SpawnName = "Arachnotron";	// 24/256
			else if (r < 192) SpawnName = "Fatso";			// 24/256
			else if (r < 216) SpawnName = "HellKnight";		// 24/256
			else if (r < 228) SpawnName = "BaronOfHell";	// 12/256
			else if (r < 240) SpawnName = "HellCleric";		// 12/256
			else if (r < 244) SpawnName = "Archvile";		// 4/256
			else if (r < 248) SpawnName = "FlyingBalrog";	// 4/256
			else if (r < 252) SpawnName = "Cyberdemon";		// 4/256
			else SpawnName = "HadesOverlord";	// 4/256
		}
		if (spawnname != null)
		{
			newmobj = Spawn (spawnname, targ.pos, ALLOW_REPLACE);
			if (newmobj != null)
			{
				// Make the new monster hate what the boss eye hates
				if (eye != null)
				{
					newmobj.CopyFriendliness (eye, false);
				}
				// Make it act as if it was around when the player first made noise
				// (if the player has made noise).
				newmobj.LastHeard = newmobj.CurSector.SoundTarget;

				if (newmobj.SeeState != null && newmobj.LookForPlayers (true))
				{
					newmobj.SetState (newmobj.SeeState);
				}
				if (!newmobj.bDestroyed)
				{
					// telefrag anything in this spot
					newmobj.TeleportMove (newmobj.pos, true);
				}
				newmobj.bBossSpawned = true;
			}
		}

		// remove self (i.e., cube).
		Destroy ();
	}

	void A_SpawnFlyDS(class<Actor> spawntype = null)
	{
		sound snd; 
		if (spawntype != null) 
		{
			snd = GetDefaultByType(spawntype).SeeSound;
		}
		else
		{
			spawntype = "SpawnFire";
			snd = "brain/spawn";
		}
		SpawnFlyDS(spawntype, snd);
	}

	void A_SpawnSoundDS()
	{
		// travelling cube sound
		A_StartSound("brain/cube", CHAN_BODY);
		SpawnFlyDS("SpawnFire", "brain/spawn");
	}	
}

class AetheriusEffectProjectile : AetheriusProjectileZSC
{
	int user_canafflict;
	default
	{
		+HITMASTER;
	}
	
	void A_StatusEffectChecker(int basechance)
	{
		user_ailmentmaxchance = basechance;
		if (CountInv("EWShieldIdleMode",AAPTR_PLAYER1) > 0) user_ailmentmaxchance * 4;
		if (CallACS("GetBuffTimer",7) > 0) user_ailmentmaxchance * 4;

		user_canafflict = 1;
		if (master != null && master.health <= 0) { user_canafflict = 0; }
		if (CountInv("InvulnerabilitySpell",AAPTR_MASTER) > 0 || 
				CountInv("IsInvulnerable",AAPTR_MASTER) > 0 || 
				CountInv("MenuInvulnerability",AAPTR_MASTER) > 0 ||
				CountInv("EvadeAnAttack",AAPTR_MASTER) > 0 || 
				CountInv("PlayerDashing",AAPTR_MASTER) > 0) 
				{
					user_canafflict = 0;
				}

		AetheriusPlayerPawn playpawn;
		if (master) playpawn = AetheriusPlayerPawn(master);
		if (playpawn)
		{
			if (playpawn.player.cheats & CF_GODMODE2 || playpawn.player.cheats & CF_GODMODE) user_canafflict = 0;
		}
	}
}

class AetheriusWhirlwind : AetheriusProjectileZSC
{
	default
	{
		Accuracy 8;
		DamageType "Wind";
	}

	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		int randVal;
		if (Accuracy < 1) Accuracy = 1;
		int whirltimer = level.time & (Accuracy-1);
		int whirldmg = 3 * randompick(1,1,1,1,1,1,1,1,2,2,2,3);            
		if (Stamina == 30) whirldmg *= CallACS("CrisisMultiplier");

		if (!target.bDontThrust)
		{
			target.angle += Random2[WhirlwindDamage]() * (360 / 4096.);
			target.Vel.X += Random2[WhirlwindDamage]() / 64.;
			target.Vel.Y += Random2[WhirlwindDamage]() / 64.;
		}

		if ((level.time & 16) && !target.bBoss && !target.bDontThrust)
		{
			randVal = min(160, random[WhirlwindSeek]());
			target.Vel.Z += randVal / 32.;
			if (target.Vel.Z > 12)
			{
				target.Vel.Z = 12;
			}
		}

		if (whirltimer == 0)
		{
			target.DamageMobj (null, target, whirldmg, 'Wind');
		}
		return -1;
	}

	void A_WhirlwindSeek()
	{
		health -= 3;
		if (health < 0)
		{
			Vel = (0,0,0);
			SetStateLabel("Death");
			bMissile = false;
			return;
		}
		if ((threshold -= 3) < 0)
		{
			threshold = 58 + (random[WhirlwindSeek]() & 31);
			A_StartSound("ironlich/attack3", CHAN_BODY);
		}
		if (tracer && tracer.bShadow)
		{
			return;
		}
		A_SeekerMissile(10, 30);
	}
	
}

// Holy Spirit --------------------------------------------------------------
class HolySpiritBase : AetheriusDoomSpellZSC
{
	Default
	{
		Health 105;
		Speed 12;
		Radius 10;
		Height 6;
		Damage 3;
		Projectile;
		+RIPPER +SEEKERMISSILE
		+FOILINVUL +SKYEXPLODE +NOEXPLODEFLOOR +CANBLAST
		+EXTREMEDEATH +NOSHIELDREFLECT
		RenderStyle "Translucent";
		Alpha 0.4;
		DeathSound "SpiritDie";
		Obituary "$OB_MPCWEAPWRAITHVERGE";
	}

	States
	{
		Spawn:
			SPIR AAB 2 A_CHolySeek;
			SPIR B 2 A_CHolyCheckScream;
			Loop;
		Death:
			SPIR D 4;
			SPIR E 4 A_Scream;
			SPIR FGHI 4;
			Stop;
	}
	
	//============================================================================
	//
	//
	//
	//============================================================================

	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		int RandCall;

		string nm, nn, no, np;

		AetheriusMonsterZSC s2; 
		s2 = AetheriusMonsterZSC(target);
		
		string s2name;

		if (s2 != null)
		{
			s2name = s2.GetClassName();
			nm = "DSparilUnmountedNew";

			if (s2name == nm)
			{
				// D'Sparil teleports away
				if (CallACS("MiscVarCheckDECORATE",10003) <= 0) RandCall = 4;
				if (CallACS("MiscVarCheckDECORATE",10003) == 1) RandCall = 4;
				if (CallACS("MiscVarCheckDECORATE",10003) == 2) RandCall = 3;
				if (CallACS("MiscVarCheckDECORATE",10003) == 3) RandCall = 3;
				if (CallACS("MiscVarCheckDECORATE",10003) == 4) RandCall = 2;
				if (CallACS("MiscVarCheckDECORATE",10003) >= 5) RandCall = 2;

				if (random(1,1024) <= RandCall)
				{
					s2.DSparilTeleport();
					return -1;
				}
				return damage;
			}
			return damage;
		}
		return damage;
	}

	override bool Slam(Actor thing)
	{
		if (thing.bShootable && thing != target)
		{
			if (multiplayer && !deathmatch && thing.player && target.player)
			{
				// don't attack other co-op players
				return true;
			}
			if (thing.bReflective && (thing.player || thing.bBoss))
			{
				tracer = target;
				target = thing;
				return true;
			}
			if (thing.bIsMonster || thing.player)
			{
				tracer = thing;
			}
			if (random[SpiritSlam]() < 96)
			{
				int dam = 12;
				if (thing.player || thing.bBoss)
				{
					dam = 3;
					// ghost burns out faster when attacking players/bosses
					health -= 6;
				}
				if (Stamina == 30) { dam *= CallACS("CrisisMultiplier"); }

				thing.DamageMobj(self, target, dam, 'Melee');
				if (random[SpiritSlam]() < 128)
				{
					Spawn("HolyPuff", Pos, ALLOW_REPLACE);
					A_StartSound("SpiritAttack", CHAN_WEAPON);
					if (thing.bIsMonster && random[SpiritSlam]() < 128)
					{
						thing.Howl();
					}
				}
			}
			if (thing.health <= 0)
			{
				tracer = null;
			}
		}
		return true;
	}

	override bool SpecialBlastHandling (Actor source, double strength)
	{
		if (tracer == source)
		{
			tracer = target;
			target = source;
		}
		return true;
	}

	//============================================================================
	//
	// CHolyFindTarget
	//
	//============================================================================

	private void CHolyFindTarget ()
	{
		Actor target;

		if ( (target = RoughMonsterSearch (6, true)) )
		{
			tracer = target;
			bNoClip = true;
			bSkullFly = true;
			bMissile = false;
		}
	}

	//============================================================================
	//
	// CHolySeekerMissile
	//
	// Similar to P_SeekerMissile, but seeks to a random Z on the target
	//============================================================================

	private void CHolySeekerMissile (double thresh, double turnMax)
	{
		Actor target = tracer;
		if (target == NULL)
		{
			return;
		}
		if (!target.bShootable || (!target.bIsMonster && !target.player))
		{
			// Target died/target isn't a player or creature
			tracer = null;
			bNoClip = false;
			bSkullFly = false;
			bMissile = true;
			CHolyFindTarget();
			return;
		}
		double ang = deltaangle(angle, AngleTo(target));
		double delta = abs(ang);
		
		if (delta > thresh)
		{
			delta /= 2;
			if (delta > turnMax)
			{
				delta = turnMax;
			}
		}
		if (ang > 0)
		{
			// Turn clockwise
			angle += delta;
		}
		else
		{
			// Turn counter clockwise
			angle -= delta;
		}
		VelFromAngle();

		if (!(level.time&15) 
			|| pos.z > target.pos.z + target.height
			|| pos.z + height < target.pos.z)
		{
			double newZ = target.pos.z + ((random[HolySeeker]()*target.Height) / 256.);
			double deltaZ = newZ - pos.z;
			if (abs(deltaZ) > 15)
			{
				if (deltaZ > 0)
				{
					deltaZ = 15;
				}
				else
				{
					deltaZ = -15;
				}
			}
			Vel.Z = deltaZ / DistanceBySpeed(target, Speed);
		}
	}

	//============================================================================
	//
	// A_CHolySeek
	//
	//============================================================================

	void A_CHolySeek()
	{
		health--;
		if (health <= 0)
		{
			Vel.X /= 4;
			Vel.Y /= 4;
			Vel.Z = 0;
			SetStateLabel ("Death");
			tics -= random[HolySeeker]()&3;
			return;
		}
		if (tracer)
		{
			CHolySeekerMissile (args[0], args[0]*2.);
			if (!((level.time+7)&15))
			{
				args[0] = 5+(random[HolySeeker]()/20);
			}
		}

		int xyspeed = (random[HolySeeker]() % 5);
		int zspeed = (random[HolySeeker]() % 5);
		A_Weave(xyspeed, zspeed, 4., 2.);
	}

	//============================================================================
	//
	// A_CHolyCheckScream
	//
	//============================================================================

	void A_CHolyCheckScream()
	{
		A_CHolySeek();
		if (random[HolyScream]() < 20)
		{
			A_StartSound("SpiritActive", CHAN_VOICE);
		}
		if (!tracer)
		{
			CHolyFindTarget();
		}
	}
}

// Mage Staff FX2 (Bloodscourge) --------------------------------------------
class MageStaffFX2Base : AetheriusProjectileZSC
{
	Default
	{
		Speed 17;
		Height 8;
		Damage 4;
		DamageType "Fire";
		Projectile;
		+SEEKERMISSILE
		+SCREENSEEKER
		+EXTREMEDEATH
		DeathSound "MageStaffExplode";
		Obituary "$OB_MPMWEAPBLOODSCOURGE";
	}


	States
	{
		Spawn:
			MSP2 ABCD 2 Bright A_MStaffTrack;
			Loop;
		Death:
			MSP2 E 4 Bright A_SetTranslucent(1,1);
			MSP2 F 5 Bright A_Explode (80, 192, 0);
			MSP2 GH 5 Bright;
			MSP2 I 4 Bright;
			Stop;
	}
	
	//============================================================================
	//
	//
	//
	//============================================================================

	override int SpecialMissileHit (Actor victim)
	{
		if (victim != target && !victim.player && !victim.bBoss)
		{
			int dam = 10;
			if (Stamina == 30) { dam *= CallACS("CrisisMultiplier"); }

			victim.DamageMobj (self, target, dam, 'Fire');
			return 1;	// Keep going
		}
		return -1;
	}

	override bool SpecialBlastHandling (Actor source, double strength)
	{
		// Reflect to originator
		tracer = target;	
		target = source;
		return true;
	}

	//============================================================================
	//
	// A_MStaffTrack
	//
	//============================================================================

	void A_MStaffTrack()
	{
		if (tracer == null && random[MStaffTrack]() < 50)
		{
			tracer = RoughMonsterSearch (10, true);
		}
		A_SeekerMissile(2, 10);
	}
}

class HealMissile : AetheriusProjectileZSC
{
	// A_SeekerMissile variant that seeks out friends in need of healing.
	action void A_HealingSeekerMissile(int threshold, int maxturnangle, int flags = 0, int chance = 50, int distance = 10, int healtype = 0)
	{
		int maxhealth;
		if (
			(flags & SMF_LOOK) // this projectile should seek new targets
			&& target // this projectile's shooter is known
			&& (!tracer || !(tracer.bShootable && CanSeek(tracer))) // not already seeking something
			&& ((chance >= 255) || ((random() & 255) < chance)) // the random roll checks out
		)
		{
			for (let it = BlockThingsIterator.Create(self, distance); it.Next();)
			if (target != it.thing && target.isFriend(it.thing) && it.thing is "AetheriusMonsterZSC")
			{
				let healee = AetheriusMonsterZSC(it.thing);
				if (healtype == 0) maxhealth = healee.User_MaxHP; else maxhealth = healee.User_MaxHP*2;
				if (healee.health > 0 && healee.health < maxhealth)
				{
						tracer = it.thing;
						break;
				}
			}
		}
		A_SeekerMissile(threshold,maxturnangle,flags & ~SMF_LOOK,chance,distance);
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			if (!other.bFRIENDLY) return false;
		}
		// We don't really care about others making the check.
		return true;
	}

	override int SpecialMissileHit (Actor victim)
 	{
		AetheriusMonsterZSC healee;
		if (victim) healee = AetheriusMonsterZSC(victim);

 		if (healee == target) return 1;
 		if (healee && healee == tracer && !healee.bFRIENDLY) return 1;
		if (healee && healee.bFRIENDLY)
		{
			if (self.GetClassName() == "Heal1Shot")
			{
				if (healee.health > 0 && healee.health < healee.User_MaxHP)
				{
					healee.health += CallACS("Healing_Actor",0,1); 
					if (healee.health > healee.User_MaxHP) healee.health = healee.User_MaxHP;
					return -1;
				}
				else { return 1; }
			}

			if (self.GetClassName() == "Heal2Shot")
			{
				if (healee.health > 0 && healee.health < healee.User_MaxHP)
				{
					healee.health += CallACS("Healing_Actor",1,1);
					if (healee.health > healee.User_MaxHP) healee.health = healee.User_MaxHP;
					return -1;
				}
				else { return 1; }
			}

			if (self.GetClassName() == "Heal3Shot")
			{
				if (healee.health > 0 && healee.health < (healee.User_MaxHP*2))
				{
					healee.health += CallACS("Healing_Actor",2,1); 
					if (healee.health > (healee.User_MaxHP*2)) healee.health = (healee.User_MaxHP*2);
					return -1;
				}
				else { return 1; }
			}
		}

 		return -1;
 	}
}

// Converts Monsters to Friendlys [base for items like Monster Munchies]
class CharmMissile : AetheriusProjectileZSC
{
	override bool CanCollideWith(Actor other, bool passive)
	{
		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			if (other.bFRIENDLY)
				return false;
		}
		// We don't really care about others making the check.
		return true;
	}

	override int SpecialMissileHit (Actor victim)
	{
		if (victim == target) return 1;
		if (victim == tracer && victim.bFRIENDLY) return 1;
		return -1;
	}
}

class AetheriusBaseLightning : AetheriusProjectileZSC
{
	Default
	{
		MissileType "LightningZap";
		AttackSound "MageLightningZap";
		ActiveSound "MageLightningContinuous";
		Obituary "$OB_MPMWEAPLIGHTNING";
		Mass 3;
		Stamina 1;
		Accuracy 1;
	}
	
	override int SpecialMissileHit (Actor thing)
	{
		int dmg = self.mass * random(self.stamina,self.accuracy);

		if (thing.bShootable && thing != target)
		{
			if (thing.Mass < LARGE_MASS)
			{
				thing.Vel.X += Vel.X / 16;
				thing.Vel.Y += Vel.Y / 16;
			}
			if ((!thing.player && !thing.bBoss) || !(level.time&1))
			{
				thing.DamageMobj(self, target, dmg, 'Electric');
				A_StartSound(AttackSound, CHAN_WEAPON|CHAN_NOSTOP, CHANF_DEFAULT, 1);
				if (thing.bIsMonster && random[LightningHit]() < 64)
				{
					thing.Howl ();
				}
			}
			health--;
			if (health <= 0 || thing.health <= 0)
			{
				return 0;
			}
			if (bFloorHugger)
			{
				if (lastenemy && ! lastenemy.tracer)
				{
					lastenemy.tracer = thing;
				}
			}
			else if (!tracer)
			{
				tracer = thing;
			}
		}
		return 1; // lightning zaps through all sprites
	}
	
}

class AetheriusLightningTop : AetheriusBaseLightning
{
	const ZAGSPEED = 1;

	Default
	{
		Health 144;
		Speed 25;
		Radius 16;
		Height 40;
		Damage 8;
		Projectile;
		+CEILINGHUGGER
		RenderStyle "Add";
	}

	States
	{
		Spawn:
			MLFX A 2 Bright A_LightningZap;
			MLFX BCD 2 Bright A_LightningClip;
			Loop;
		Death:
			MLF2 A 2 Bright A_LightningRemove;
			MLF2 BCDEKLM 3 Bright;
			ACLO E 35;
			MLF2 NO 3 Bright;
			MLF2 P 4 Bright;
			MLF2 QP 3 Bright;
			MLF2 Q 4 Bright;
			MLF2 P 3 Bright;
			MLF2 O 3 Bright;
			MLF2 P 3 Bright;
			MLF2 P 1 Bright A_HideThing;
			ACLO E 1050;
			Stop;
	}
	
	//============================================================================
	//
	// A_LightningClip
	//
	//============================================================================

	void A_LightningClip()
	{
		Actor cMo;
		Actor target = NULL;
		int zigZag;

		if (bFloorHugger)
		{
			if (lastenemy == NULL)
			{
				return;
			}
			SetZ(floorz);
			target = lastenemy.tracer;
		}
		else if (bCeilingHugger)
		{
			SetZ(ceilingz - Height);
			target = tracer;
		}
		if (bFloorHugger)
		{
			// floor lightning zig-zags, and forces the ceiling lightning to mimic
			cMo = lastenemy;
			zigZag = random[LightningClip]();
			if((zigZag > 128 && special1 < 2) || special1 < -2)
			{
				Thrust(ZAGSPEED, angle + 90);
				if(cMo)
				{
					cMo.Thrust(ZAGSPEED, angle + 90);
				}
				special1++;
			}
			else
			{
				Thrust(ZAGSPEED,angle - 90);
				if(cMo)
				{
					cMo.Thrust(ZAGSPEED, angle - 90);
				}
				special1--;
			}
		}
		if(target)
		{
			if(target.health <= 0)
			{
				ExplodeMissile();
			}
			else
			{
				angle = AngleTo(target);
				VelFromAngle(Speed / 2);
			}
		}
	}


	//============================================================================
	//
	// A_LightningZap
	//
	//============================================================================

	void A_LightningZap(string MissileName = "LightningZap")
	{
		Class<Actor> lightning = MissileName;
		if (lightning == NULL) lightning = "LightningZap";

		A_LightningClip();

		health -= 8;
		if (health <= 0)
		{
			SetStateLabel ("Death");
			return;
		}
		double deltaX = (random[LightningZap]() - 128) * radius / 256;
		double deltaY = (random[LightningZap]() - 128) * radius / 256;
		double deltaZ = (bFloorHugger) ? 10 : -10;

		Actor mo = Spawn(lightning, Vec3Offset(deltaX, deltaY, deltaZ), ALLOW_REPLACE);
		if (mo)
		{
			mo.lastenemy = self;
			mo.Vel.X = Vel.X;
			mo.Vel.Y = Vel.Y;
			mo.Vel.Z = (bFloorHugger) ? 20 : -20;
			mo.target = target;
		}
		if (bFloorHugger && random[LightningZap]() < 160)
		{
			A_StartSound(ActiveSound, CHAN_BODY);
		}
	}

	//============================================================================
	//
	// A_LightningRemove
	//
	//============================================================================

	void A_LightningRemove()
	{
		Actor mo = lastenemy;
		if (mo)
		{
			bNoTarget = true;	// tell A_ZapMimic that we are dead. The original code did a state pointer compare which is not safe.
			mo.lastenemy = NULL;
			mo.ExplodeMissile ();
		}
	}
	
}

class AetheriusLightningBottom : AetheriusLightningTop
{
	Default
	{
		-CEILINGHUGGER
		+FLOORHUGGER
		RenderStyle "Add";
	}

	States
	{
	Spawn:
		MLFX E 2 Bright A_LightningZap;
		MLFX FGH 2 Bright A_LightningClip;
		Loop;
	Death:
		MLF2 F 2 Bright A_LightningRemove;
		MLF2 GHIJKLM 3 Bright;
		ACLO E 20;
		MLF2 NO 3 Bright;
		MLF2 P 4 Bright;
		MLF2 QP 3 Bright;
		MLF2 Q 4 Bright A_LastZap;
		MLF2 POP 3 Bright;
		MLF2 P 1 Bright A_HideThing;
		Goto Super::Death + 19;
	}
	
	//============================================================================
	//
	// A_LastZap
	//
	//============================================================================

	void A_LastZap(string MissileName = "LightningZap")
	{
		Class<Actor> lightning = MissileName;
		if (lightning == NULL) lightning = "LightningZap";
		
		Actor mo = Spawn(lightning, self.Pos, ALLOW_REPLACE);
		if (mo)
		{
			mo.SetStateLabel ("Death");
			mo.Vel.Z = 40;
			mo.SetDamage(0);
		}
	}
}

class AetheriusLightningZap : AetheriusProjectileZSC
{
	Default
	{
		Radius 15;
		Height 35;
		Damage 2;
		Projectile;
		-ACTIVATEIMPACT
		-ACTIVATEPCROSS
		RenderStyle "Add";
		Obituary "$OB_MPMWEAPLIGHTNING";
	}

	States
	{
		Spawn:
			MLFX IJKLM 2 Bright A_ZapMimic;
			Loop;
		Death:
			MLFX NOPQRSTU 2 Bright;
			Stop;
	}
	
	override int SpecialMissileHit (Actor thing)
	{
		Actor lmo;

		if (thing.bShootable && thing != target)
		{
			lmo = lastenemy;
			if (lmo)
			{
				if (lmo.bFloorHugger)
				{
					if (lmo.lastenemy && !lmo.lastenemy.tracer)
					{
						lmo.lastenemy.tracer = thing;
					}
				}
				else if (!lmo.tracer)
				{
					lmo.tracer = thing;
				}
				if (!(level.time&3))
				{
					lmo.health--;
				}
			}
		}
		return -1;
	}
	
	//============================================================================
	//
	// A_ZapMimic
	//
	//============================================================================

	void A_ZapMimic()
	{
		Actor mo = lastenemy;
		if (mo)
		{
			if (mo.bNoTarget)
			{
				ExplodeMissile ();
			}
			else
			{
				Vel.X = mo.Vel.X;
				Vel.Y = mo.Vel.Y;
			}
		}
	}
}

// Projectiles derived from this class should rip through actors,
// but not actually hit them more than once.
class SingleDamageRipper : AetheriusProjectileZSC
{
	default
	{
			Projectile;
			+RIPPER;
	}
	
	Array<Actor> ActorsAlreadyHit;
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		AetheriusPlayerPawn playpawn;
		AetheriusPlayerPawn playpawn2;
		AetheriusMonsterZSC DVDSActor;
		AetheriusMonsterZSC DVDSActor2;
		playpawn = AetheriusPlayerPawn(target);
		playpawn2 = AetheriusPlayerPawn(other);
		DVDSActor = AetheriusMonsterZSC(target);
		DVDSActor2 = AetheriusMonsterZSC(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer() > 0) return false;
					if (A_CheckFriendCollisionProjTypePlayer2() > 0) return false;
				}
			}
			else
			if (DVDSActor && DVDSActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1() > 0) return false;
				}
			}
			else 
			{
				if (GetClassName() == "HubbleBubbleSmall" || GetClassName() == "HubbleBubbleLarge") return false;
			}
		}
		// We don't really care about others making the check.

		for (let i = 0, size = ActorsAlreadyHit.Size(); i < size; i++)
				if (other == ActorsAlreadyHit[i])
						return false;
		
		return true;
	}
}

class SingleDamageFastRipper : AetheriusFastProjectileZSC
{
	default
	{
			Projectile;
			+RIPPER;
	}
	
	Array<Actor> ActorsAlreadyHit;
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		AetheriusPlayerPawn playpawn;
		AetheriusPlayerPawn playpawn2;
		AetheriusMonsterZSC DVDSActor;
		AetheriusMonsterZSC DVDSActor2;
		playpawn = AetheriusPlayerPawn(target);
		playpawn2 = AetheriusPlayerPawn(other);
		DVDSActor = AetheriusMonsterZSC(target);
		DVDSActor2 = AetheriusMonsterZSC(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer() > 0) return false;
					if (A_CheckFriendCollisionProjTypePlayer2() > 0) return false;
				}
			}
			else
			if (DVDSActor && DVDSActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1() > 0) return false;
				}
			}
			else 
			{
				if (GetClassName() == "HubbleBubbleSmall" || GetClassName() == "HubbleBubbleLarge") return false;
			}
		}
		// We don't really care about others making the check.

		for (let i = 0, size = ActorsAlreadyHit.Size(); i < size; i++)
				if (other == ActorsAlreadyHit[i])
						return false;
		
		return true;
	}
}

class SingleDamageEffectFastRipper : AetheriusEffectFastProjectile
{
	default
	{
		Projectile;
		+RIPPER;
		+HITMASTER;
	}
	
	void A_StatusEffectChecker(int basechance)
	{
		user_ailmentmaxchance = basechance;
		if (CountInv("EWShieldIdleMode",AAPTR_PLAYER1) > 0) user_ailmentmaxchance * 4;
		if (CallACS("GetBuffTimer",7) > 0) user_ailmentmaxchance * 4;

		user_canafflict = 1;
		if (master != null && master.health <= 0) { user_canafflict = 0; }
		if (CountInv("InvulnerabilitySpell",AAPTR_MASTER) > 0 || 
				CountInv("IsInvulnerable",AAPTR_MASTER) > 0 || 
				CountInv("MenuInvulnerability",AAPTR_MASTER) > 0 ||
				CountInv("EvadeAnAttack",AAPTR_MASTER) > 0 || 
				CountInv("PlayerDashing",AAPTR_MASTER) > 0) 
				{
					user_canafflict = 0;
				}

		AetheriusPlayerPawn playpawn;
		if (master) playpawn = AetheriusPlayerPawn(master);
		if (playpawn)
		{
			if (playpawn.player.cheats & CF_GODMODE2 || playpawn.player.cheats & CF_GODMODE) user_canafflict = 0;
		}
	}
}

class AetheriusFrostMissile : AetheriusDoomSpellZSC
{
	const SHARDSPAWN_LEFT	= 1;
	const SHARDSPAWN_RIGHT	= 2;
	const SHARDSPAWN_UP		= 4;
	const SHARDSPAWN_DOWN	= 8;
	
	Default
	{
		Speed 25;
		Radius 13;
		Height 8;
		Damage 1;
		DamageType "Ice";
		Projectile;
		DeathSound "MageShardsExplode";
		Obituary "$OB_MPMWEAPFROST";
	}

	States
	{
		Spawn:
			SHRD A 2 Bright;
			SHRD A 3 Bright A_ShedShard;
			SHRD B 3 Bright;
			SHRD C 3 Bright;
			Loop;
		Death:
			SHEX ABCDE 5 Bright;
			Stop;
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		AetheriusPlayerPawn playpawn;
		AetheriusPlayerPawn playpawn2;
		AetheriusMonsterZSC DVDSActor;
		AetheriusMonsterZSC DVDSActor2;
		playpawn = AetheriusPlayerPawn(target);
		playpawn2 = AetheriusPlayerPawn(other);
		DVDSActor = AetheriusMonsterZSC(target);
		DVDSActor2 = AetheriusMonsterZSC(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer() > 0) return false;
					if (A_CheckFriendCollisionProjTypePlayer2() > 0) return false;
				}
			}
			else
			if (DVDSActor && DVDSActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1() > 0) return false;
				}
			}
			else 
			{
				if (GetClassName() == "HubbleBubbleSmall" || GetClassName() == "HubbleBubbleLarge") return false;
			}

			let checkedenemy = Actor(other);
			if (!checkedenemy.bICECORPSE == 0) return false; else return true; // Makes the ice projectiles move PAST the frozen monster to hit other monsters.
		}
		// We don't really care about others making the check.

		return true;
	}
	
	override int DoSpecialDamage (Actor victim, int damage, Name damagetype)
	{
		if (special2 > 0)
		{
			damage <<= special2;
		}
		return damage;
	}

	//============================================================================
	//
	// A_ShedShard
	//
	//============================================================================

	void A_ShedShard()
	{
		int spawndir = special1;
		int spermcount = special2;
		Actor mo;

		if (spermcount <= 0)
		{
			return;				// No sperm left
		}
		special2 = 0;
		spermcount--;

		// every so many calls, spawn a new missile in its set directions
		if (spawndir & SHARDSPAWN_LEFT)
		{
			mo = SpawnMissileAngleZSpeed(pos.z, "FrostMissile", angle + 5, 0, (20. + 2 * spermcount), target);
			if (mo)
			{
				mo.special1 = SHARDSPAWN_LEFT;
				mo.special2 = spermcount;
				mo.Vel.Z = Vel.Z;
				mo.args[0] = (spermcount==3)?2:0;
			}
		}
		if (spawndir & SHARDSPAWN_RIGHT)
		{
			mo = SpawnMissileAngleZSpeed(pos.z, "FrostMissile",	angle - 5, 0, (20. + 2 * spermcount), target);
			if (mo)
			{
				mo.special1 = SHARDSPAWN_RIGHT;
				mo.special2 = spermcount;
				mo.Vel.Z = Vel.Z;
				mo.args[0] = (spermcount==3)?2:0;
			}
		}
		if (spawndir & SHARDSPAWN_UP)
		{
			mo = SpawnMissileAngleZSpeed(pos.z + 8., "FrostMissile", angle, 0, (15. + 2 * spermcount), target);
			if (mo)
			{
				mo.Vel.Z = Vel.Z;
				if (spermcount & 1)			// Every other reproduction
					mo.special1 = SHARDSPAWN_UP | SHARDSPAWN_LEFT | SHARDSPAWN_RIGHT;
				else
					mo.special1 = SHARDSPAWN_UP;
				mo.special2 = spermcount;
				mo.args[0] = (spermcount==3)?2:0;
			}
		}
		if (spawndir & SHARDSPAWN_DOWN)
		{
			mo = SpawnMissileAngleZSpeed(pos.z - 4., "FrostMissile", angle, 0, (15. + 2 * spermcount), target);
			if (mo)
			{
				mo.Vel.Z = Vel.Z;
				if (spermcount & 1)			// Every other reproduction
					mo.special1 = SHARDSPAWN_DOWN | SHARDSPAWN_LEFT | SHARDSPAWN_RIGHT;
				else
					mo.special1 = SHARDSPAWN_DOWN;
				mo.special2 = spermcount;
				mo.target = target;
				mo.args[0] = (spermcount==3)?2:0;
			}
		}
	}
}

class AetheriusIceShard : AetheriusFrostMissile
{
	Default
	{
		DamageType "Ice";
		-ACTIVATEIMPACT
		-ACTIVATEPCROSS
	}
	States
	{
		Spawn:
			SHRD ABC 3 Bright;
			Loop;
	}
}

class CFlameMissileNew : AetheriusFastProjectileZSC
{
	Default
	{
		Speed 200;
		Radius 14;
		Height 8;
		Damage 8;
		DamageType "Fire";
		+INVISIBLE
		+ZDOOMTRANS
		RenderStyle "Add";
		Obituary "$OB_MPCWEAPFLAME";
	}
	
	States
	{
		Spawn:
			CFFX A 4 Bright;
			CFFX A 1 A_CFlamePuff;
			Goto Death + 1;
		Death:
			CFFX A 1 Bright A_CFlameMissile;
			CFFX ABC 3 Bright;
			CFFX D 4 Bright;
			CFFX E 3 Bright;
			CFFX F 4 Bright;
			CFFX G 3 Bright;
			CFFX H 4 Bright;
			CFFX I 3 Bright;
			CFFX J 4 Bright;
			CFFX K 3 Bright;
			CFFX L 4 Bright;
			CFFX M 3 Bright;
			Stop;
	}
	
	override void BeginPlay ()
	{
		special1 = 2;
	}

	override void Effect ()
	{
		if (!--special1)
		{
			special1 = 4;
			double newz = pos.z - 12;
			if (newz < floorz)
			{
				newz = floorz;
			}
			Actor mo = Spawn ("CFlameFloor", (pos.xy, newz), ALLOW_REPLACE);
			if (mo)
			{
				mo.angle = angle;
			}
		}
	}
	
	//============================================================================
	//
	// A_CFlamePuff
	//
	//============================================================================

	void A_CFlamePuff()
	{
		bInvisible = false;
		bMissile = false;
		Vel = (0,0,0);
		A_StartSound("ClericFlameExplode", CHAN_BODY);
	}

	//============================================================================
	//
	// A_CFlameMissile
	//
	//============================================================================

	void A_CFlameMissile(string actorname = "CircleFlame")
	{
		bInvisible = false;
		A_StartSound("ClericFlameExplode", CHAN_BODY);
		if (BlockingMobj && BlockingMobj.bShootable)
		{ // Hit something, so spawn the flame circle around the thing
			double dist = BlockingMobj.radius + 18;
			for (int i = 0; i < 4; i++)
			{
				double an = i*45.;
				Actor mo = Spawn (actorname, BlockingMobj.Vec3Angle(dist, an, 5), ALLOW_REPLACE);
				if (mo)
				{
					mo.angle = an;
					mo.target = target;
					mo.VelFromAngle(CircleFlame.FLAMESPEED);
					mo.specialf1 = mo.Vel.X;
					mo.specialf2 = mo.Vel.Y;
					mo.tics -= random[FlameMissile]()&3;
				}
				an += 180;
				mo = Spawn(actorname, BlockingMobj.Vec3Angle(dist, an, 5), ALLOW_REPLACE);
				if(mo)
				{
					mo.angle = an;
					mo.target = target;
					mo.VelFromAngle(-CircleFlame.FLAMESPEED);
					mo.specialf1 = mo.Vel.X;
					mo.specialf2 = mo.Vel.Y;
					mo.tics -= random[FlameMissile]()&3;
				}
			}
			SetState (SpawnState);
		}
	}
}

class CircleFlameNew : AetheriusProjectileZSC
{
	const FLAMESPEED = 0.45;
	const FLAMEROTSPEED = 2.;
	
	Default
	{
		Radius 6;
		Damage 2;
		DamageType "Fire";
		Projectile;
		-ACTIVATEIMPACT
		-ACTIVATEPCROSS
		+ZDOOMTRANS
		RenderStyle "Add";
		DeathSound "ClericFlameCircle";
		Obituary "$OB_MPCWEAPFLAME";
	}

	States
	{
		Spawn:
			CFCF A 4 Bright;
			CFCF B 2 Bright A_CFlameRotate;
			CFCF C 2 Bright;
			CFCF D 1 Bright;
			CFCF E 2 Bright;
			CFCF F 2 Bright A_CFlameRotate;
			CFCF G 1 Bright;
			CFCF HI 2 Bright;
			CFCF J 1 Bright A_CFlameRotate;
			CFCF K 2 Bright;
			CFCF LM 3 Bright;
			CFCF N 2 Bright A_CFlameRotate;
			CFCF O 3 Bright;
			CFCF P 2 Bright;
			Stop;
		Death:
			CFCF QR 3 Bright;
			CFCF S 3 Bright A_Explode(20, 20, 0);
			CFCF TUVWXYZ 3 Bright;
			Stop;
	}
	
	//============================================================================
	//
	// A_CFlameRotate
	//
	//============================================================================

	void A_CFlameRotate()
	{
		double an = Angle + 90.;
		VelFromAngle(FLAMEROTSPEED, an);
		Vel.XY += (specialf1, specialf2);
		Angle += 6;
	}
}

class BishopFXNew : AetheriusProjectileZSC
{
	Default
	{
		Radius 10;
		Height 6;
		Speed 10;
		Damage 1;
		Projectile;
		+SEEKERMISSILE
		-ACTIVATEIMPACT -ACTIVATEPCROSS
		+STRIFEDAMAGE +ZDOOMTRANS
		RenderStyle "Add";
		DeathSound "BishopMissileExplode";
	}
	States
	{
	Spawn:
		BPFX ABAB 1 Bright A_BishopMissileWeave;
		BPFX B 0 Bright A_SeekerMissile(2,3);
		Loop;
	Death:
		BPFX CDEF 4 Bright;
		BPFX GH 3 Bright;
		Stop;
	}
}

class BlasterFX1Base : AetheriusFastProjectileZSC
{
	Default
	{
		Radius 12;
		Height 8;
		Speed 184;
		Damage 2;
		SeeSound "weapons/blastershoot";
		DeathSound "weapons/blasterhit";
		+SPAWNSOUNDSOURCE
		Obituary "$OB_MPPBLASTER";
	}

	States
	{
		Spawn:
			ACLO E 200;
			Loop;
		Death:
			FX18 A 3 BRIGHT A_SpawnRippers;
			FX18 B 3 BRIGHT;
			FX18 CDEFG 4 BRIGHT;
			Stop;
	}
	
	//----------------------------------------------------------------------------
	//
	// 
	//
	//----------------------------------------------------------------------------

	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		string nm, nn, no, np;
		nm = "IronLichNew";
		nn = "IceLich";
		no = "Goldlich";
		np = "BloodLich";
		if (target is "Ironlich" || target is nm || target is nn || target is no || target is np)
		{ // Less damage to Ironlich bosses
			damage /= 16; // random[BlasterFX]() & 1;
			if (!damage)
			{
				return -1;
			}
		}
		return damage;
	}

	override void Effect ()
	{
		if (random[BlasterFX]() < 64)
		{
			Spawn("BlasterSmoke", (pos.xy, max(pos.z - 8, floorz)), ALLOW_REPLACE);
		}
	}

	//----------------------------------------------------------------------------
	//
	// PROC A_SpawnRippers
	//
	//----------------------------------------------------------------------------

	void A_SpawnRippers(string atktype = "Ripper", int numshots = 8, double circ = 360.0)
	{
		numshots += ((CallACS("MiscVarCheckDECORATE",10053) / 2) + CallACS("MiscVarCheckDECORATE",10054));

		for(int i = 0; i < numshots; i++)
		{
			Actor ripper = Spawn(atktype, pos, ALLOW_REPLACE);
			if (ripper != null)
			{
				ripper.target = target;
				ripper.angle = i*(circ/numshots);
				ripper.VelFromAngle();
				ripper.CheckMissileSpawn (radius);
			}
		}
	}
}

class RipperBase : AetheriusProjectileZSC
{
	Default
	{
		Radius 8;
		Height 6;
		Speed 14;
		Damage 1;
		Projectile;
		+RIPPER
		DeathSound "weapons/blasterpowhit";
		Obituary "$OB_MPPBLASTER";
	}

	States
	{
		Spawn:
			FX18 M 4;
			FX18 N 5;
			Loop;
		Death:
			FX18 OPQRS 4 BRIGHT;
			Stop;
	}
	
	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		string nm, nn, no, np;
		nm = "IronLichNew";
		nn = "IceLich";
		no = "Goldlich";
		np = "BloodLich";
		if (target is "Ironlich" || target is nm || target is nn || target is no || target is np)
		{ // Less damage to Ironlich bosses
			damage /= 8; // random[Ripper]() & 1;
			if (!damage)
			{
				return -1;
			}
		}
		return damage;
	}
	
}

// Horn Rod FX 2 ------------------------------------------------------------
class HornRodFX2Base : AetheriusProjectileZSC
{
	Default
	{
		Radius 12;
		Height 8;
		Speed 22;
		Damage 10;
		Health 140;
		Projectile;
		RenderStyle "Add";
		SeeSound "weapons/hornrodpowshoot";
		DeathSound "weapons/hornrodpowhit";
		Obituary "$OB_MPPSKULLROD";
	}

	States
	{
		Spawn:	
			FX00 C 3 BRIGHT;
			FX00 D 3 BRIGHT A_SeekerMissile(10, 30);
			FX00 E 3 BRIGHT;
			FX00 F 3 BRIGHT A_SeekerMissile(10, 30);
			Loop;
		Death:
			FX00 H 5 BRIGHT A_AddPlayerRain;
			FX00 I 5 BRIGHT;
			FX00 J 4 BRIGHT;
			FX00 KLM 3 BRIGHT;
			FX00 G 1 A_HideInCeiling;
			FX00 G 1 A_SkullRodStorm;
			Wait;
	}
	
	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		int RandCall;

		string nm, nn, no, np;

		AetheriusMonsterZSC s2; 
		s2 = AetheriusMonsterZSC(target);
		
		string s2name;

		if (s2 != null)
		{
			s2name = s2.GetClassName();
			nm = "DSparilUnmountedNew";

			if (s2name == nm)
			{
				// D'Sparil teleports away
				if (CallACS("MiscVarCheckDECORATE",10053) <= 0) RandCall = 96;
				if (CallACS("MiscVarCheckDECORATE",10053) == 1) RandCall = 92;
				if (CallACS("MiscVarCheckDECORATE",10053) == 2) RandCall = 86;
				if (CallACS("MiscVarCheckDECORATE",10053) == 3) RandCall = 78;
				if (CallACS("MiscVarCheckDECORATE",10053) == 4) RandCall = 68;
				if (CallACS("MiscVarCheckDECORATE",10053) >= 5) RandCall = 56;

				if (random[HornRodFX2]() <= RandCall)
				{
					s2.DSparilTeleport();
					return -1;
				}
				return damage;
			}
			return damage;
		}

		return damage;
	}
	
	//----------------------------------------------------------------------------
	//
	// PROC A_AddPlayerRain
	//
	//----------------------------------------------------------------------------

	void A_AddPlayerRain()
	{
		RainTracker tracker;

		if (target == null || target.health <= 0)
		{
			// Shooter is dead or nonexistant
			return;
		}

		tracker = RainTracker(target.FindInventory("RainTracker"));

		// They player is only allowed two rainstorms at a time. Shooting more
		// than that will cause the oldest one to terminate.
		if (tracker != null)
		{
			if (tracker.Rain1 && tracker.Rain2)
			{
				// Terminate an active rain
				if (tracker.Rain1.health < tracker.Rain2.health)
				{
					if (tracker.Rain1.health > 16)
					{
						tracker.Rain1.health = 16;
					}
					tracker.Rain1 = null;
				}
				else
				{
					if (tracker.Rain2.health > 16)
					{
						tracker.Rain2.health = 16;
					}
					tracker.Rain2 = null;
				}
			}
		}
		else
		{
			tracker = RainTracker(target.GiveInventoryType("RainTracker"));
		}
		// Add rain mobj to list
		if (tracker.Rain1)
		{
			tracker.Rain2 = self;
		}
		else
		{
			tracker.Rain1 = self;
		}
		ActiveSound = "misc/rain";
	}
	
	//----------------------------------------------------------------------------
	//
	// PROC A_HideInCeiling
	//
	//----------------------------------------------------------------------------

	void A_HideInCeiling()
	{
		// This no longer hides in the ceiling. It just makes the actor invisible and keeps it in place.
		// We need its actual position to determine the correct ceiling height in A_SkullRodStorm.
		bInvisible = true;
		bSolid = false;
		bMissile = false;
		Vel = (0,0,0);
	}
	
	//----------------------------------------------------------------------------
	//
	// PROC A_SkullRodStorm [CUSTOMIZED for Aetherius Acid Rain stuff] :V
	//
	//----------------------------------------------------------------------------
	void A_AcidRainDrop(Class<Actor> missiletype, int xradius = 64, int yradius = 64)
	{
		static const Name translations[] =
		{
			"RainPillar1", "RainPillar2", "RainPillar3", "RainPillar4",
			"RainPillar5", "RainPillar6", "RainPillar7", "RainPillar8"
		};

		double xo = random(-xradius,xradius); // ((Random[SkullRodStorm]() & 127) - 64);
		double yo = random(-yradius,yradius); // ((Random[SkullRodStorm]() & 127) - 64);
		Vector3 spawnpos = Vec2OffsetZ(xo, yo, pos.z);
		Actor mo = Spawn(missiletype, spawnpos, ALLOW_REPLACE);
		if (!mo) return;
		
		// Find the ceiling above the spawn location. This may come from 3D floors but will not reach through portals.
		// (should probably be fixed for portals, too.)
		double newz = mo.CurSector.NextHighestCeilingAt(mo.pos.x, mo.pos.y, mo.pos.z, mo.pos.z, FFCF_NOPORTALS) - mo.height;
		mo.SetZ(newz);
    
		if (multiplayer && target.player)
		{
			mo.A_SetTranslation(translations[target.PlayerNumber()]);
		}
		mo.target = target;
		mo.Vel.X = MinVel; // Force collision detection
		mo.Vel.Z = -mo.Speed;
		mo.CheckMissileSpawn (radius);
		if (ActiveSound > 0) A_StartSound(ActiveSound, CHAN_BODY, CHANF_DEFAULT, 1);
	}

	void A_SkullRodStorm(Class<Actor> missiletype = "RainPillar", 
			int xradius =             64,	int yradius =             64, 
			int rainspawnchance1 =   231,	int rainspawnchance2 =    16,	int rainspawnchance3 =     0,	int rainspawnchance4 =     0, 
			int rainspawnchance5 =     0,	int rainspawnchance6 =     0,	int rainspawnchance7 =     0,	int rainspawnchance8 =     0, 
			int rainspawnchance9 =     0,	int rainspawnchance10 =    0,	int rainspawnchance11 =    0,	int rainspawnchance12 =    0, 
			int rainspawnchance13 =    0,	int rainspawnchance14 =    0,	int rainspawnchance15 =    0,	int rainspawnchance16 =    0)
	{
		if (health-- == 0)
		{
			A_StopSound (CHAN_BODY);
			if (target == null)
			{
				// Player left the game
				Destroy ();
				return;
			}
			RainTracker tracker = RainTracker(target.FindInventory("RainTracker"));
			if (tracker != null)
			{
				if (tracker.Rain1 == self)
				{
					tracker.Rain1 = null;
				}
				else if (tracker.Rain2 == self)
				{
					tracker.Rain2 = null;
				}
			}
			Destroy ();
			return;
		}
		if (Random[SkullRodStorm](1,256) <= rainspawnchance1) A_AcidRainDrop(missiletype,xradius,yradius);
		if (Random[SkullRodStorm](1,256) <= rainspawnchance2) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance3) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance4) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance5) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance6) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance7) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance8) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance9) A_AcidRainDrop(missiletype,xradius,yradius);
		if (Random[SkullRodStorm](1,256) <= rainspawnchance10) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance11) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance12) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance13) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance14) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance15) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance16) A_AcidRainDrop(missiletype,xradius,yradius); 
	}
}

class RainPillarBase : AetheriusProjectileZSC
{
	Default
	{
		Radius 5;
		Height 12;
		Speed 12;
		Damage 5;
		Mass 5;
		Projectile;
		-ACTIVATEPCROSS
		-ACTIVATEIMPACT
		+ZDOOMTRANS
		RenderStyle "Add";
		Obituary "$OB_MPPSKULLROD";
	}

	States
	{
		Spawn:
			FX22 A -1 BRIGHT;
			Stop;
		Death:
			FX22 B 4 BRIGHT A_RainImpact;
			FX22 CDEF 4 BRIGHT;
			Stop;
		NotFloor:
			FX22 GHI 4 BRIGHT;
			Stop;
	}
	
	//----------------------------------------------------------------------------
	//
	// PROC A_RainImpact
	//
	//----------------------------------------------------------------------------

	void A_RainImpact()
	{
		if (pos.z > floorz)
		{
			SetStateLabel("NotFloor");
		}
		else if (random[RainImpact]() < 40)
		{
			HitFloor ();
		}
	}

	// Rain pillar 1 ------------------------------------------------------------

	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		if (target.bBoss)
		{ // Decrease damage for bosses
			damage /= random(4,5); // damage = random[RainDamage](1, 8);
		}
		return damage;
	}
}

class PhoenixFX1Base : AetheriusProjectileZSC
{
	Default
	{
		Radius 11;
		Height 8;
		Speed 20;
		Damage 20;
		DamageType "Fire";
		Projectile;
		+THRUGHOST
		+SPECIALFIREDAMAGE
		SeeSound "weapons/phoenixshoot";
		DeathSound "weapons/phoenixhit";
		Obituary "$OB_MPPHOENIXROD";
	}

	States
	{
		Spawn:
			FX04 A 4 BRIGHT A_PhoenixPuff;
			Loop;
		Death:
			FX08 A 6 BRIGHT A_Explode;
			FX08 BC 5 BRIGHT;
			FX08 DEFGH 4 BRIGHT;
			Stop;
	}
	
	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		int RandCall;

		string nm, nn, no, np;

		AetheriusMonsterZSC s2; 
		s2 = AetheriusMonsterZSC(target);
		
		string s2name;

		if (s2 != null)
		{
			s2name = s2.GetClassName();
			nm = "DSparilUnmountedNew";

			if (s2name == nm)
			{
				// D'Sparil teleports away
				if (CallACS("MiscVarCheckDECORATE",10053) <= 0) RandCall = 96;
				if (CallACS("MiscVarCheckDECORATE",10053) == 1) RandCall = 92;
				if (CallACS("MiscVarCheckDECORATE",10053) == 2) RandCall = 86;
				if (CallACS("MiscVarCheckDECORATE",10053) == 3) RandCall = 78;
				if (CallACS("MiscVarCheckDECORATE",10053) == 4) RandCall = 68;
				if (CallACS("MiscVarCheckDECORATE",10053) >= 5) RandCall = 56;

				if (random[HornRodFX2]() <= RandCall)
				{
					s2.DSparilTeleport();
					return -1;
				}
				return damage;
			}
			return damage;
		}
		return damage;
	}

	//----------------------------------------------------------------------------
	//
	// PROC A_PhoenixPuff
	//
	//----------------------------------------------------------------------------

	void A_PhoenixPuff(string missiletype = "PhoenixPuff", double anglediff = 90.0, double puffspeed = 1.3)
	{
		//[RH] Heretic never sets the target for seeking
		//P_SeekerMissile (self, 5, 10);
		Actor puff = Spawn(missiletype, Pos, ALLOW_REPLACE);
		if (puff != null)
		{
			puff.Vel.XY = AngleToVector(Angle + anglediff, puffspeed);
		}

		puff = Spawn(missiletype, Pos, ALLOW_REPLACE);
		if (puff != null)
		{
			puff.Vel.XY = AngleToVector(Angle - anglediff, puffspeed);
		}
	}
}

class PhoenixFX2Base : AetheriusProjectileZSC
{
	Default
	{
		Radius 6;
		Height 8;
		Speed 10;
		Damage 2;
		DamageType "Fire";
		Projectile;
		RenderStyle "Add";
		+ZDOOMTRANS
		Obituary "$OB_MPPPHOENIXROD";
	}

	States
	{
		Spawn:
			FX09 ABABA 2 BRIGHT;
			FX09 B 2 BRIGHT A_FlameEnd;
			FX09 CDEF 2 BRIGHT;
			Stop;
		Death:
			FX09 G 3 BRIGHT;
			FX09 H 3 BRIGHT A_FloatPuff;
			FX09 I 4 BRIGHT;
			FX09 JK 5 BRIGHT;
			Stop;
	}
	

	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		if (target.player && Random[PhoenixFX2]() < 128)
		{ // Freeze player for a bit
			target.reactiontime += 4;
		}
		return damage;
	}
	
	//----------------------------------------------------------------------------
	//
	// PROC A_FlameEnd
	//
	//----------------------------------------------------------------------------

	void A_FlameEnd()
	{
		Vel.Z += 1.5;
	}

	//----------------------------------------------------------------------------
	//
	// PROC A_FloatPuff
	//
	//----------------------------------------------------------------------------

	void A_FloatPuff()
	{
		Vel.Z += 1.8;
	}
}

class MaceFX1Base : AetheriusProjectileZSC
{
	const MAGIC_JUNK = 1234;
	
	Default
	{
		Radius 8;
		Height 6;
		Speed 20;
		Damage 2;
		Projectile;
		+THRUGHOST
		BounceType "HereticCompat";
		SeeSound "weapons/maceshoot";
		Obituary "$OB_MPMACE";
	}

	States
	{
		Spawn:
			FX02 AB 4 A_MacePL1Check;
			Loop;
		Death:
			FX02 F 4 BRIGHT A_MaceBallImpact;
			FX02 GHIJ 4 BRIGHT;
			Stop;
	}
	
	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		int olddmg = damage;
		AetheriusMonsterZSC DVDSActor; DVDSActor = AetheriusMonsterZSC(target);
		if (DVDSActor && DVDSActor.user_legendaryevolved) damage *= MACELDLDMGMULTI;
		if (dvdsdebug_actordmgdisplays) Console.Printf("    (\czProjectile Damage Output [DoSpecialDamage]\c-: \cxolddmg = %d\c-, \cydmg = %d\c-)", olddmg, damage);
		return damage;
	}

	//----------------------------------------------------------------------------
	//
	// PROC A_MacePL1Check
	//
	//----------------------------------------------------------------------------

	void A_MacePL1Check()
	{
		if (special1 == 0) return;
		special1 -= 4;
		if (special1 > 0) return;
		special1 = 0;
		bNoGravity = false;
		Gravity = 1. / 8;
		// [RH] Avoid some precision loss by scaling the velocity directly
		double velscale = 7 / Vel.XY.Length();
		Vel.XY *= velscale;
		Vel.Z *= 0.5;
	}

	//----------------------------------------------------------------------------
	//
	// PROC A_MaceBallImpact
	//
	//----------------------------------------------------------------------------

	void A_MaceBallImpact()
	{
		if ((health != MAGIC_JUNK) && bInFloat)
		{ // Bounce
			health = MAGIC_JUNK;
			Vel.Z *= 0.75;
			bBounceOnFloors = bBounceOnCeilings = false;
			SetState (SpawnState);
			A_StartSound("weapons/macebounce", CHAN_BODY);
		}
		else
		{ // Explode
			Vel = (0,0,0);
			bNoGravity = true;
			Gravity = 1;
			A_StartSound("weapons/macehit", CHAN_BODY);
		}
	}
}

class MaceFX2Base : MaceFX1Base
{
	Default
	{
		Speed 10;
		Damage 6;
		Gravity 0.125;
		-NOGRAVITY
		SeeSound "";
	}

	States
	{
		Spawn:
			FX02 CD 4;
			Loop;
		Death:
			FX02 F 4 A_MaceBallImpact2;
			goto Super::Death+1;
	}
	
	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		int olddmg = damage;
		AetheriusMonsterZSC DVDSActor; DVDSActor = AetheriusMonsterZSC(target);
		if (DVDSActor && DVDSActor.user_legendaryevolved) damage *= MACELDLDMGMULTI;
		if (dvdsdebug_actordmgdisplays) Console.Printf("    (\czProjectile Damage Output [DoSpecialDamage]\c-: \cxolddmg = %d\c-, \cydmg = %d\c-)", olddmg, damage);
		return damage;
	}

	//----------------------------------------------------------------------------
	//
	// PROC A_MaceBallImpact2
	//
	//----------------------------------------------------------------------------

	void A_MaceBallImpact2()
	{
		if ((pos.Z <= floorz) && HitFloor ())
		{ // Landed in some sort of liquid
			Destroy ();
			return;
		}
		if (bInFloat)
		{
			if (Vel.Z >= 2)
			{
				// Bounce
				Vel.Z *= 0.75;
				SetState (SpawnState);

				Actor tiny = Spawn("MaceFX3", Pos, ALLOW_REPLACE);
				if (tiny != null)
				{
					tiny.target = target;
					tiny.angle = angle + 90.;
					tiny.VelFromAngle(Vel.Z - 1.);
					tiny.Vel += (Vel.XY * .5, Vel.Z);
					tiny.CheckMissileSpawn (radius);
				}

				tiny = Spawn("MaceFX3", Pos, ALLOW_REPLACE);
				if (tiny != null)
				{
					tiny.target = target;
					tiny.angle = angle - 90.;
					tiny.VelFromAngle(Vel.Z - 1.);
					tiny.Vel += (Vel.XY * .5, Vel.Z);
					tiny.CheckMissileSpawn (radius);
				}
				return;
			}
		}
		Vel = (0,0,0);
		bNoGravity = true;
		bBounceOnFloors = bBounceOnCeilings = false;
		Gravity = 1;
	}
}

class MaceFX3Base : MaceFX1Base
{
	Default
	{
		Speed 7;
		Damage 4;
		-NOGRAVITY;
		Gravity 0.125;
	}

	States
	{
		Spawn:
			FX02 AB 4;
			Loop;
	}

	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		int olddmg = damage;
		AetheriusMonsterZSC DVDSActor; DVDSActor = AetheriusMonsterZSC(target);
		if (DVDSActor && DVDSActor.user_legendaryevolved) damage *= MACELDLDMGMULTI;
		if (dvdsdebug_actordmgdisplays) Console.Printf("    (\czProjectile Damage Output [DoSpecialDamage]\c-: \cxolddmg = %d\c-, \cydmg = %d\c-)", olddmg, damage);
		return damage;
	}
}

class MaceFX4Base : AetheriusProjectileZSC
{
	Default
	{
		Radius 8;
		Height 6;
		Speed 7;
		Damage 18;
		Gravity 0.125;
		Projectile;
		-NOGRAVITY
		+TELESTOMP
		+THRUGHOST
		-NOTELEPORT
		BounceType "HereticCompat";
		SeeSound "";
		Obituary "$OB_MPPMACE";
	}

	States
	{
		Spawn:
			FX02 E 99;
			Loop;
		Death:
			TNT1 A 0 
			{
				A_Quake(1, 4, 0, 512, "");
				A_Quake(4, 4, 0, 256, "");
			}
			FX02 C 4 A_DeathBallImpact;
			FX02 GHIJ 4 BRIGHT;
			Stop;
	}
	
	//---------------------------------------------------------------------------
	//
	// FUNC P_AutoUseChaosDevice
	//
	//---------------------------------------------------------------------------

	private bool AutoUseChaosDevice (PlayerInfo player)
	{
		Inventory arti = player.mo.FindInventory("ArtiTeleport");

		if (arti != null)
		{
			player.mo.UseInventory (arti);
			player.health = player.mo.health = (player.health+1)/2;
			return true;
		}
		return false;
	}
	
	//----------------------------------------------------------------------------
	//
	// PROC DoSpecialDamage
	//
	//----------------------------------------------------------------------------

	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		int olddmg = damage;
		AetheriusMonsterZSC DVDSActor; DVDSActor = AetheriusMonsterZSC(target);

		int legendarycheck = 0;
		int monstermaxhp;
		if (DVDSActor) monstermaxhp = DVDSActor.user_MaxHP * 10; else monstermaxhp = SpawnHealth() * 10;
		if (DVDSActor && DVDSActor.user_legendaryevolved) legendarycheck = 1;

		if (target.bBoss || target.bDontSquash || legendarycheck || target.IsTeammate (self.target))
		{ // Don't allow cheap boss kills and don't instagib teammates
			if (legendarycheck) damage *= MACELDLDMGMULTI;
			if (dvdsdebug_actordmgdisplays) Console.Printf("    (\czProjectile Damage Output [DoSpecialDamage]\c-: \cxolddmg = %d\c-, \cydmg = %d\c-)", olddmg, damage);
			return damage;
		}
		else if (target.player)
		{ // Player specific checks
			if (target.player.mo.bInvulnerable)
			{ // Can't hurt invulnerable players
				return -1;
			}
			if (AutoUseChaosDevice (target.player))
			{ // Player was saved using chaos device
				return -1;
			}
		}
		damage = monstermaxhp;
		if (dvdsdebug_actordmgdisplays) Console.Printf("    (\czProjectile Damage Output [DoSpecialDamage]\c-: \cxolddmg = %d\c-, \cydmg = %d\c-)", olddmg, damage);
		return damage; // Something's probably gonna die
	}

	//----------------------------------------------------------------------------
	//
	// PROC A_DeathBallImpact
	//
	//----------------------------------------------------------------------------

	void A_DeathBallImpact()
	{
		FTranslatedLineTarget t;

		if ((pos.Z <= floorz) && HitFloor ())
		{ // Landed in some sort of liquid
			Destroy ();
			return;
		}
		if (bInFloat)
		{
			if (Vel.Z >= 2)
			{
				// Bounce
				bool newAngle = false;
				double ang = 0;
				if (tracer)
				{
					if (!tracer.bShootable)
					{ // Target died
						tracer = null;
					}
					else
					{ // Seek
						ang = AngleTo(tracer);
						newAngle = true;
					}
				}
				else
				{ // Find new target
					ang = 0.;
					for (int i = 0; i < 32; i++)
					{
						AimLineAttack (ang, 1280., t, 0., ALF_NOFRIENDS|ALF_PORTALRESTRICT, null, target);
						if (t.linetarget && target != t.linetarget)
						{
							tracer = t.linetarget;
							ang = t.angleFromSource;
							newAngle = true;
							break;
						}
						ang += 11.25;
					}
				}
				if (newAngle)
				{
					angle = ang;
					VelFromAngle();
				}
				SetState (SpawnState);
				A_StartSound("weapons/macestop", CHAN_BODY);
				return;
			}
		}
		Vel = (0,0,0);
		bNoGravity = true;
		Gravity = 1;
		A_StartSound("weapons/maceexplode", CHAN_BODY);
	}
}

class LoreShotBase : AetheriusProjectileZSC
{
	Default
	{
		Speed 20;
		Height 14;
		Radius 10;
		Projectile;
		+STRIFEDAMAGE
		Damage 2;
		MaxStepHeight 4;
		SeeSound "loremaster/chain";
		ActiveSound "loremaster/swish";
	}

	States
	{
	Spawn:
		OCLW A 2 A_LoremasterChain;
		Loop;
	Death:
		OCLW A 6;
		Stop;
	}
	
	override int DoSpecialDamage (Actor victim, int damage, Name damagetype)
	{
		if (victim != NULL && target != NULL && !victim.bDontThrust)
		{
			Vector3 thrust = victim.Vec3To(target);
			victim.Vel += thrust.Unit() * (255. * 50 / max(victim.Mass, 1));
		}
		return damage;
	}

	void A_LoremasterChain ()
	{
		A_StartSound("loremaster/active", CHAN_BODY);
		Spawn("LoreShot2", Pos, ALLOW_REPLACE);
		Spawn("LoreShot2", Vec3Offset(-Vel.x/2., -Vel.y/2., -Vel.z/2.), ALLOW_REPLACE);
		Spawn("LoreShot2", Vec3Offset(-Vel.x, -Vel.y, -Vel.z), ALLOW_REPLACE);
	}
	
}

class GravityHPBall : AetheriusFastProjectileZSC
{
	default
	{
		Damage (0);
		+MISSILE
		+PAINLESS
		+NODAMAGETHRUST
		+CANNOTPUSH
		+NOTIMEFREEZE
		+FOILINVUL
		RenderStyle "Add";
		Alpha 0.0;
		Speed 511;
		Radius 1;
		Height 1;
		FastSpeed 511;
		SeeSound "null";
		DeathSound "null";
	}

	override int SpecialMissileHit (Actor victim)
 	{
		int TrueGameSkill = dvds_gendifficultycurve + Skill;
		double GravityEffectFactor, FinalGravityFactor;
		int PropertyValue;
		int LevelFactor;
		double EffectChance;
		string vict;

		AetheriusMonsterZSC svictim;
		if (victim) svictim = AetheriusMonsterZSC(victim);

		if (svictim && svictim.bISMONSTER)
		{
			vict = svictim.GetClassName();
			if (vict == "PracticeTarget" || vict == "PracticeTarget2") EffectChance = 0;
			else if (vict == "ProgrammerNew" || vict == "StrifeBishopNew" || vict == "OracleNew" || vict == "Macil1New" || vict == "LoremasterNew" ||
							 vict == "AlienSpectre1New" || vict == "AlienSpectre2New" || vict == "AlienSpectre3New" || vict == "AlienSpectre4New" || vict == "AlienSpectre5New" ||
							 vict == "EntityBossNew" || vict == "EntitySecondNew" || vict == "EntityAscended") EffectChance = 0;
			else if (vict == "SirenNightmareNew" || vict == "CeilingTurretNew") EffectChance = 0;
			else if (vict == "ThamuzNew" || vict == "TchernobogNew") EffectChance = 0.03125;
			else if (vict == "DSparilMountedNew" || vict == "DSparilUnmountedNew" || vict == "KoraxNew" || vict == "Zakachi") EffectChance = 1;
			else if (vict == "Daedabus") EffectChance = 8;
			else if (vict == "Macil2New") EffectChance = 8;
			else if (vict == "HeresiarchNew" || vict == "ClericBossNew" || vict == "FighterBossNew" || vict == "FighterBossNew") EffectChance = 16;
			else if (vict == "VampireDVDS" || vict == "ReaverNew" || vict == "CrusaderNew" || vict == "SentinelNew" || vict == "OStalkerNew") EffectChance = 32;
			else if (vict == "Bormereth" || vict == "DragonNew") EffectChance = 64;
			else if (vict == "MaulotaurNew" || vict == "TNTSpider") EffectChance = 85;
			else if (vict == "Hierophant" || vict == "TemplarNew") EffectChance = 128;
			else EffectChance = 256;
			
			double roll = frandom(0.1,256.0);
			//Console.Printf("    (\czINFO:\c- \Roll vs EffectChance [%s]\c-: \cy%.8f vs %.8f\c-)", vict, roll, EffectChance);
			if (frandom(0.1,256.0) <= EffectChance)
			{
				//Console.Printf("    (\czINFO:\c- \EffectChance Successful!\c-)");
				if (TrueGameSkill <= SKILL_VERY_EASY) GravityEffectFactor = 0.125;  
				if (TrueGameSkill == SKILL_EASY) GravityEffectFactor = 0.250;  
				if (TrueGameSkill == SKILL_NORMAL) GravityEffectFactor = 0.500;  
				if (TrueGameSkill == SKILL_HARD) GravityEffectFactor = 0.750;  
				if (TrueGameSkill == SKILL_VERY_HARD) GravityEffectFactor = 0.875;  
				if (TrueGameSkill == SKILL_EXTREME) GravityEffectFactor = 0.900;  
				if (TrueGameSkill == SKILL_HORRIBLE) GravityEffectFactor = 0.925;  
				if (TrueGameSkill == SKILL_IMPOSSIBLE) GravityEffectFactor = 0.950;  
				if (TrueGameSkill >= SKILL_OMEGA) GravityEffectFactor = 0.980;
				
				LevelFactor = 512 - svictim.user_monsterlevel;
				GravityEffectFactor = GravityEffectFactor * LevelFactor / 512;
				
				FinalGravityFactor = 1.000 - GravityEffectFactor;
				if (GravityEffectFactor < 0.000) GravityEffectFactor = 0.000;
				if (GravityEffectFactor > 0.000)
				{
					PropertyValue = svictim.health;
					PropertyValue = PropertyValue * FinalGravityFactor;
				
					if (PropertyValue < 1) PropertyValue = 1;
					svictim.health = PropertyValue;
					svictim.A_StartSound("diabloistgravityend");
					svictim.A_SpawnItem("DiabloistGravityHPTargeter");
				}
				else
				{
					svictim.A_StartSound("diabloistgravitymiss");
				}
			}
			else
			{
				svictim.A_StartSound("diabloistgravitymiss");
			}
		}
		return -1;
	}

	States
	{
		Spawn:
			TNT1 A 0;
			TNT1 A 1 A_SeekerMissile(360,90,SMF_LOOK|SMF_PRECISE|SMF_CURSPEED,256,64);
			loop;
		Death:
			TNT1 A 0;
			stop;
	}
}

class BaseWandMissile : SingleDamageFastRipper
{
	bool wandmissleeraseproj;
	double properangle;
	double properpitch;
	int setpitch;
	int setpitch2;

	void A_WandMissileGuard()
	{
		double xpos;
		double zpos;
		setpitch2 = setpitch % 2;
		//Console.Printf("%d, %d", setpitch, setpitch2);
		if (!setpitch) { angle = properangle; pitch += properpitch; }
		setpitch++;
		if (setpitch > 1)
		{
			if (!(CountInv("AetheriusTimeFreezer",AAPTR_PLAYER1) || CountInv("AetheriusTimeFreezerMenu",AAPTR_PLAYER1) || isFrozen()))
			{
				double newradius = 8.0 * (1.0 + (0.2 * CallACS("MiscVarCheckDECORATE",10053)));
				double ahead = -184.0 - (newradius * 2); // 184 speed

				int maxgoes = ((-ahead)) / (newradius * 2);
				if (dvdsdebug_shieldactorghosts) Console.Printf("maxgoes: %d, newradius: %.2f", maxgoes, newradius);

				for (int i; i < maxgoes; i++)
				{
					ahead += (newradius * 2);
					xpos = 0 + (cos(pitch) * (0 + ahead));
					zpos = 4 - (sin(pitch) * (0 + ahead));
					A_SpawnItemEx("MageWandGuard",xpos,0,zpos,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH);
					if (dvdsdebug_shieldactorghosts) Console.Printf("i: %d, angle: %.8f, pitch: %.8f, ahead: %.8f, xpos: %.8f, zpos: %.8f", i, angle, pitch, ahead, xpos, zpos);
				}
			}
		}
	}
	
	override void PostBeginPlay()
	{
		properangle = (angle % 360);
		properpitch = pitch;
		if (dvdsdebug_shieldactorghosts) Console.Printf("(PBP) Angle: %.8f, Pitch: %.8f", properangle, properpitch);
		if (wandmissleeraseproj) 
		{
			A_StartSound("MageWandFireSpecial", 9, CHANF_DEFAULT, frandom(1.125,1.375));
		}
		Super.PostBeginPlay();
	}

	override void Die(Actor source, Actor inflictor, int dmgflags)
	{
		if (wandmissleeraseproj) A_WandMissileGuard();
		Super.Die(source, inflictor, dmgflags);
	}

	override void Tick()
	{
		if (wandmissleeraseproj) A_WandMissileGuard();
		Super.Tick();
	}
}

class BaseDiarisHolyArrow : SingleDamageFastRipper
{
	double properangle;
	double properpitch;
	int setpitch;
	int setpitch2;

	void A_ArrowGuard()
	{
		double xpos;
		double zpos;
		setpitch2 = setpitch % 2;

		if (!setpitch) { pitch += properpitch; angle = properangle; }
		setpitch++;
		if (setpitch > 1)
		{
			if (!(CountInv("AetheriusTimeFreezer",AAPTR_PLAYER1) || CountInv("AetheriusTimeFreezerMenu",AAPTR_PLAYER1) || isFrozen()))
			{
				double newradius = 16.0 * (1.0 + (0.2 * CallACS("MiscVarCheckDECORATE",10031)));
				int ahead = -320 - (newradius * 2);
				int maxgoes = ((-ahead)) / (newradius * 2);
				if (dvdsdebug_shieldactorghosts) Console.Printf("maxgoes: %d, newradius: %.2f", maxgoes, newradius);

				for (int i; i < maxgoes; i++)
				{
					ahead += (newradius * 2);
					xpos = 0 + (cos(pitch) * (0 + ahead));
					zpos = 4 - (sin(pitch) * (0 + ahead));
					A_SpawnItemEx("DiarisArrowGuard",xpos,0,zpos,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH); 
					if (dvdsdebug_shieldactorghosts) Console.Printf("i: %d, angle: %.8f, pitch: %.8f, ahead: %.8f, xpos: %.8f, zpos: %.8f", i, angle, pitch, ahead, xpos, zpos);
				}
			}
		}
	}

	override void PostBeginPlay()
	{
		properangle = (angle % 360);
		properpitch = pitch;
		if (dvdsdebug_shieldactorghosts) Console.Printf("(PBP) Angle: %.8f, Pitch: %.8f", properangle, properpitch);
		Super.PostBeginPlay();
	}

	override void Die(Actor source, Actor inflictor, int dmgflags)
	{
		A_ArrowGuard();
		Super.Die(source, inflictor, dmgflags);
	}

	override void Tick()
	{
		A_ArrowGuard();
		Super.Tick();
	}
}

class AetheriusDoomSpellZSC : AetheriusProjectileZSC
{
}

class AetheriusFastDoomSpellZSC : AetheriusFastProjectileZSC
{
}

class BFGBallBase : AetheriusProjectileZSC
{
	default
	{
		Radius 13;
		Height 8;
		Speed 25;
		DamageFunction 100;
		Projectile;
		+RANDOMIZE;
		RenderStyle "Add";
		Alpha 0.75;
		DeathSound "weapons/bfgx";
		Obituary "$OB_MPBFG_BOOM";
	}
	States
	{
		Spawn:
			BFS1 AB 4 Bright;
			Loop;
		Death:
			TNT1 A 0 
			{
				A_StartSound("weapons/bfgx",CHAN_7);
				A_Quake(1, 12, 0, 768, "");
				A_Quake(5, 12, 0, 512, "");
			}
			BFE1 AB 8 Bright;
			BFE1 C 8 Bright A_BFGSpray();
			BFE1 DEF 8 Bright;
			Stop;

		ShotDown:
			TNT1 A 0 
			{
				A_ScaleVelocity(0);
				A_StartSound("weapons/bfgx",CHAN_7, CHANF_DEFAULT, 0.5);
				A_Quake(1, 12, 0, 384, "");
				A_Quake(5, 12, 0, 256, "");
			}
			BFE1 ABCDEF 4 Bright;
			Stop;
	}
}
