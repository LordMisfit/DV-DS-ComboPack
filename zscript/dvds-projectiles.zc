// Base Projectile Class
class AetheriusBaseProjectileZSC : AetheriusBaseZSC
{
	mixin AtkTypeChecker;
	const MACELDLDMGMULTI = 5;

	// General
	const SKILL_VERY_EASY = 0;
	const SKILL_EASY = 1;
	const SKILL_NORMAL = 2;
	const SKILL_HARD = 3;
	const SKILL_VERY_HARD = 4;
	const SKILL_EXTREME = 5;
	const SKILL_HORRIBLE = 6;
	const SKILL_IMPOSSIBLE = 7;
	const SKILL_OMEGA = 8;

	bool IsACrisisAttack;
	int CrisisMultiplier;
	
	int user_basespellangle;
	int debugplayeratkinfo;
	
	int Fuse;
	int timesrippedoverall;
	int maxtimesrippedoverall;
	int FuseDone;
	int user_BaseDamage;
	int user_DamageError;
	int user_BaseExplodeDamage;
	int user_ExplodeDamageError;
	int user_Fuse;
	int user_fusemax;
	int user_seek;
	int user_seekmax1;
	int user_crisistimer;
	int user_misctimer1;
	int user_misctimer2;
	int user_misctimer3;
	int user_misctimer4;

	int user_randompain;
	int tic;
	int finaldamagedealt;
	int finaldamagedealt2;
	int MeleeImpactRad;
	int QuakeIntensity;
	int QuakeDuration;
	int QuakeTremRad;
	int VortStrength;
	int VortDistance;
	int VortDistance2;
	int VortDmgRad;
	int VortDmgRad2;
	actor OriginalActor;
	string OriginalActorType;
	bool REFLECTEDMONSTERPROJ;

	int InitRenderType;
	double InitAlpha;

	int BFGTracerAngle;
	int BFGTracerVAngle;
	int BFGTracerRange;
	int BFGTracers;
	int ishellcoreproj;
	
	// Perks
	int StamUpPerkLevel;
	int StamUpEXPerkLevel;
	int MagiUpPerkLevel;
	int MagiUpEXPerkLevel;
	int PlasmaAccuracyPerkLevel;
	int PlasmaAccuracyEXPerkLevel;
	int DemolitionsExpertPerkLevel;
	int DemolitionsExpertEXPerkLevel;
	int KarasawaAttunementPerkLevel;
	int KarasawaAttunementEXPerkLevel;
	int BFGAttunementPerkLevel;
	int BFGAttunementEXPerkLevel;
	int ArcheryMasteryPerkLevel;
	int ArcheryMasteryEXPerkLevel;
	int SoulMasteryPerkLevel;
	int SoulMasteryEXPerkLevel;
	int MartialArtsMastery;
	int MartialArtsMasteryEX;
	int BerserkerFit;
	int BerserkerFitEX;
	int WandMastPerkLvl;
	int WandMastEXPerkLvl;
	
	int DivineAvatarTimer;
	
	int PlayerLevel;
	int PlayerAGL;
	int PlayerDEF;
	int PlayerDFT;
	int PlayerSOR;
	int PlayerSTR;
	int PlayerTHE;

	int BaseSigilMaxHealth;
	int MaxHealthTrue;
	int ClassicDoomType;
	int SceptreActualLevel;
	int stamdamagefactor;
	int accudamagefactor;
	int CharacterClass;

	int ImpSouls;
	int DarkImpSouls;
	int CacodemonSouls;
	int CacolanternSouls;
	int AbaddonSouls;
	int KnightSouls;
	int BaronSouls;
	int BelphegorSouls;
	int BruiserSouls;
	int ArchonSouls;
	int PyroDemonSouls;
	int DiabloistSouls;
	int FlyingBalrogSouls;
	int HadesElementalSouls;
	int HadesOverlordSouls;
	
	private class<Inventory> APPackToken, APPackCheck, APPackCheck2, APPackCheck3, APPackCheck4, iDTech1Check, iDTech1Check2, iDTech1Check3, iDTech1Check4;
	
	property ishellcore: ishellcoreproj;
	
	override void BeginPlay()
	{
		super.BeginPlay();
	}
	
	override void PostBeginPlay()
	{
		AetheriusPlayerPawn playpawn;
		playpawn = AetheriusPlayerPawn(target);
		if (playpawn)
		{
			angle = playpawn.angle;
			pitch = playpawn.pitch;
		}

		/*
		STYLE_None (0)
		STYLE_Normal (1)
		STYLE_Fuzzy (2)
		STYLE_SoulTrans (3)
		STYLE_OptFuzzy (4)
		STYLE_Stencil (5)
		STYLE_Translucent (6)
		STYLE_Add (7)
		STYLE_Shaded (8)
		STYLE_TranslucentStencil (9)
		STYLE_Shadow (10)
		STYLE_Subtract (11)
		STYLE_AddStencil (12)
		STYLE_AddShaded (13)
		*/
		InitRenderType = GetRenderStyle();
		InitAlpha = Alpha;

		if (ishellcoreproj)
		{
			if (InitRenderType != 6) A_SetRenderStyle((InitAlpha*dvds_hellcoreprojalpha),6);
			else alpha = InitAlpha * dvds_hellcoreprojalpha;
			if (dvdsdebug_projectiledisplays) Console.Printf("%.8f", alpha);
		}

		if (dvdsdebug_projectiledisplays) Console.Printf("InitRenderType: %d (InitAlpha: %.8f) [Name: %s]", InitRenderType, InitAlpha, GetClassName());
		
		if (GetClassName() == "ReviveProj2")
		{
			if (target) { bFRIENDLY = target.BFRIENDLY; }
		}
		
		StamUpPerkLevel = CallACS("MiscVarCheckDECORATE",10005);
		StamUpEXPerkLevel = CallACS("MiscVarCheckDECORATE",10006);
		MagiUpPerkLevel = CallACS("MiscVarCheckDECORATE",10003);
		MagiUpEXPerkLevel = CallACS("MiscVarCheckDECORATE",10004);
		PlasmaAccuracyPerkLevel = CallACS("MiscVarCheckDECORATE",10023);
		PlasmaAccuracyEXPerkLevel = CallACS("MiscVarCheckDECORATE",10024);
		DemolitionsExpertPerkLevel = CallACS("MiscVarCheckDECORATE",10025);
		DemolitionsExpertEXPerkLevel = CallACS("MiscVarCheckDECORATE",10026);
		KarasawaAttunementPerkLevel = CallACS("MiscVarCheckDECORATE",10027);
		KarasawaAttunementEXPerkLevel = CallACS("MiscVarCheckDECORATE",10028);
		BFGAttunementPerkLevel = CallACS("MiscVarCheckDECORATE",10029);
		BFGAttunementEXPerkLevel = CallACS("MiscVarCheckDECORATE",10030);
		ArcheryMasteryPerkLevel = CallACS("MiscVarCheckDECORATE",10031);
		ArcheryMasteryEXPerkLevel = CallACS("MiscVarCheckDECORATE",10032);
		SoulMasteryPerkLevel = CallACS("MiscVarCheckDECORATE",10033);
		SoulMasteryEXPerkLevel = CallACS("MiscVarCheckDECORATE",10034);
		MartialArtsMastery = CallACS("MiscVarCheckDECORATE",10035);
		MartialArtsMasteryEX = CallACS("MiscVarCheckDECORATE",10036);
		BerserkerFit = CallACS("MiscVarCheckDECORATE",10051);
		BerserkerFitEX = CallACS("MiscVarCheckDECORATE",10052);
		WandMastPerkLvl = CallACS("MiscVarCheckDECORATE",10053);
		WandMastEXPerkLvl = CallACS("MiscVarCheckDECORATE",10054);
		
		ImpSouls = CallACS("MiscVarCheckDECORATE",96);
		DarkImpSouls = CallACS("MiscVarCheckDECORATE",97);
		CacodemonSouls = CallACS("MiscVarCheckDECORATE",98);
		CacolanternSouls = CallACS("MiscVarCheckDECORATE",99);
		AbaddonSouls = CallACS("MiscVarCheckDECORATE",100);
		KnightSouls = CallACS("MiscVarCheckDECORATE",101);
		BaronSouls = CallACS("MiscVarCheckDECORATE",102);
		BelphegorSouls = CallACS("MiscVarCheckDECORATE",103);
		BruiserSouls = CallACS("MiscVarCheckDECORATE",104);
		ArchonSouls = CallACS("MiscVarCheckDECORATE",105);
		PyroDemonSouls = CallACS("MiscVarCheckDECORATE",106);
		DiabloistSouls = CallACS("MiscVarCheckDECORATE",109);
		FlyingBalrogSouls = CallACS("MiscVarCheckDECORATE",110);
		HadesElementalSouls = CallACS("MiscVarCheckDECORATE",111);
		HadesOverlordSouls = CallACS("MiscVarCheckDECORATE",112);
		
		DivineAvatarTimer = CallACS("GetBuffTimer",7);
		
		PlayerLevel = CallACS("StatCheck",0);
		PlayerAGL = CallACS("MiscVarCheckDECORATE",31);
		PlayerDEF = CallACS("MiscVarCheckDECORATE",32);
		PlayerDFT = CallACS("MiscVarCheckDECORATE",33);
		PlayerSOR = CallACS("MiscVarCheckDECORATE",34);
		PlayerSTR = CallACS("MiscVarCheckDECORATE",35);
		PlayerTHE = CallACS("MiscVarCheckDECORATE",36);
		
		BaseSigilMaxHealth = CallACS("MiscVarCheckDECORATE",298);
		MaxHealthTrue = CallACS("StatCheck",1);
		ClassicDoomType = CallACS("OtherVarCheckDECORATE",7);
		SceptreActualLevel = CallACS("OtherVarCheckDECORATE",11);
		stamdamagefactor = CallACS("MiscVarCheckDECORATE",317);
		accudamagefactor = CallACS("MiscVarCheckDECORATE",318);
		CharacterClass = CallACS("CheckCharacterClass");
		
		CrisisMultiplier = CallACS("CrisisMultiplier");

		user_basespellangle = CallACS("CalculateSpellBaseAngles");

		Super.PostBeginPlay();
	}
	
	override void Tick()
	{
		if (GetAge() == 1)
		{
			if (ishellcoreproj)
			{
				if (InitRenderType != 6) A_SetRenderStyle((InitAlpha*dvds_hellcoreprojalpha),6);
				else alpha = InitAlpha * dvds_hellcoreprojalpha;
				if (dvdsdebug_projectiledisplays) Console.Printf("%.8f", alpha);
			}
		}
		//Console.Printf("pitch: %.8f", pitch);
		Super.Tick();
	}

	override bool CanCollideWith(Actor other, bool passive)
	{
		AetheriusPlayerPawn playpawn;
		AetheriusPlayerPawn playpawn2;
		AetheriusMonsterZSC DVDSActor;
		AetheriusMonsterZSC DVDSActor2;
		playpawn = AetheriusPlayerPawn(target);
		playpawn2 = AetheriusPlayerPawn(other);
		DVDSActor = AetheriusMonsterZSC(target);
		DVDSActor2 = AetheriusMonsterZSC(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer() > 0) return false;
					if (A_CheckFriendCollisionProjTypePlayer2() > 0) return false;
				}
			}
			else
			if (DVDSActor && DVDSActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1() > 0) return false;
				}
			}
			else 
			{
				if (GetClassName() == "HubbleBubbleSmall" || GetClassName() == "HubbleBubbleLarge") return false;
			}
		}
		// We don't really care about others making the check.
		return true;
	}

	int A_GetRagingSpiritDMG(int type = 0)
	{
		int lowcap = 1;
		int lowcaprand = 2;
		int damagedivider;
		
		int basedamage; 
		int extradamage;
		if (type == 0)
		{
			basedamage = (((3 + random(0,1)) * random(3,4)));
			extradamage = (((PlayerSOR + PlayerTHE) * 0.20) * random(4,8) / 8);
		}
		else
		{
			basedamage = (((6 + random(0,2)) * random(6,8)));
			extradamage = (((PlayerSOR + PlayerTHE) * 0.40) * random(8,16) / 8);
		}
		int damage = basedamage + extradamage;
		if (DivineAvatarTimer > 0) // Divine Avatar reduces the damage divide [aka even more damage is dealt]
		{
			if (type == 0)
			{
				damagedivider = random(5,6);
				lowcap = 6; 
				lowcaprand = 9; 
			}
			else
			{
				damagedivider = random(3,5);
				lowcap = 9; 
				lowcaprand = 12; 
			}
		}
		else
		{
			if (type == 0)
			{
				damagedivider = random(10,12);
				lowcap = 2; 
				lowcaprand = 3; 
			}
			else
			{
				damagedivider = random(6,10);
				lowcap = 3; 
				lowcaprand = 4; 
			}
		}
		
		int damagedivgain;
		if (type == 0)
		{
			if (CharacterClass == 0) damagedivgain = (PlayerLevel/56);
			if (CharacterClass == 1) damagedivgain = (PlayerLevel/48);
			if (CharacterClass == 2) damagedivgain = (PlayerLevel/40);
			if (CharacterClass == 8) damagedivgain = (PlayerLevel/52);
			if (CharacterClass == 9) damagedivgain = (PlayerLevel/44);
			damagedivgain = clamp(damagedivgain, damagedivgain, 4);
		}
		else
		{
			if (CharacterClass == 0) damagedivgain = (PlayerLevel/44);
			if (CharacterClass == 1) damagedivgain = (PlayerLevel/36);
			if (CharacterClass == 2) damagedivgain = (PlayerLevel/28);
			if (CharacterClass == 8) damagedivgain = (PlayerLevel/40);
			if (CharacterClass == 9) damagedivgain = (PlayerLevel/32);
			damagedivgain = clamp(damagedivgain, damagedivgain, 8);
		}
		
		damagedivider -= damagedivgain;
		damagedivider = clamp(damagedivider, 1, damagedivider);
		
		damage /= damagedivider;
		if (damage < lowcap) damage = random(lowcap,lowcaprand);
		int postdamage1 = damage;
		
		if (debugplayeratkinfo) Console.Printf("\cxRaging Spirit Damage (type: %d):\c- \cxFinalDamage: %d\c-, BaseDamage: %d, ExtraDamage: %d, DamageDivGain: %d, DamageDivider: %d, LowCap: %d, LowCapRand: %d, \cySeekTimer: %d / %d\c-, \cwFuse: %d / %d\c-", type, damage, basedamage, extradamage, damagedivgain, damagedivider, lowcap, lowcaprand, user_seek, user_seekmax1, user_fuse, user_fusemax);
		finaldamagedealt = damage;
		return damage;
	}
	
	void A_GetSigilDamage(int attacktype = 0, int radiustype = 0)
	{
		int damage, extradmg1, extradmg2, extradmg3, extradmg4, extradmg5, extradmg6, prefinaldmg, finaldmg;
		int rand1, rand2;
		int perkfactor = 10000;
		
		// SpectralLightningBaseNew's A_Explode [this affects the explosive-damage/radius of most Sigil attacks]
		if (attacktype == 0)
		{
			if (radiustype == 0) // Damage Calculation
			{
				damage = 32;
				extradmg1 = (PlayerDEF * 4) / 1;		// 400% of Defense		[1 pt[s] = 4 more unit[s] of damage]
				extradmg2 = (PlayerDFT * 3) / 8;		// 37.5% of Deftness	[8 pt[s] = 3 more unit[s] of damage]
				extradmg3 = (PlayerSOR * 7) / 4;		// 150% of Sorcery		[4 pt[s] = 6 more unit[s] of damage]
			}
			else // Radius Calculation
			{
				damage = 32; 
				extradmg1 = (PlayerDEF * 2) / 1;		// 200% of Defense		[1 pt[s] = 2 more unit[s] of radius]
				extradmg2 = (PlayerDFT * 3) / 16;	// 18.75% of Deftness	[16 pt[s] = 3 more unit[s] of radius]
				extradmg3 = (PlayerSOR * 3) / 4;		// 75% of Sorcery		[4 pt[s] = 3 more unit[s] of radius]
			}
		}
		// SpectralLightningBall1New
		if (attacktype == 1)
		{
			damage = 175 + random(-87,87); // 88 to 242
			extradmg1 = (PlayerDEF * 21) / 4;		// 525% of Defense		[4 pt[s] = 21 more unit[s] of damage]
			extradmg2 = (PlayerDFT * 21) / 32;	// 65.625% of Deftness	[32 pt[s] = 21 more unit[s] of damage]
			extradmg3 = (PlayerSOR * 63) / 16;	// 393.75% of Sorcery	[16 pt[s] = 63 more unit[s] of damage]
		}
		// SpectralLightningBall2New
		if (attacktype == 2)
		{
			damage = 50 + random(-25,25); // 25 to 75
			extradmg1 = (PlayerDEF * 9) / 6;		// 150% of Defense		[6 pt[s] = 9 more unit[s] of damage]
			extradmg2 = (PlayerDFT * 9) / 48;		// 18.75% of Deftness	[48 pt[s] = 9 more unit[s] of damage]
			extradmg3 = (PlayerSOR * 27) / 24;	// 112.5% of Sorcery	[24 pt[s] = 27 more unit[s] of damage]
		}
		// SpectralLightningV1New
		if (attacktype == 3)
		{
			damage = 300 + random(-150,150); // 150 to 450
			extradmg1 = (PlayerDEF * 9) / 1;		// 900% of Defense		[1 pt[s] = 9 more unit[s] of damage]
			extradmg2 = (PlayerDFT * 9) / 8;		// 112.5% of Deftness	[8 pt[s] = 9 more unit[s] of damage]
			extradmg3 = (PlayerSOR * 27) / 4;		// 675% of Sorcery		[4 pt[s] = 27 more unit[s] of damage]
		}
		// SpectralLightningV2New
		if (attacktype == 4)
		{
			damage = 150 + random(-75,75); // 75 to 225
			extradmg1 = (PlayerDEF * 9) / 2;		// 450% of Defense		[2 pt[s] = 9 more unit[s] of damage]
			extradmg2 = (PlayerDFT * 9) / 16;		// 56.25% of Deftness	[16 pt[s] = 9 more unit[s] of damage]
			extradmg3 = (PlayerSOR * 27) / 8;		// 337.5% of Sorcery	[8 pt[s] = 27 more unit[s] of damage]
		}
		// SpectralLightningH1New
		if (attacktype == 5)
		{
			damage = 175 + random(-87,87); // 88 to 242
			extradmg1 = (PlayerDEF * 21) / 4;		// 525% of Defense		[4 pt[s] = 21 more unit[s] of damage]
			extradmg2 = (PlayerDFT * 21) / 32;	// 65.625% of Deftness	[32 pt[s] = 21 more unit[s] of damage]
			extradmg3 = (PlayerSOR * 63) / 16;	// 393.75% of Sorcery	[16 pt[s] = 63 more unit[s] of damage]
		}
		// SpectralLightningH2New
		if (attacktype == 6)
		{
			damage = 50 + random(-25,25); // 25 to 75
			extradmg1 = (PlayerDEF * 9) / 6;		// 150% of Defense		[6 pt[s] = 9 more unit[s] of damage]
			extradmg2 = (PlayerDFT * 9) / 48;		// 18.75% of Deftness	[48 pt[s] = 9 more unit[s] of damage]
			extradmg3 = (PlayerSOR * 27) / 24;	// 112.5% of Sorcery	[24 pt[s] = 27 more unit[s] of damage]
		}
		// SpectralLightningH3New
		if (attacktype == 7)
		{
			damage = 25 + random(-12,12); // 13 to 37
			extradmg1 = (PlayerDEF * 9) / 12;		// 75% of Defense		[12 pt[s] = 9 more unit[s] of damage]
			extradmg2 = (PlayerDFT * 9) / 96;		// 9.375% of Deftness	[96 pt[s] = 9 more unit[s] of damage]
			extradmg3 = (PlayerSOR * 27) / 48;	// 56.25% of Sorcery	[48 pt[s] = 27 more unit[s] of damage]
		}
		// SpectralLightningBigBall1New
		if (attacktype == 8)
		{
			damage = 325 + random(-162,162); // 163 to 387
			extradmg1 = (PlayerDEF * 10) / 1;		// 1000% of Defense		[1 pt[s] = 10 more unit[s] of damage]
			extradmg2 = (PlayerDFT * 10) / 8;		// 125% of Deftness	[8 pt[s] = 210 more unit[s] of damage]
			extradmg3 = (PlayerSOR * 30) / 4;		// 750% of Sorcery		[4 pt[s] = 30 more unit[s] of damage]
		}
		
		// Final Calculations
		string AttackerName = "NONE";
		if (target) AttackerName = target.GetClassName();
		String nm, nn, no, np;
		if (radiustype == 0) // Direct Damage is randomized
		{
			if (AttackerName == "FloraBriscoletti") // if (IsPointerEqual(AAPTR_TARGET, AAPTR_PLAYER1) == TRUE) // AAPTR_TARGET - the being who fires the shot
			{
				if (debugplayeratkinfo) Console.Printf("Player Sigil Shot (%s), %d", AttackerName, attacktype);
				
				rand1 = (extradmg1 + extradmg2 + extradmg3 + extradmg4 + extradmg5 + extradmg6) * 7 / 10;
				rand2 = (extradmg1 + extradmg2 + extradmg3 + extradmg4 + extradmg5 + extradmg6) * 13 / 10;
				finaldmg = damage + random(rand1,rand2);
				
				if (stamdamagefactor == 1) finaldmg = finaldmg * 45 / 40; // +12.5% damage
				if (stamdamagefactor == 2) finaldmg = finaldmg * 51 / 40; // +27.5% damage
				if (stamdamagefactor == 3) finaldmg = finaldmg * 58 / 40; // +45% damage
				if (stamdamagefactor == 4) finaldmg = finaldmg * 66 / 40; // +65% damage
				if (stamdamagefactor == 5) finaldmg = finaldmg * 75 / 40; // +87.5% damage
				if (stamdamagefactor == 6) finaldmg = finaldmg * 85 / 40; // +112.5% damage
				if (stamdamagefactor == 7) finaldmg = finaldmg * 96 / 40; // +140% damage
				if (stamdamagefactor == 8) finaldmg = finaldmg * 108 / 40; // +170% damage
				if (stamdamagefactor == 9) finaldmg = finaldmg * 121 / 40; // +202.5% damage
				if (stamdamagefactor == 10) finaldmg = finaldmg * 135 / 40; // +237.5% damage
			
				if (accudamagefactor == 1) finaldmg = finaldmg * 85 / 80; // +6.25% damage
				if (accudamagefactor == 2) finaldmg = finaldmg * 91 / 80; // +13.75% damage
				if (accudamagefactor == 3) finaldmg = finaldmg * 98 / 80; // +22.5% damage
				if (accudamagefactor == 4) finaldmg = finaldmg * 106 / 80; // +32.5% damage
				if (accudamagefactor == 5) finaldmg = finaldmg * 115 / 80; // +43.75% damage
				if (accudamagefactor == 6) finaldmg = finaldmg * 125 / 80; // +56.25% damage
				if (accudamagefactor == 7) finaldmg = finaldmg * 136 / 80; // +70% damage
				if (accudamagefactor == 8) finaldmg = finaldmg * 148 / 80; // +85% damage
				if (accudamagefactor == 9) finaldmg = finaldmg * 161 / 80; // +101.25% damage
				if (accudamagefactor == 10) finaldmg = finaldmg * 175 / 80; // +118.75% damage
			
				int prefinaldmg = finaldmg;
				int hpextradmg = 100;
				int hpextradmgfactor = (MaxHealthTrue * 100);
				int hpextradmg2 = (hpextradmgfactor / BaseSigilMaxHealth) / 5;
				int hpextradmg3 = (hpextradmg + hpextradmg2);
				finaldmg = (finaldmg * hpextradmg3) / 100;
			
				if (debugplayeratkinfo) Console.Printf("\cy(%s)\c-: BaseDmg: %d, Extra1: %d, Extra2: %d, Extra3: %d, Extra4: %d, Extra5: %d, Extra6: %d, Original Max HP: %d, Current Max HP: %d, hpextradmg: %d, hpextradmgfactor: %d, hpextradmg2: %d, hpextradmg3: %d, Random: %d - %d, PerkFactor: %d, Total [Pre Max HP Check] %d, \cxTotal [Post Max HP Check]: %d\c-", 
																GetClassName(), damage, extradmg1, extradmg2, extradmg3, extradmg4, extradmg5, extradmg6, 
																BaseSigilMaxHealth, MaxHealthTrue, hpextradmg, hpextradmgfactor, hpextradmg2, hpextradmg3, 
																rand1, rand2, perkfactor, prefinaldmg, finaldmg);
			}
			else // If something that's NOT the player shoots it...
			{
				if (debugplayeratkinfo) Console.Printf("Non-Player/Spectre/Entity Sigil Shot (%s), %d", AttackerName, attacktype);

				prefinaldmg = damage;
				finaldmg = damage;
				if (attacktype != 0) finaldmg = finaldmg * random(1,4); // +STRIFEDAMAGE calculation
				nm = "EntityBossNew"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = finaldmg * 6 / 4;
				nm = "EntitySecondNew"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = finaldmg * 6 / 4;
				nm = "EntityAscended"; iDTech1Check = nm; if (AttackerName == iDTech1Check) finaldmg = finaldmg * 9 / 4;

				if (debugplayeratkinfo) Console.Printf("\cy(%s)\c-: BaseDmg: %d, PreTotal: %d, \cxTotal: %d\c-", GetClassName(), damage, prefinaldmg, finaldmg);
			}
		}
		else // Radius is NOT randomized
		{
			if (debugplayeratkinfo) Console.Printf("\cy(%s)\c-: BaseDmg: %d, Extra1: %d, Extra2: %d, Extra3: %d, Extra4: %d, Extra5: %d, Extra6: %d, PerkFactor: %d, \cxTotal: %d\c-", 
															GetClassName(), damage, extradmg1, extradmg2, extradmg3, extradmg4, extradmg5, extradmg6, perkfactor, finaldmg);
		}
		if (radiustype == 0) 
		{
			finaldamagedealt = finaldmg;
			if (debugplayeratkinfo) Console.Printf("\cxSigil Damage Total: %d (%d)\c-", finaldmg, finaldamagedealt);
		}
		if (radiustype == 1) 
		{
			finaldamagedealt2 = finaldmg;
			if (debugplayeratkinfo) Console.Printf("\cxSigil Radius Total: %d (%d)\c-", finaldmg, finaldamagedealt2);
		}
	}
	
	int A_GetMiscDMG(int type = 0)
	{
		int damage;
		string actorname = GetClassName();
		int miscdmgdebug = dvdsdebug_showmiscdmginformation;
		
		if (type == 1) // Minor Magic Missile [particle]
		{
			if (random(1,1000) > 667) damage = (1 + random(-1,0));
													else damage = (2 + random(-1,1));
		}
		
		if (type == 2) // Magic Missile [particle]
		{
			if (random(1,1000) > 667) damage = (6 + random(-1,2));
													else damage = (10 + random(-3,3));
		}
		
		if (type == 3) // Major Magic Missile [particle]
		{
			if (random(1,1000) > 667) damage = (12 + random(-3,4));
													else damage = (20 + random(-7,8));
		}
		
		if (type == 4) // Ultra Magic Missile [particle]
		{
			if (random(1,1000) > 667) damage = (24 + random(-13,14));
													else damage = (40 + random(-22,23));
		}
		
		if (miscdmgdebug) Console.Printf("MM Particle Dmg: (%s) %d", actorname, damage);
		finaldamagedealt = damage;
		return damage;
	}

	double A_GetBFGTracerAngle()
	{
		int result = 90;
		if (BFGAttunementPerkLevel >= 1) result += 22;
		if (BFGAttunementPerkLevel >= 2) result += 23;
		if (BFGAttunementEXPerkLevel >= 1) result += 33;
		if (BFGAttunementEXPerkLevel >= 2) result += 34;
		if (debugplayeratkinfo) Console.Printf("BFG Tracer Angle: %d (Perks: %d - %d)", result, BFGAttunementPerkLevel, BFGAttunementEXPerkLevel);

		BFGTracerAngle = result;
		return result;
	}
	
	double A_GetBFGTracerVAngle()
	{
		int result = 32;
		if (BFGAttunementPerkLevel >= 1) result += 8;
		if (BFGAttunementPerkLevel >= 2) result += 8;
		if (BFGAttunementEXPerkLevel >= 1) result += 12;
		if (BFGAttunementEXPerkLevel >= 2) result += 12;
		if (debugplayeratkinfo) Console.Printf("BFG Tracer Vertical Angle: %d (Perks: %d - %d)", result, BFGAttunementPerkLevel, BFGAttunementEXPerkLevel);

		BFGTracerVAngle = result;
		return result;
	}
	
	double A_GetBFGTracerDistance()
	{
		int result = 1024;
		if (BFGAttunementPerkLevel >= 1) result += 256;
		if (BFGAttunementPerkLevel >= 2) result += 256;
		if (BFGAttunementEXPerkLevel >= 1) result += 384;
		if (BFGAttunementEXPerkLevel >= 2) result += 384;
		if (debugplayeratkinfo) Console.Printf("BFG Tracer Range: %d (Perks: %d - %d)", result, BFGAttunementPerkLevel, BFGAttunementEXPerkLevel);

		BFGTracerRange = result;
		return result;
	}
	
	int A_GetBFGTracers()
	{
		int result = 40;
		if (BFGAttunementPerkLevel >= 1) result += 8;
		if (BFGAttunementPerkLevel >= 2) result += 8;
		if (BFGAttunementEXPerkLevel >= 1) result += 12;
		if (BFGAttunementEXPerkLevel >= 2) result += 12;
		if (debugplayeratkinfo) Console.Printf("BFG Tracers: %d (Perks: %d - %d)", result, BFGAttunementPerkLevel, BFGAttunementEXPerkLevel);

		BFGTracers = result;
		return result;
	}
	
	int A_MeleeImpactRadius(int attacktype)
	{
		double radius;
		double radiuserror;
		int debugmelee = dvdsdebug_showmeleeinformation;

		if (attacktype == 0) // Sceptre [Normal]
		{
			radius = ((80 + (5 * SceptreActualLevel)) + (PlayerSTR * (32 + SceptreActualLevel) / 32));
			radiuserror = frandom(0.375,0.625);
		}
		else
		if (attacktype == 1) // Sceptre [Aireal]
		{
			radius = ((80 + (5 * SceptreActualLevel)) + (PlayerSTR * (32 + SceptreActualLevel) / 32));
			radiuserror = frandom(0.375,0.625);
		}
		else
		if (attacktype == 2) // Sceptre [Spinning]
		{
			radius = ((20 + (1.25 * SceptreActualLevel)) + (PlayerSTR * (128 + SceptreActualLevel) / 128));
			radiuserror = frandom(0.375,0.625);
		}
		else
		if (attacktype == 3) // Punch [unarmed] (normal)
		{
			radius = 16 + (PlayerSTR / 8);
			radiuserror = frandom(0.84375,1.15625);
		}
		else
		if (attacktype == 4) // Punch [unarmed] (alt-fire)
		{
			radius = 24 + (PlayerSTR / 6);
			radiuserror = frandom(0.84375,1.15625);
		}
		else
		if (attacktype == 5) // Punch [w/ Gauntlets] (normal)
		{
			radius = 40 + (PlayerSTR / 3);
			radiuserror = frandom(0.84375,1.15625);
		}
		else
		if (attacktype == 6) // Punch [w/ Gauntlets] (alt-fire)
		{
			radius = 64 + (PlayerSTR / 2);
			radiuserror = frandom(0.84375,1.15625);
		}
		else
		if (attacktype == 7) // Thrust Kick
		{
			radius = 24 + (PlayerSTR / 4);
			radiuserror = frandom(0.84375,1.15625);
		}
		else
		if (attacktype == 8) // Spinning/Roundhouse Kick
		{
			radius = 36 + (PlayerSTR / 3);
			radiuserror = frandom(0.84375,1.15625);
		}
		radius *= radiuserror;
		int baseradius = radius;
		//****************
		if (debugmelee) Console.Printf("EXPLRadius [Base]: %d [RadError: %.8f]", radius, radiuserror);

		if (stamdamagefactor > 0) radius = (radius * (16 + (stamdamagefactor * 3.2)) / 16);
		if (debugmelee) Console.Printf("EXPLRadius [StaminaUpgrades]: %d", radius);

		if (CharacterClass == 0) radius = radius * 5 / 4;
		if (CharacterClass == 1) radius = radius * 9 / 8;
		if (debugmelee) Console.Printf("EXPLRadius [Class-Check]: %d", radius);
		
		if (DivineAvatarTimer > 0) 
		{
			radius = radius * 6 / 5; // 1.2x Radius [Divine Avatar]
			if (debugmelee) Console.Printf("EXPLRadius [Divine]: %d", radius);
		}

		if (CountInv("AetheriusPowerStrength",AAPTR_PLAYER1) > 0) 
		{
			radius = radius * 11 / 8; // 1.375x Radius [Berserk]
			if (debugmelee) Console.Printf("EXPLRadius [Berserk]: %d", radius);
		}
		
		if (ClassicDoomType == 5)
		{
			radius = radius * 6 / 5; // 1.2x in Doom64 due to scaling up of general maps, etc :V
			if (debugmelee) Console.Printf("EXPLRadius [Final]: %d [Base: %d]", radius, baseradius);
		}

		MeleeImpactRad = radius;
		return radius;
	}

	// Quake tremor effects
	int A_QuakeMeleeIntensity(int attacktype = 0)
	{
		int intensity;
		int debugmelee = dvdsdebug_showmeleeinformation;

		if (attacktype == 0) // Sceptre [Normal]
		{
			if (SceptreActualLevel <= 0) intensity = 1;
			if (SceptreActualLevel == 1) intensity = 1;
			if (SceptreActualLevel == 2) intensity = 1;
			if (SceptreActualLevel == 3) intensity = 1;
			if (SceptreActualLevel == 4) intensity = 1;
			if (SceptreActualLevel == 5) intensity = 1;
			if (SceptreActualLevel == 6) intensity = 1;
			if (SceptreActualLevel == 7) intensity = 1;
			if (SceptreActualLevel == 8) intensity = 2;
			if (SceptreActualLevel == 9) intensity = 2;
			if (SceptreActualLevel == 10) intensity = 2;
			if (SceptreActualLevel == 11) intensity = 2;
			if (SceptreActualLevel == 12) intensity = 2;
			if (SceptreActualLevel == 13) intensity = 2;
			if (SceptreActualLevel == 14) intensity = 2;
			if (SceptreActualLevel == 15) intensity = 2;
			if (SceptreActualLevel >= 16) intensity = 3;
			intensity = intensity + (PlayerSTR / 12);
		}
		else
		if (attacktype == 1) // Sceptre [Aireal]
		{
		}
		else
		if (attacktype == 2) // Sceptre [Spinning]
		{
			if (SceptreActualLevel <= 0) intensity = 0;
			if (SceptreActualLevel == 1) intensity = 0;
			if (SceptreActualLevel == 2) intensity = 0;
			if (SceptreActualLevel == 3) intensity = 0;
			if (SceptreActualLevel == 4) intensity = 0;
			if (SceptreActualLevel == 5) intensity = 0;
			if (SceptreActualLevel == 6) intensity = 0;
			if (SceptreActualLevel == 7) intensity = 0;
			if (SceptreActualLevel == 8) intensity = 0;
			if (SceptreActualLevel == 9) intensity = 0;
			if (SceptreActualLevel == 10) intensity = 0;
			if (SceptreActualLevel == 11) intensity = 0;
			if (SceptreActualLevel == 12) intensity = 0;
			if (SceptreActualLevel == 13) intensity = 0;
			if (SceptreActualLevel == 14) intensity = 0;
			if (SceptreActualLevel == 15) intensity = 0;
			if (SceptreActualLevel >= 16) intensity = 0;
			intensity = intensity + (PlayerSTR / 32);
		}
		else
		if (attacktype == 3) // Punch [unarmed] (normal)
		{
			intensity = 0 + (PlayerSTR / 32);
		}
		else
		if (attacktype == 4) // Punch [unarmed] (alt-fire/uppercut)
		{
			intensity = 0 + (PlayerSTR / 24);
		}
		else
		if (attacktype == 5) // Punch [w/ Gauntlets] (normal)
		{
			intensity = 1 + (PlayerSTR / 12);
		}
		else
		if (attacktype == 6) // Punch [w/ Gauntlets] (alt-fire)
		{
			intensity = 1 + (PlayerSTR / 8);
		}
		else
		if (attacktype == 7) // Thrust Kick
		{
			intensity = 0 + (PlayerSTR / 16);
		}
		else
		if (attacktype == 8) // Spinning/Roundhouse Kick
		{
			intensity = 0 + (PlayerSTR / 12);
		}

		int baseintensity = intensity;
		if (debugmelee) Console.Printf("Intensity [Base]: %d", intensity);

		if (stamdamagefactor > 0) intensity += (stamdamagefactor / 4);
		if (debugmelee) Console.Printf("Intensity [StaminaUpgrades]: %d", intensity);

		if (CharacterClass == 0) intensity = intensity * 3 / 2;
		if (CharacterClass == 1) intensity = intensity * 5 / 4;
		if (debugmelee) Console.Printf("Intensity [CharacterCheck]: %d", intensity);
		
		if (CountInv("AetheriusPowerStrength",AAPTR_PLAYER1) > 0)
		{
			if (intensity <= 0) intensity += 1; else intensity = (intensity * 3) / 2;
			if (debugmelee) Console.Printf("Intensity [Berserk]: %d", intensity);
		}
		
		if (debugmelee) Console.Printf("Intensity [Final]: %d, [Base: %d]", intensity, baseintensity);

		QuakeIntensity = intensity;
		return intensity;
	}
	
	int A_QuakeMeleeDuration(int attacktype = 0)
	{
		int duration;
		int debugmelee = dvdsdebug_showmeleeinformation;

		if (attacktype == 0) // Sceptre [Normal]
		{
			if (SceptreActualLevel <= 0) duration = 8;
			if (SceptreActualLevel == 1) duration = 8;
			if (SceptreActualLevel == 2) duration = 9;
			if (SceptreActualLevel == 3) duration = 9;
			if (SceptreActualLevel == 4) duration = 10;
			if (SceptreActualLevel == 5) duration = 10;
			if (SceptreActualLevel == 6) duration = 11;
			if (SceptreActualLevel == 7) duration = 11;
			if (SceptreActualLevel == 8) duration = 12;
			if (SceptreActualLevel == 9) duration = 12;
			if (SceptreActualLevel == 10) duration = 13;
			if (SceptreActualLevel == 11) duration = 13;
			if (SceptreActualLevel == 12) duration = 14;
			if (SceptreActualLevel == 13) duration = 14;
			if (SceptreActualLevel == 14) duration = 15;
			if (SceptreActualLevel == 15) duration = 15;
			if (SceptreActualLevel >= 16) duration = 16;
			duration = duration + (PlayerSTR / 10);
		}
		else
		if (attacktype == 1) // Sceptre [Aireal]
		{
		}
		else
		if (attacktype == 2) // Sceptre [Spinning]
		{
			if (SceptreActualLevel <= 0) duration = 2;
			if (SceptreActualLevel == 1) duration = 2;
			if (SceptreActualLevel == 2) duration = 2;
			if (SceptreActualLevel == 3) duration = 2;
			if (SceptreActualLevel == 4) duration = 2;
			if (SceptreActualLevel == 5) duration = 2;
			if (SceptreActualLevel == 6) duration = 2;
			if (SceptreActualLevel == 7) duration = 2;
			if (SceptreActualLevel == 8) duration = 3;
			if (SceptreActualLevel == 9) duration = 3;
			if (SceptreActualLevel == 10) duration = 3;
			if (SceptreActualLevel == 11) duration = 3;
			if (SceptreActualLevel == 12) duration = 3;
			if (SceptreActualLevel == 13) duration = 3;
			if (SceptreActualLevel == 14) duration = 3;
			if (SceptreActualLevel == 15) duration = 3;
			if (SceptreActualLevel >= 16) duration = 4;
			duration = duration + (PlayerSTR / 40);
		}
		else
		if (attacktype == 3) // Punch [unarmed] (normal)
		{
			duration = 2;
			duration = duration + (PlayerSTR / 40);
		}
		else
		if (attacktype == 4) // Punch [unarmed] (alt-fire)
		{
			duration = 3;
			duration = duration + (PlayerSTR / 28);
		}
		else
		if (attacktype == 5) // Punch [w/ Gauntlets] (normal)
		{
			duration = 6;
			duration = duration + (PlayerSTR / 14);
		}
		else
		if (attacktype == 6) // Punch [w/ Gauntlets] (alt-fire)
		{
			duration = 8;
			duration = duration + (PlayerSTR / 10);
		}
		else
		if (attacktype == 7) // Thrust Kick
		{
			duration = 4;
			duration = duration + (PlayerSTR / 20);
		}
		else
		if (attacktype == 8) // Spinning/Roundhouse Kick
		{
			duration = 6;
			duration = duration + (PlayerSTR / 14);
		}
		int baseduration = duration;
		
		if (stamdamagefactor > 0) duration = (duration * (16 + (stamdamagefactor * 3.2)) / 16);
		int stamduration = duration;
		if (CharacterClass == 0) duration = duration * 3 / 2;
		if (CharacterClass == 1) duration = duration * 5 / 4;
		int charduration = duration;
		
		if (DivineAvatarTimer > 0) duration = duration * 3 / 2;
		int dvavduration = duration;
		
		if (CountInv("AetheriusPowerStrength",AAPTR_PLAYER1) > 0) duration *= 4;
		int bersduration = duration;
		
		if (debugmelee) 
		{
			Console.Printf("Duration [Base]: %d, Duration [StaminaUpgrades]: %d, Duration [CharacterCheck]: %d, Duration [DivineAvatar]: %d, Duration [Berserk]: %d, \cxDuration [Final]: %d\c-", baseduration, stamduration, charduration, dvavduration, bersduration, duration);
		}
		
		QuakeDuration = duration;
		return duration;
	}
	
	int A_QuakeMeleeTremrad(int attacktype = 0)
	{
		int tremrad;
		int debugmelee = dvdsdebug_showmeleeinformation;

		if (attacktype == 0) // Sceptre [Normal]
		{
			if (SceptreActualLevel <= 0) tremrad = 512;
			if (SceptreActualLevel == 1) tremrad = 544;
			if (SceptreActualLevel == 2) tremrad = 576;
			if (SceptreActualLevel == 3) tremrad = 608;
			if (SceptreActualLevel == 4) tremrad = 640;
			if (SceptreActualLevel == 5) tremrad = 672;
			if (SceptreActualLevel == 6) tremrad = 704;
			if (SceptreActualLevel == 7) tremrad = 736;
			if (SceptreActualLevel == 8) tremrad = 768;
			if (SceptreActualLevel == 9) tremrad = 800;
			if (SceptreActualLevel == 10) tremrad = 832;
			if (SceptreActualLevel == 11) tremrad = 864;
			if (SceptreActualLevel == 12) tremrad = 896;
			if (SceptreActualLevel == 13) tremrad = 928;
			if (SceptreActualLevel == 14) tremrad = 960;
			if (SceptreActualLevel == 15) tremrad = 992;
			if (SceptreActualLevel >= 16) tremrad = 1024;
			tremrad = tremrad + (PlayerSTR * 4);
		}
		else
		if (attacktype == 1) // Sceptre [Aireal]
		{
		}
		else
		if (attacktype == 2) // Sceptre [Spinning]
		{
			if (SceptreActualLevel <= 0) tremrad = 128;
			if (SceptreActualLevel == 1) tremrad = 136;
			if (SceptreActualLevel == 2) tremrad = 144;
			if (SceptreActualLevel == 3) tremrad = 152;
			if (SceptreActualLevel == 4) tremrad = 160;
			if (SceptreActualLevel == 5) tremrad = 168;
			if (SceptreActualLevel == 6) tremrad = 176;
			if (SceptreActualLevel == 7) tremrad = 184;
			if (SceptreActualLevel == 8) tremrad = 192;
			if (SceptreActualLevel == 9) tremrad = 200;
			if (SceptreActualLevel == 10) tremrad = 208;
			if (SceptreActualLevel == 11) tremrad = 216;
			if (SceptreActualLevel == 12) tremrad = 224;
			if (SceptreActualLevel == 13) tremrad = 232;
			if (SceptreActualLevel == 14) tremrad = 240;
			if (SceptreActualLevel == 15) tremrad = 248;
			if (SceptreActualLevel >= 16) tremrad = 256;
			tremrad = tremrad + (PlayerSTR);
		}
		else
		if (attacktype == 3) // Punch [unarmed] (normal)
		{
			tremrad = 256;
			tremrad = tremrad + (PlayerSTR);
		}
		else
		if (attacktype == 4) // Punch [unarmed] (alt-fire)
		{
			tremrad = 320;
			tremrad = tremrad + ((PlayerSTR * 5) / 4);
		}
		else
		if (attacktype == 5) // Punch [w/ Gauntlets] (normal)
		{
			tremrad = 844;
			tremrad = tremrad + (PlayerSTR * 13 / 4);
		}
		else
		if (attacktype == 6) // Punch [w/ Gauntlets] (alt-fire)
		{
			tremrad = 1024;
			tremrad = tremrad + (PlayerSTR * 4);
		}
		else
		if (attacktype == 7) // Thrust Kick
		{
			tremrad = 384;
			tremrad = tremrad + ((PlayerSTR * 7) / 4);
		}
		else
		if (attacktype == 8) // Spinning/Roundhouse Kick
		{
			tremrad = 480;
			tremrad = tremrad + ((PlayerSTR * 13) / 4);
		}
		int basetremrad = tremrad;
		
		if (stamdamagefactor > 0) tremrad = (tremrad * (16 + (stamdamagefactor * 3.2)) / 16);
		int stamtremrad = tremrad;
		
		if (CharacterClass == 0) tremrad = tremrad * 3 / 2;
		if (CharacterClass == 1) tremrad = tremrad * 5 / 4;
		int chartremrad = tremrad;
		
		if (DivineAvatarTimer > 0) tremrad = tremrad * 3 / 2;
		int dvavtremrad = tremrad;
		
		if (CountInv("AetheriusPowerStrength",AAPTR_PLAYER1) > 0) tremrad *= 8;
		int berstremrad = tremrad;
		
		if (debugmelee)
		{
			Console.Printf("TremRad [Base]: %d, TremRad [StaminaUpgrades]: %d, TremRad [CharacterCheck]: %d, TremRad [DivineAvatar]: %d, TremRad [Berserk]: %d, \cxTremRad [Final]: %d\c-", basetremrad, stamtremrad, chartremrad, dvavtremrad, berstremrad, tremrad);
		}

		QuakeTremRad = tremrad;
		return tremrad;
	}
	
	int A_GetPoisonCloudDMG(int level)
	{
		int basedamage;
		int damage;
		int extradamage;
		int postdamage1;
		int postdamage2;
		int postdamage3;
		int lowcap;
		int lowcaprand;
		int poisonclouddebug;
		
		if (Level == 0) { basedamage = random(16,24); lowcap = 8; } // Minor
		if (Level == 1) { basedamage = random(36,48); lowcap = 16; } // Normal
		if (Level == 2) { basedamage = random(72,88); lowcap = 32; } // Major
		
		if (Level == 3) { basedamage = random(4,6); lowcap = 2; } // Minor [left]
		if (Level == 4) { basedamage = random(9,12); lowcap = 4; } // Normal [left]
		if (Level == 5) { basedamage = random(18,22); lowcap = 8; } // Major [left]
		lowcaprand = lowcap * 3 / 2;
		damage = basedamage;
		
		if (CharacterClass == 0) postdamage1 = damage * 32 / 10;
		if (CharacterClass == 1) postdamage1 = damage * 21 / 10;
		if (CharacterClass == 2) postdamage1 = damage * 10 / 10;
		if (CharacterClass == 8) postdamage1 = damage * 24 / 10;
		if (CharacterClass == 9) postdamage1 = damage * 16 / 10;
		damage = postdamage1;
		
		if (CharacterClass == 0) extradamage = damage * (PlayerSOR / 2) / 60;
		if (CharacterClass == 1) extradamage = damage * (PlayerSOR / 2) / 68;
		if (CharacterClass == 2) extradamage = damage * (PlayerSOR / 2) / 76;
		if (CharacterClass == 8) extradamage = damage * (PlayerSOR / 2) / 64;
		if (CharacterClass == 9) extradamage = damage * (PlayerSOR / 2) / 70;
		damage += extradamage;
		
		if (damage < lowcap) damage = random(lowcap,lowcaprand);
		
		string actorname = GetClassName();

		if (debugplayeratkinfo) Console.Printf("\Poison Cloud Damage (%s):\c- FinalDamage: %d, BaseDamage: %d, ExtraDamage: %d, PostDamage1: %d, LowCap: %d, LowCapRand: %d", actorname, damage, basedamage, extradamage, postdamage1, lowcap, lowcaprand);
		finaldamagedealt = damage;

		if (debugplayeratkinfo) Console.Printf("PoisonCloudDmg: %d", finaldamagedealt);
		return damage;
	}
	
	int A_GetPSNCloudVortexSTR(int CloudSize = 0, int radtype = 0)
	{
		int poisonclouddebug;

		int VortexStrength = 256;
		int Extra;
		if (CloudSize == 0) // Minor
		{
			if (radtype == 1)
			{
				VortexStrength = 64; // 25%
				Extra = (PlayerSOR * 1) + (PlayerTHE / 2);
			}
			else
			{
				VortexStrength = 256; // 100%
				Extra = (PlayerSOR * 4) + (PlayerTHE * 2);
			}
		}
		
		if (CloudSize == 1) // Normal
		{
			if (radtype == 1)
			{
				VortexStrength = 128; // 50%
				Extra = (PlayerSOR * 2) + (PlayerTHE * 1);
			}
			else
			{
				VortexStrength = 512; // 200%
				Extra = (PlayerSOR * 8) + (PlayerTHE * 4);
			}
		}
		
		if (CloudSize == 2) // Major
		{
			if (radtype == 1)
			{
				VortexStrength = 256; // 100%
				Extra = (PlayerSOR * 4) + (PlayerTHE * 2);
			}
			else
			{
				VortexStrength = 1024; // 400%
				Extra = (PlayerSOR * 16) + (PlayerTHE * 8);
			}
		}
		
		VortexStrength += Extra;
		VortexStrength *= -1;

		VortStrength = VortexStrength;
		if (debugplayeratkinfo) Console.Printf("VortStrength: %d", VortStrength);
		return VortexStrength;
	}
	
	int A_GetPSNCloudVortexDIST(int CloudSize = 0, int type = 0, int particlespawn = 0, int pulltype = 0)
	{
		int poisonclouddebug;

		int VortexDistance = 80;
		int VortexDistance2;
		int Extra;
		if (CloudSize == 0) // Minor
		{
			if (pulltype == 1)
			{
				VortexDistance = 240; // 300%
				Extra = (PlayerSOR * 8) + (PlayerTHE * 4);
			}
			else
			{
				VortexDistance = 80; // 100%
				Extra = (PlayerSOR * 2) + (PlayerTHE * 1);
			}
		}
		
		if (CloudSize == 1) // Normal
		{
			if (pulltype == 1)
			{
				VortexDistance = 420; // 525%
				Extra = (PlayerSOR * 14) + (PlayerTHE * 28);
			}
			else
			{
				VortexDistance = 140; // 175%
				Extra = (PlayerSOR * 4) + (PlayerTHE * 2);
			}
		}
		
		if (CloudSize == 2) // Major
		{
			if (pulltype == 1)
			{
				VortexDistance = 780; // 975%
				Extra = (PlayerSOR * 26) + (PlayerTHE * 52);
			}
			else
			{
				VortexDistance = 260; // 325%
				Extra = (PlayerSOR * 8) + (PlayerTHE * 4);
			}
		}
		
		VortexDistance += Extra;
		if (type == 1) VortexDistance2 = VortexDistance / 2;
		
		if (particlespawn == 1) // Fixed Value
		{
			VortexDistance *= 1.0;
			//VortexDistance = VortexDistance>>16;
		}
		
		VortDistance = VortexDistance;
		VortDistance2 = VortexDistance2;
		if (debugplayeratkinfo) Console.Printf("VortDistance: %d, VortDistance2: %d, Type: %d, ParticleSpawn: %d", VortDistance, VortDistance2, type, particlespawn);
		if (type == 1) return VortexDistance2;
							else return VortexDistance;
	} 
	
	int A_GetPSNCloudDmgRad(int CloudSize = 0, int Type = 0)
	{
		int poisonclouddebug;

		int DmgRad = 40;
		int Extra;
		if (CloudSize == 0) // Minor
		{
			DmgRad = 40;
			Extra = (PlayerSOR * 1) + (PlayerTHE / 2);
		}
		if (CloudSize == 1) // Normal
		{
			DmgRad = 64;
			Extra = (PlayerSOR * 8 / 5) + (PlayerTHE * 4 / 5);
		}
		if (CloudSize == 2) // Major
		{
			DmgRad = 88;
			Extra = (PlayerSOR * 11 / 5) + (PlayerTHE * 7 / 5);
		}
		
		int DmgSmlRad = DmgRad / 4;

		if (Type == 0) 
		{
			if (debugplayeratkinfo) Console.Printf("VortDmgRad: %d", VortDmgRad);
			return DmgRad;
		}
		else 
		{
			if (debugplayeratkinfo) Console.Printf("VortDmgRad2: %d", VortDmgRad2);
			return DmgSmlRad;
		}
	}
	
	void A_GenerateCrisisParticle(int flags = SXF_TRANSFERTRANSLATION | SXF_NOCHECKPOSITION | SXF_TRANSFERSPRITEFRAME | SXF_TRANSFERSCALE | SXF_TRANSFERALPHA)
	{
		double basespread = 0.64;
		double rangexspread = 1.28;
		double rangeyspread = 1.28;
		double rangezspread = 1.28;
		A_SpawnItemEx("AetheriusCrisisParticle", 0,0,0, 0,basespread,0, 0, flags);
		A_SpawnItemEx("AetheriusCrisisParticle", 0,0,0, 0,-basespread,0, 0, flags);
		A_SpawnItemEx("AetheriusCrisisParticle", 0,0,0, 0,0,basespread, 0, flags);
		A_SpawnItemEx("AetheriusCrisisParticle", 0,0,0, 0,0,-basespread, 0, flags);

		A_SpawnItemEx("AetheriusCrisisParticle", 0,0,0, frandom(-rangexspread,rangexspread),frandom(-rangeyspread,rangeyspread),frandom(-rangezspread,rangezspread), 0, flags);
		A_SpawnItemEx("AetheriusCrisisParticle", 0,0,0, frandom(-rangexspread,rangexspread),frandom(-rangeyspread,rangeyspread),frandom(-rangezspread,rangezspread), 0, flags);
		if (random(1,4) <= 3) A_SpawnItemEx("AetheriusCrisisParticle", 0,0,0, frandom(-rangexspread,rangexspread),frandom(-rangeyspread,rangeyspread),frandom(-rangezspread,rangezspread), 0, flags);
		if (random(1,4) <= 3) A_SpawnItemEx("AetheriusCrisisParticle", 0,0,0, frandom(-rangexspread,rangexspread),frandom(-rangeyspread,rangeyspread),frandom(-rangezspread,rangezspread), 0, flags);
		if (random(1,4) <= 2) A_SpawnItemEx("AetheriusCrisisParticle", 0,0,0, frandom(-rangexspread,rangexspread),frandom(-rangeyspread,rangeyspread),frandom(-rangezspread,rangezspread), 0, flags);
		if (random(1,4) <= 2) A_SpawnItemEx("AetheriusCrisisParticle", 0,0,0, frandom(-rangexspread,rangexspread),frandom(-rangeyspread,rangeyspread),frandom(-rangezspread,rangezspread), 0, flags);
		if (random(1,4) <= 1) A_SpawnItemEx("AetheriusCrisisParticle", 0,0,0, frandom(-rangexspread,rangexspread),frandom(-rangeyspread,rangeyspread),frandom(-rangezspread,rangezspread), 0, flags);
		if (random(1,4) <= 1) A_SpawnItemEx("AetheriusCrisisParticle", 0,0,0, frandom(-rangexspread,rangexspread),frandom(-rangeyspread,rangeyspread),frandom(-rangezspread,rangezspread), 0, flags);
	}
	
}

// Base Normal Projectile Class
class AetheriusProjectileZSC : AetheriusBaseProjectileZSC
{
	const SHARDSPAWN_LEFT	= 1;
	const SHARDSPAWN_RIGHT	= 2;
	const SHARDSPAWN_UP		= 4;
	const SHARDSPAWN_DOWN	= 8;

	int user_noseektimer, user_seektimer; // For Magic Missiles
	int projtouchedshieldactor;
	
	override void BeginPlay()
	{
		if (GetClassName() == "MMMParticle") { A_GetMiscDMG(1); }
		if (GetClassName() == "NMMParticle") { A_GetMiscDMG(2); }
		if (GetClassName() == "BMMParticle") { A_GetMiscDMG(3); }
		if (GetClassName() == "UMMParticle") { A_GetMiscDMG(4); }

		if (GetClassName() == "RagingSpirit") { A_GetRagingSpiritDMG(0); }
		if (GetClassName() == "RagingSpirit2") { A_GetRagingSpiritDMG(1); }

		if (GetClassName() == "SpectralLightningBall1New") { A_GetSigilDamage(1); }
		if (GetClassName() == "SpectralLightningBall2New") { A_GetSigilDamage(2); }
		if (GetClassName() == "SpectralLightningBigV1New") { A_GetSigilDamage(3); }
		if (GetClassName() == "SpectralLightningBigBall1New") { A_GetSigilDamage(8); }
		if (GetClassName() == "SpectralLightningV1New") { A_GetSigilDamage(3); }
		if (GetClassName() == "SpectralLightningV2New") { A_GetSigilDamage(4); }
		if (GetClassName() == "SpectralLightningH1New") { A_GetSigilDamage(5); }
		if (GetClassName() == "SpectralLightningH2New") { A_GetSigilDamage(6); }
		if (GetClassName() == "SpectralLightningH3New") { A_GetSigilDamage(7); }
		if (GetClassName() == "NNSigilLightningBigV") { A_GetSigilDamage(3); }
		
		if (GetClassName() == "STGrenade" || GetClassName() == "STGrenadeNoAOE" || 
				GetClassName() == "RocketPlayer" || GetClassName() == "RocketPlayerNoAOE" || 
				GetClassName() == "RocketPlayerSeeking" || GetClassName() == "RocketPlayerSeekingNoAOE") { finaldamagedealt = A_GetPlayerAttackDamage(8,0); }

		if (GetClassName() == "RepeaterPuffPlayer") { finaldamagedealt = A_GetPlayerAttackDamage(10,0); }
		if (GetClassName() == "PlasmaBallPlayer") { finaldamagedealt = A_GetPlayerAttackDamage(11,0); }
		if (GetClassName() == "PlasmaBall1Player") { finaldamagedealt = A_GetPlayerAttackDamage(12,0); }
		if (GetClassName() == "PlasmaBall2Player") { finaldamagedealt = A_GetPlayerAttackDamage(13,0); }
		if (GetClassName() == "BFGBallPlayer") { finaldamagedealt = A_GetPlayerAttackDamage(14,0); }

		if (GetClassName() == "KsawBoltPlayer") { finaldamagedealt = A_GetPlayerAttackDamage(16,0); }

		if (GetClassName() == "DiarisHolyArrow") { finaldamagedealt = A_GetPlayerAttackDamage(18,0); }
		if (GetClassName() == "DiarisHolyArrow2XDmg") { finaldamagedealt = A_GetPlayerAttackDamage(19,0); }
		if (GetClassName() == "DiarisHolyArrow3XDmg") { finaldamagedealt = A_GetPlayerAttackDamage(20,0); }
		if (GetClassName() == "CrossbowFX1New") { finaldamagedealt = A_GetPlayerAttackDamage(21,0); }
		if (GetClassName() == "CrossbowFX2New") { finaldamagedealt = A_GetPlayerAttackDamage(22,0); }
		if (GetClassName() == "CrossbowFX3New") { finaldamagedealt = A_GetPlayerAttackDamage(23,0); }
		if (GetClassName() == "RipperNew") { finaldamagedealt = A_GetPlayerAttackDamage(24,0); }
		if (GetClassName() == "ElectricBoltNew") { finaldamagedealt = A_GetPlayerAttackDamage(25,0); }
		if (GetClassName() == "PoisonBoltNew") { finaldamagedealt = A_GetPlayerAttackDamage(26,0); }

		if (GetClassName() == "BlasterFX1New") { finaldamagedealt = A_GetPlayerAttackDamage(28,0); }

		if (GetClassName() == "HornRodFX1New") { finaldamagedealt = A_GetPlayerAttackDamage(31,0); }
		if (GetClassName() == "HornRodFX2New") { finaldamagedealt = A_GetPlayerAttackDamage(32,0); }
		if (GetClassName() == "PhoenixFX1New" || GetClassName() == "PhoenixFX1NoAOE") { finaldamagedealt = A_GetPlayerAttackDamage(33,0); }
		if (GetClassName() == "PhoenixFX2New") { finaldamagedealt = A_GetPlayerAttackDamage(34,0); }
		if (GetClassName() == "MaceFX1New") { finaldamagedealt = A_GetPlayerAttackDamage(35,0); }
		if (GetClassName() == "MaceFX2New") { finaldamagedealt = A_GetPlayerAttackDamage(36,0); }
		if (GetClassName() == "MaceFX3New") { finaldamagedealt = A_GetPlayerAttackDamage(37,0); }
		if (GetClassName() == "MaceFX4New") { finaldamagedealt = A_GetPlayerAttackDamage(38,0); }
		if (GetClassName() == "Sorcerer2FX1Player") { finaldamagedealt = A_GetPlayerAttackDamage(39,0); }
		if (GetClassName() == "Sorcerer2FX3") { finaldamagedealt = A_GetPlayerAttackDamage(40,0); }
		if (GetClassName() == "GoldWandFX1New") { finaldamagedealt = A_GetPlayerAttackDamage(41,0); }
		if (GetClassName() == "GoldWandFX2New") { finaldamagedealt = A_GetPlayerAttackDamage(42,0); }
		if (GetClassName() == "RainPillarNew") { finaldamagedealt = A_GetPlayerAttackDamage(43,0); }
		if (GetClassName() == "MageWandMissileNew") { finaldamagedealt = A_GetPlayerAttackDamage(44,0); }
		if (GetClassName() == "MageWandMissile2New") { finaldamagedealt = A_GetPlayerAttackDamage(45,0); }
		if (GetClassName() == "HubbleBubbleSmall") { finaldamagedealt = A_GetPlayerAttackDamage(46,0); }
		if (GetClassName() == "HubbleBubbleLarge") { finaldamagedealt = A_GetPlayerAttackDamage(47,0); }
		
		if (GetClassName() == "EvilWarriorShieldBall" || GetClassName() == "EvilWarriorShieldBallCrisis") { finaldamagedealt = A_GetPlayerAttackDamage(52,0); }

		if (GetClassName() == "AChristinaBouncingShotWeak") { finaldamagedealt = A_GetPlayerAttackDamage(55,0); }
		if (GetClassName() == "AChristinaBouncingShotStage1" || GetClassName() == "AChristinaBouncingShotStage2" || GetClassName() == "AChristinaBouncingShotStage3") { finaldamagedealt = A_GetPlayerAttackDamage(56,0); }
		if (GetClassName() == "CStaffMissileNew") { finaldamagedealt = A_GetPlayerAttackDamage(57,0); }

		if (GetClassName() == "PoisonNeedleProj" || GetClassName() == "PoisonNeedleProjExtra") { finaldamagedealt = A_GetPlayerAttackDamage(59,0); }
		if (GetClassName() == "RockBombShardProj") { finaldamagedealt = A_GetPlayerAttackDamage(69,0); }
		if (GetClassName() == "UnmakerLaser" || GetClassName() == "UnmakerLaserCrisis") { finaldamagedealt = A_GetPlayerAttackDamage(71,0); }

		Super.BeginPlay(); // KEEP THIS HERE ELSE OTHER FUNCTIONS RELATED TO BeginPlay() BREAK :V
	}
	override void PostBeginPlay()
	{
		if (GetClassName() == "MMMParticle") { A_GetMiscDMG(1); }
		if (GetClassName() == "NMMParticle") { A_GetMiscDMG(2); }
		if (GetClassName() == "BMMParticle") { A_GetMiscDMG(3); }
		if (GetClassName() == "UMMParticle") { A_GetMiscDMG(4); }
		
		if (GetClassName() == "RagingSpirit") { A_GetRagingSpiritDMG(0); }
		if (GetClassName() == "RagingSpirit2") { A_GetRagingSpiritDMG(1); }

		if (GetClassName() == "SpectralLightningBall1New") { A_GetSigilDamage(1); }
		if (GetClassName() == "SpectralLightningBall2New") { A_GetSigilDamage(2); }
		if (GetClassName() == "SpectralLightningBigV1New") { A_GetSigilDamage(3); }
		if (GetClassName() == "SpectralLightningBigBall1New") { A_GetSigilDamage(8); }
		if (GetClassName() == "SpectralLightningV1New") { A_GetSigilDamage(3); }
		if (GetClassName() == "SpectralLightningV2New") { A_GetSigilDamage(4); }
		if (GetClassName() == "SpectralLightningH1New") { A_GetSigilDamage(5); }
		if (GetClassName() == "SpectralLightningH2New") { A_GetSigilDamage(6); }
		if (GetClassName() == "SpectralLightningH3New") { A_GetSigilDamage(7); }
		if (GetClassName() == "NNSigilLightningBigV") { A_GetSigilDamage(3); }

		if (GetClassName() == "STGrenade" || GetClassName() == "STGrenadeNoAOE" || 
				GetClassName() == "RocketPlayer" || GetClassName() == "RocketPlayerNoAOE" || 
				GetClassName() == "RocketPlayerSeeking" || GetClassName() == "RocketPlayerSeekingNoAOE") { finaldamagedealt = A_GetPlayerAttackDamage(8,0); }

		if (GetClassName() == "RepeaterPuffPlayer") { finaldamagedealt = A_GetPlayerAttackDamage(10,0); }
		if (GetClassName() == "PlasmaBallPlayer") { finaldamagedealt = A_GetPlayerAttackDamage(11,0); }
		if (GetClassName() == "PlasmaBall1Player") { finaldamagedealt = A_GetPlayerAttackDamage(12,0); }
		if (GetClassName() == "PlasmaBall2Player") { finaldamagedealt = A_GetPlayerAttackDamage(13,0); }
		if (GetClassName() == "BFGBallPlayer") { finaldamagedealt = A_GetPlayerAttackDamage(14,0); }

		if (GetClassName() == "KsawBoltPlayer") { finaldamagedealt = A_GetPlayerAttackDamage(16,0); }

		if (GetClassName() == "DiarisHolyArrow") { finaldamagedealt = A_GetPlayerAttackDamage(18,0); }
		if (GetClassName() == "DiarisHolyArrow2XDmg") { finaldamagedealt = A_GetPlayerAttackDamage(19,0); }
		if (GetClassName() == "DiarisHolyArrow3XDmg") { finaldamagedealt = A_GetPlayerAttackDamage(20,0); }
		if (GetClassName() == "CrossbowFX1New") { finaldamagedealt = A_GetPlayerAttackDamage(21,0); }
		if (GetClassName() == "CrossbowFX2New") { finaldamagedealt = A_GetPlayerAttackDamage(22,0); }
		if (GetClassName() == "CrossbowFX3New") { finaldamagedealt = A_GetPlayerAttackDamage(23,0); }
		if (GetClassName() == "RipperNew") { finaldamagedealt = A_GetPlayerAttackDamage(24,0); }
		if (GetClassName() == "ElectricBoltNew") { finaldamagedealt = A_GetPlayerAttackDamage(25,0); }
		if (GetClassName() == "PoisonBoltNew") { finaldamagedealt = A_GetPlayerAttackDamage(26,0); }

		if (GetClassName() == "BlasterFX1New") { finaldamagedealt = A_GetPlayerAttackDamage(28,0); }

		if (GetClassName() == "HornRodFX1New") { finaldamagedealt = A_GetPlayerAttackDamage(31,0); }
		if (GetClassName() == "HornRodFX2New") { finaldamagedealt = A_GetPlayerAttackDamage(32,0); }
		if (GetClassName() == "PhoenixFX1New" || GetClassName() == "PhoenixFX1NoAOE") { finaldamagedealt = A_GetPlayerAttackDamage(33,0); }
		if (GetClassName() == "PhoenixFX2New") { finaldamagedealt = A_GetPlayerAttackDamage(34,0); }
		if (GetClassName() == "MaceFX1New") { finaldamagedealt = A_GetPlayerAttackDamage(35,0); }
		if (GetClassName() == "MaceFX2New") { finaldamagedealt = A_GetPlayerAttackDamage(36,0); }
		if (GetClassName() == "MaceFX3New") { finaldamagedealt = A_GetPlayerAttackDamage(37,0); }
		if (GetClassName() == "MaceFX4New") { finaldamagedealt = A_GetPlayerAttackDamage(38,0); }
		if (GetClassName() == "Sorcerer2FX1Player") { finaldamagedealt = A_GetPlayerAttackDamage(39,0); }
		if (GetClassName() == "Sorcerer2FX3") { finaldamagedealt = A_GetPlayerAttackDamage(40,0); }
		if (GetClassName() == "GoldWandFX1New") { finaldamagedealt = A_GetPlayerAttackDamage(41,0); }
		if (GetClassName() == "GoldWandFX2New") { finaldamagedealt = A_GetPlayerAttackDamage(42,0); }
		if (GetClassName() == "RainPillarNew") { finaldamagedealt = A_GetPlayerAttackDamage(43,0); }
		if (GetClassName() == "MageWandMissileNew") { finaldamagedealt = A_GetPlayerAttackDamage(44,0); }
		if (GetClassName() == "MageWandMissile2New") { finaldamagedealt = A_GetPlayerAttackDamage(45,0); }
		if (GetClassName() == "HubbleBubbleSmall") { finaldamagedealt = A_GetPlayerAttackDamage(46,0); }
		if (GetClassName() == "HubbleBubbleLarge") { finaldamagedealt = A_GetPlayerAttackDamage(47,0); }
		
		if (GetClassName() == "EvilWarriorShieldBall" || GetClassName() == "EvilWarriorShieldBallCrisis") { finaldamagedealt = A_GetPlayerAttackDamage(52,0); }

		if (GetClassName() == "AChristinaBouncingShotWeak") { finaldamagedealt = A_GetPlayerAttackDamage(55,0); }
		if (GetClassName() == "AChristinaBouncingShotStage1" || GetClassName() == "AChristinaBouncingShotStage2" || GetClassName() == "AChristinaBouncingShotStage3") { finaldamagedealt = A_GetPlayerAttackDamage(56,0); }
		if (GetClassName() == "CStaffMissileNew") { finaldamagedealt = A_GetPlayerAttackDamage(57,0); }

		if (GetClassName() == "PoisonNeedleProj" || GetClassName() == "PoisonNeedleProjExtra") { finaldamagedealt = A_GetPlayerAttackDamage(59,0); }
		if (GetClassName() == "SonicNail") { finaldamagedealt = A_GetPlayerAttackDamage(63,0); }
		if (GetClassName() == "UnmakerLaser" || GetClassName() == "UnmakerLaserCrisis") { finaldamagedealt = A_GetPlayerAttackDamage(71,0); }
		
		// Sometimes allow THRUGHOST projectiles to HIT ghosts when Wand Mastery is increased
		int RandCall = random(1,256);
		if (GetClassName() == "CrossbowFX3New")
		{
			if (WandMastPerkLvl <= 0 && RandCall <= 2) bTHRUGHOST = 0;
			else if (WandMastPerkLvl == 1 && RandCall <= 12) bTHRUGHOST = 0;
			else if (WandMastPerkLvl == 2 && RandCall <= 24) bTHRUGHOST = 0;
			else if (WandMastPerkLvl == 3 && RandCall <= 38) bTHRUGHOST = 0;
			else if (WandMastPerkLvl == 4 && RandCall <= 54) bTHRUGHOST = 0;
			else if (WandMastPerkLvl >= 5 && RandCall <= 72) bTHRUGHOST = 0;
		}
		if (GetClassName() == "PhoenixFX1New" || GetClassName() == "PhoenixFX1NoAOE")
		{
			if (WandMastPerkLvl <= 0 && RandCall <= 8) bTHRUGHOST = 0;
			else if (WandMastPerkLvl == 1 && RandCall <= 20) bTHRUGHOST = 0;
			else if (WandMastPerkLvl == 2 && RandCall <= 36) bTHRUGHOST = 0;
			else if (WandMastPerkLvl == 3 && RandCall <= 56) bTHRUGHOST = 0;
			else if (WandMastPerkLvl == 4 && RandCall <= 80) bTHRUGHOST = 0;
			else if (WandMastPerkLvl >= 5 && RandCall <= 108) bTHRUGHOST = 0;
		}
		if (GetClassName() == "MaceFX1New" || GetClassName() == "MaceFX2New" || GetClassName() == "MaceFX3New" || GetClassName() == "MaceFX4New")
		{
			if (WandMastPerkLvl <= 0 && RandCall <= 1) bTHRUGHOST = 0;
			else if (WandMastPerkLvl == 1 && RandCall <= 8) bTHRUGHOST = 0;
			else if (WandMastPerkLvl == 2 && RandCall <= 18) bTHRUGHOST = 0;
			else if (WandMastPerkLvl == 3 && RandCall <= 30) bTHRUGHOST = 0;
			else if (WandMastPerkLvl == 4 && RandCall <= 44) bTHRUGHOST = 0;
			else if (WandMastPerkLvl >= 5 && RandCall <= 60) bTHRUGHOST = 0;
		}

		float basexvel = vel.x;
		float baseyvel = vel.y;
		float basezvel = vel.z;
		float speedmulti;
		float speedmulti2;
		float speedmulti3;
		float monsprojboostfactor = dvds_monsprojboostfactor;
		float mprojectilevelmulti = dvds_mprojectilevelmulti;
		float pprojectilevelmulti = dvds_pprojectilevelmulti;
		let IsPlayer = PlayerPawn(target);
		if (!IsPlayer) A_ScaleVelocity(mprojectilevelmulti); else A_ScaleVelocity(pprojectilevelmulti);

		let IsAMonster = AetheriusMonsterZSC(target);
		if (IsAMonster)
		{
			OriginalActor = IsAMonster;
			OriginalActorType = IsAMonster.GetClassName();

			if (dvds_monsterprojectileboost == 1)
			{
				if (IsAMonster.user_basespeed <= 0) speedmulti = 1.0; else speedmulti = IsAMonster.speed / IsAMonster.user_basespeed;
				speedmulti = clamp(speedmulti, 1.0, speedmulti);
				speedmulti2 = ((speedmulti - 1.0) * monsprojboostfactor) + 1.0;
				A_ScaleVelocity(speedmulti2);
			}

			speedmulti3 = 1.0;
			let IsAMonsterLegendary = IsAMonster.user_legendaryevolved;
			if (IsAMonsterLegendary) speedmulti3 = dvds_LD_projspeedmulti;
			A_ScaleVelocity(speedmulti3);
		}

		float newxvel = vel.x;
		float newyvel = vel.y;
		float newzvel = vel.z;

		if (dvdsdebug_showmiscdmginformation && IsAMonster) Console.Printf("PROJECTILE SPEED: \czXVelOld\c-: \cz%.4f\c-, \cyXVelNew\c-: \cy%.4f\c-, \czYVelOld\c-: \cz%.4f\c-, \cyYVelNew\c-: \cy%.4f\c-, \czZVelOld\c-: \cz%.4f\c-, \cyZVelNew\c-: \cy%.4f\c-, \cxSpeedMulti\c-: \cx%.4f\c-, \cwSpeedMulti2\c-: \cw%.4f\c-, \cvSpeedMulti3\c-: \cv%.4f\c-", basexvel, newxvel, baseyvel, newyvel, basezvel, newzvel, speedmulti, speedmulti2, speedmulti3);
		
		Super.PostBeginPlay(); // KEEP THIS HERE ELSE OTHER FUNCTIONS RELATED TO PostBeginPlay() BREAK :V
	}
	override void Tick()
	{
		if (GetClassName() == "MinorMagicMissile" || GetClassName() == "MinorMagicMissileSeek") user_fusemax = (140 + (PlayerSOR * 0.05) + (PlayerTHE * 0.05));
		if (GetClassName() == "MagicMissile" || GetClassName() == "MagicMissileSeek") user_fusemax = (210 + (PlayerSOR * 0.075) + (PlayerTHE * 0.075));
		if (GetClassName() == "MajorMagicMissile" || GetClassName() == "MajorMagicMissileSeek") user_fusemax = (280 + (PlayerSOR * 0.10) + (PlayerTHE * 0.10));
		if (GetClassName() == "UltraMagicMissile" || GetClassName() == "UltraMagicMissileSeek") user_fusemax = (420 + (PlayerSOR * 0.15) + (PlayerTHE * 0.15));
		
		if (user_fusemax > 0)
		{
			if (user_Fuse < user_fusemax) 
			{
				if (!(CountInv("AetheriusTimeFreezer",AAPTR_PLAYER1) || CountInv("AetheriusTimeFreezerMenu",AAPTR_PLAYER1) || isFrozen() || InStateSequence(curstate,ResolveState("Death")))) user_Fuse++;
			}
			if (user_Fuse == user_fusemax) 
			{ 
				if (!(CountInv("AetheriusTimeFreezer",AAPTR_PLAYER1) || CountInv("AetheriusTimeFreezerMenu",AAPTR_PLAYER1) || isFrozen() || InStateSequence(curstate,ResolveState("Death")))) SetStateLabel("Death");
			}
			if (user_Fuse > user_fusemax) 
			{ 
				if (!(CountInv("AetheriusTimeFreezer",AAPTR_PLAYER1) || CountInv("AetheriusTimeFreezerMenu",AAPTR_PLAYER1) || isFrozen())) user_Fuse /= 4; 
			}
		}
		
		if (OriginalActor != null) 
		{ 
			if (target != OriginalActor && target == AetheriusPlayerPawn(target)) REFLECTEDMONSTERPROJ = true; 
		}
		
		if (REFLECTEDMONSTERPROJ && bDONTREFLECT == false) 
		{
			//Console.Printf("REFLECTEDMONSTERPROJ (%d)", level.time);
			bDONTREFLECT = true;
		}
		
		debugplayeratkinfo = dvdsdebug_showplayeratkinformation;
		Super.Tick();
	}

	void A_PlayCrisisAtkSound ()
	{
		A_StartSound("crisisattack", 9, CHANF_DEFAULT, frandom(1.25,1.5), ATTN_NORM, frandom(0.75,1.25));
		A_StartSound("crisisattack2", 10, CHANF_DEFAULT, frandom(1.25,1.5), ATTN_NORM, frandom(0.75,1.25));
	}
	
	
	void A_DVDSFire(double spawnheight = 0, double firelength = 24)
	{
		Actor dest = tracer;
		if (!dest || !target) return;
				
		// don't move it if the vile lost sight
		if (!target.CheckSight (dest, 0) ) return;

		SetOrigin(dest.Vec3Angle(firelength, dest.angle, (dest.height/2)), true);
	}

	// A_SeekerMissile that will clear its tracer pointer if the tracer is friendly.
	void A_NFSeekerMissile(int threshold, int maxturnangle, int flags = 0, int chance = 50, int distance = 10)
	{
		if ((flags & SMF_LOOK) && !tracer)
		{
			// Searches for a monster to seek, but only if it's not friendly.
			tracer = RoughMonsterSearch(distance, onlyseekable: true);
			if (tracer && target && !target.isHostile(tracer)) tracer = null;
		}
		A_SeekerMissile(threshold,maxturnangle,flags & ~SMF_LOOK,chance,distance);
	}	
	
	// A_SeekerMissile that will clear its tracer pointer if the tracer is hostile and only try to seek friendlies [for healing projectiles, etc].
	void A_FOSeekerMissile(int threshold, int maxturnangle, int flags = 0, int chance = 50, int distance = 10)
	{
		if ((flags & SMF_LOOK) && !tracer)
		{
			// Searches for a monster to seek, but only if it's friendly.
			tracer = RoughMonsterSearch(distance, onlyseekable: true);
			if (tracer && target && !target.isFriend(tracer)) tracer = null;
		}
		A_SeekerMissile(threshold,maxturnangle,flags & ~SMF_LOOK,chance,distance);
	}	
	
	void A_HealSeek(int maxtime = 2)
	{
		user_seektimer += 1;
		if (user_seektimer >= maxtime) 
		{
			A_FOSeekerMissile(90,90,SMF_LOOK|SMF_PRECISE|SMF_CURSPEED,256,64); 
			user_seektimer = 0;
		}
		//A_LogInt(user_seektimer);
	}
	
	/**
	 * Sets the calling actor's Angle and Pitch to match its velocity vector, so that it is looking in exactly the same direction as it is traveling. Used by A_SelectSeekTarget.
	 */
	action void A_FaceVel()
	{
		// Math from https://forum.zdoom.org/viewtopic.php?f=15&t=59726&hilit=PitchTo#p1044007
		let dir = Vel.Unit();
		Angle = atan2(dir.Y, dir.X);
		Pitch = -asin(dir.Z);
	}
	
	/**
	 * Selects a target for A_SeekerMissile or A_SuperSeekerMissile, based on where the source of this projectile (that is, the target pointer) is currently aiming.
	 *
	 * This should be called when a projectile is first fired. If this is used, then in subsequent calls to A_SuperSeekerMissile, the retarget parameter should be the opposite of the value returned by this method. Example:
	 *
	 *	private bool specificTarget;
	 *	states {
	 *		Spawn:
	 *			TNT1 A 0 nodelay { invoker.specificTarget = A_SelectSeekTargetByShooterAim(); }
	 *			MISL A 1 A_SuperSeekerMissile(1, 1, retarget: !specificTarget);
	 *			wait;
	 *	}
	 *
	 * @param seekEnemies Whether to seek actors hostile to the source of this projectile. Defaults to true.
	 * @param seekFriends Whether to seek actors friendly to the source of this projectile. Defaults to false.
	 * @param range How far out to look. Defaults to PLAYERMISSILERANGE, the maximum range of player hitscans.
	 * @return true if a valid target was selected; false otherwise.
	 */
	action bool A_SelectSeekTargetByShooterAim(bool seekEnemies = true, bool seekFriends = false, double range = PLAYERMISSILERANGE)
	{
		if (!target)
		{
			Console.Printf("\cg%s.A_SelectSeekTargetByShooterAim called, but this actor's target field is null!", GetClassName());
			return false;
		}
		
		FLineTraceData result;
		if (LineTrace(target.Angle, range, target.Pitch, data: result) && result.HitActor)
		{
			let a = result.HitActor;
			if 
			(
				a != target &&
				a.bShootable && !a.bDormant && !a.bNeverTarget &&
				(
					(!seekEnemies && !seekFriends) ||
					(seekEnemies && target.isHostile(a)) ||
					(seekFriends && target.isFriend(a))
				)
			)
			{
				tracer = a;
				return true;
			}
		}
		
		return false;
	}
	
	/**
	 * Selects a target for A_SeekerMissile or A_SuperSeekerMissile.
	 *
	 * @param seekEnemies Whether to seek actors hostile to the source of this projectile. Defaults to true.
	 * @param seekFriends Whether to seek actors friendly to the source of this projectile. Defaults to false.
	 * @param lookDistance How far to look all around for a target.
	 */
	action void A_SelectSeekTarget(bool seekEnemies = true, bool seekFriends = false, double lookDistance = MISSILERANGE)
	{
		invoker.SuperSeekerMissileLastTargetingAttempt = gametic;
		
		A_FaceVel();
		
		Vector2 bestAimCorrection = (180, 180);
		Actor bestTarget = null;
		
		// Searches for a monster to seek.
		for (let i = BlockThingsIterator.Create(invoker, lookDistance); i.Next();)
		if 
		(
			i.thing != target &&
			i.thing.bShootable && !i.thing.bDormant && !i.thing.bNeverTarget &&
			(
				(!seekEnemies && !seekFriends) || !target ||
				(seekEnemies && target.isHostile(i.thing)) ||
				(seekFriends && target.isFriend(i.thing))
			)
		)
		{
			let dirTo = Vec3To(i.thing).Unit();
			let aimCorrection = (
				abs(atan2(dirTo.y, dirTo.x) - Angle),
				abs(asin(dirTo.z) - Pitch)
			);
			
			// Save the visibility check for last. It's quite expensive.
			if (aimCorrection.Length() < bestAimCorrection.Length() && IsVisible(i.thing, true))
			{
				bestAimCorrection = aimCorrection;
				bestTarget = i.thing;
			}
		}
		
		if (bestTarget)
			tracer = bestTarget;
	}
	
	/**
	 * The most recent tic when A_SelectSeekTarget was executed.
	 *
	 * This is used to limit how often A_SuperSeekerMissile searches for a seek target when it doesn't already have one. Searching for a seek target is an expensive operation, so it shouldn't be done on every tic.
	 *
	 * The longer ago the last attempt was made, the more probable it is that another attempt will be made on this tic, reaching 100% probability after 32 tics. In other words, seeker missile targeting will happen every 16 tics on average, but it's randomized so that not all seeker missiles in flight will try targeting on the same tic.
	 */
	private int SuperSeekerMissileLastTargetingAttempt;
	
	/**
	 * Custom replacement for A_SeekerMissile that actually works correctly, and without the quirks. Always behaves as though SMF_PRECISE and SMF_CURSPEED were given.
	 *
	 * @param maxYaw How far the missile is allowed to yaw in one tic.
	 * @param maxPitch How far the missile is allowed to pitch in one tic.
	 * @param retarget If true, the missile will occasionally look for new, better targets even if it already has one.
	 * @param seekEnemies Whether to seek actors hostile to the source of this projectile. Defaults to true.
	 * @param seekFriends Whether to seek actors friendly to the source of this projectile. Defaults to false.
	 * @param lookDistance How far the missile will look for targets. If  0, missile will not look for targets at all, and will simply seek the current tracer (if any).
	 */
	action void A_SuperSeekerMissile(double maxYaw, double maxPitch, bool retarget = true, bool seekEnemies = true, bool seekFriends = false, double lookDistance = MISSILERANGE, int faceFlags = 0)
	{
		if 
		(
			tracer && (
				!invoker.CanSeek(tracer) ||
				!tracer.bShootable ||
				(!(random() & 31) && !IsVisible(tracer, true))
			)
		)
			tracer = null; // Forget about targets that are no longer valid.
		
		if 
		(
			(!tracer && (
				// If A_SelectSeekTarget has never run before, then definitely run it.
				(invoker.SuperSeekerMissileLastTargetingAttempt == 0) ||
				// Otherwise, avoid running it on every tic; it's an expensive operation.
				(gametic - invoker.SuperSeekerMissileLastTargetingAttempt) > (random() & 31)
			)) ||
			(retarget && !(random() & 127))
		)
			A_SelectSeekTarget(seekEnemies: seekEnemies, seekFriends: seekFriends, lookDistance: lookDistance);
		
		if (tracer)
		{
			let curSpeed = Vel.Length();
			let curAngles = (Angle, Pitch);
			A_FaceTracer(maxYaw, maxPitch, flags: faceFlags);
			Vel3DFromAngle(curSpeed, Angle, Pitch);
		}
	}
	
	action void A_DrunkMissile(double maxYaw, double maxPitch)
	{
		let curSpeed = Vel.Length();
		Angle = Normalize180(Angle + random(-maxYaw, maxYaw));
		Pitch = clamp(Pitch + random(-maxPitch, maxPitch), -90., 90.);
		Vel3DFromAngle(curSpeed, Angle, Pitch);
	}

	void A_CharmSeek(int maxtime = 2)
	{
		user_seektimer += 1;
		if (user_seektimer >= maxtime) 
		{
			A_NFSeekerMissile(90,90,SMF_LOOK|SMF_PRECISE|SMF_CURSPEED,256,64); 
			user_seektimer = 0;
		}
		//A_LogInt(user_seektimer);
	}

	void A_MMSeek(int maxtime = 2)
	{
		user_seektimer += 1;
		if (user_seektimer >= maxtime) 
		{
			A_NFSeekerMissile(22,44,SMF_LOOK|SMF_PRECISE|SMF_CURSPEED,128,16);
			user_seektimer = 0;
		}
		//A_LogInt(user_seektimer);
	}

	void A_HealCheckNoSeekTimer(int maxchance = 16, int healseek = 2)
	{
		user_noseektimer -= 1;
		if (random(1,maxchance) == 1) 
		{ 
			A_HealSeek(healseek);
			user_noseektimer += 1;
		}
		//A_LogInt(user_noseektimer);
	}
	
	void A_CharmCheckNoSeekTimer(int maxchance = 16, int charmseek = 2)
	{
		user_noseektimer -= 1;
		if (random(1,maxchance) == 1) 
		{ 
			A_CharmSeek(charmseek);
			user_noseektimer += 1;
		}
		//A_LogInt(user_noseektimer);
	}
	
	void A_CharmSeekerClearBounce(int timerset = 6, int randomset = 0)
	{
		if (user_noseektimer <= 0) 
		{ 
			user_noseektimer = timerset + random(-randomset,randomset);
			A_RearrangePointers(AAPTR_DEFAULT, AAPTR_DEFAULT, AAPTR_NULL);
			//A_LogInt(user_noseektimer);
		} 
	}
	
	void A_MMCheckNoSeekTimer(int maxchance = 16, int mmseek = 2)
	{
		user_noseektimer -= 1;
		if (random(1,maxchance) == 1) 
		{ 
			A_MMSeek(mmseek);
			user_noseektimer += 1;
		}
		//A_LogInt(user_noseektimer);
	}

	void A_MMSeekerClearBounce(int timerset = 6, int randomset = 0)
	{
		if (user_noseektimer <= 0) 
		{ 
			user_noseektimer = timerset + random(-randomset,randomset);
			A_RearrangePointers(AAPTR_DEFAULT, AAPTR_DEFAULT, AAPTR_NULL);
			//A_LogInt(user_noseektimer);
		} 
	}

	// Customizable version of A_Tracer, allowing you to change the puff and smoke, as well as the tracing angle.
	void A_CustomTracer(double traceang = 16.875, string pufftype = "BulletPuff", string smoketype = "RevenantTracerSmoke")
	{
		// killough 1/18/98: this is why some missiles do not have smoke
		// and some do. Also, internal demos start at random gametics, thus
		// the bug in which revenants cause internal demos to go out of sync.
		//
		// killough 3/6/98: fix revenant internal demo bug by subtracting
		// levelstarttic from gametic:
		//
		// [RH] level.time is always 0-based, so nothing special to do here.

		if (level.time & 3)	return;
	
		// spawn a puff of smoke behind the rocket
		SpawnPuff (pufftype, pos, angle, angle, 3);
		Actor smoke = Spawn ("RevenantTracerSmoke", Vec3Offset(-Vel.X, -Vel.Y, 0.), ALLOW_REPLACE);
	
		if (smoke != null)
		{
			smoke.Vel.Z = 1.;
			smoke.tics -= random[Tracer](0, 3);
			if (smoke.tics < 1)
				smoke.tics = 1;
		}

		// The rest of this function was identical with Strife's version, except for the angle being used.
		A_Tracer2(traceang);
	}

	void A_FlameDie()
	{
		bNoGravity = true;
		Vel.Z = random[FlameDie]() & 3;
	}

	void A_WraithFX2()
	{
		for (int i = 2; i; --i)
		{
			Actor mo = Spawn ("WraithFX2", Pos, ALLOW_REPLACE);
			if (mo)
			{
				double newangle = random[WraithFX2]() * (360 / 1024.f);
				if (random[WraithFX2]() >= 128)
				{
					newangle = -newangle;
				}
				newangle += angle;
				mo.Vel.X = ((random[WraithFX2]() / 512.) + 1) * cos(newangle);
				mo.Vel.Y = ((random[WraithFX2]() / 512.) + 1) * sin(newangle);
				mo.Vel.Z = 0;
				mo.target = self;
				mo.Floorclip = 10;
			}
		}
	}

	// D'Sparil Bolt
	void A_BlueSpark ()
	{
		for (int i = 0; i < 2; i++)
		{
			Actor mo = Spawn("Sorcerer2FXSpark", pos, ALLOW_REPLACE);
			if (mo != null)
			{
				mo.Vel.X = Random2[BlueSpark]() / 128.;
				mo.Vel.Y = Random2[BlueSpark]() / 128.;
				mo.Vel.Z = 1. + Random[BlueSpark]() / 256.;
			}
		}
	}

	void A_GenWizard ()
	{
		Actor mo = Spawn("Wizard", pos, ALLOW_REPLACE);
		if (mo != null)
		{
			mo.AddZ(-mo.Default.Height / 2, false);
			if (!mo.TestMobjLocation ())
			{ // Didn't fit
				mo.ClearCounters();
				mo.Destroy ();
			}
			else
			{ // [RH] Make the new wizards inherit D'Sparil's target
				mo.CopyFriendliness (self.target, true);

				Vel = (0,0,0);
				SetStateLabel('Death');
				bMissile = false;
				mo.master = target;
				SpawnTeleportFog(pos, false, true);
			}
		}
	}

	// Red Axe [Heretic]
	void A_DripBlood (string missiletype = "Blood")
	{
		double xo = random2[DripBlood]() / 32.0;
		double yo = random2[DripBlood]() / 32.0;
		Actor mo = Spawn (missiletype, Vec3Offset(xo, yo, 0.), ALLOW_REPLACE);
		if (mo != null)
		{
			mo.Vel.X = random2[DripBlood]() / 64.0;
			mo.Vel.Y = random2[DripBlood]() / 64.0;
			mo.Gravity = 1./8;
		}
	}

	// Ice Ball Splits
	void A_LichIceImpact(string missiletype = "HeadFX2")
	{
		for (int i = 0; i < 8; i++)
		{
			Actor shard = Spawn(missiletype, Pos, ALLOW_REPLACE);
			if (shard != null)
			{
				shard.target = target;
				shard.angle = i*45.;
				shard.VelFromAngle();
				shard.Vel.Z = -.6;
				shard.CheckMissileSpawn (radius);
			}
		}
	}

	// Lich Fire Pillar
	void A_LichFireGrow ()
	{
		health--;
		AddZ(9.);
		if (health == 0)
		{
			RestoreDamage();
			SetStateLabel("NoGrow");
		}
	}

	// Ice Shards
	void A_ShedShard()
	{
		int spawndir = special1;
		int spermcount = special2;
		Actor mo;

		if (spermcount <= 0)
		{
			return;				// No sperm left
		}
		special2 = 0;
		spermcount--;

		// every so many calls, spawn a new missile in its set directions
		if (spawndir & SHARDSPAWN_LEFT)
		{
			mo = SpawnMissileAngleZSpeed(pos.z, "FrostMissile", angle + 5, 0, (20. + 2 * spermcount), target);
			if (mo)
			{
				mo.special1 = SHARDSPAWN_LEFT;
				mo.special2 = spermcount;
				mo.Vel.Z = Vel.Z;
				mo.args[0] = (spermcount==3)?2:0;
			}
		}
		if (spawndir & SHARDSPAWN_RIGHT)
		{
			mo = SpawnMissileAngleZSpeed(pos.z, "FrostMissile",	angle - 5, 0, (20. + 2 * spermcount), target);
			if (mo)
			{
				mo.special1 = SHARDSPAWN_RIGHT;
				mo.special2 = spermcount;
				mo.Vel.Z = Vel.Z;
				mo.args[0] = (spermcount==3)?2:0;
			}
		}
		if (spawndir & SHARDSPAWN_UP)
		{
			mo = SpawnMissileAngleZSpeed(pos.z + 8., "FrostMissile", angle, 0, (15. + 2 * spermcount), target);
			if (mo)
			{
				mo.Vel.Z = Vel.Z;
				if (spermcount & 1)			// Every other reproduction
					mo.special1 = SHARDSPAWN_UP | SHARDSPAWN_LEFT | SHARDSPAWN_RIGHT;
				else
					mo.special1 = SHARDSPAWN_UP;
				mo.special2 = spermcount;
				mo.args[0] = (spermcount==3)?2:0;
			}
		}
		if (spawndir & SHARDSPAWN_DOWN)
		{
			mo = SpawnMissileAngleZSpeed(pos.z - 4., "FrostMissile", angle, 0, (15. + 2 * spermcount), target);
			if (mo)
			{
				mo.Vel.Z = Vel.Z;
				if (spermcount & 1)			// Every other reproduction
					mo.special1 = SHARDSPAWN_DOWN | SHARDSPAWN_LEFT | SHARDSPAWN_RIGHT;
				else
					mo.special1 = SHARDSPAWN_DOWN;
				mo.special2 = spermcount;
				mo.target = target;
				mo.args[0] = (spermcount==3)?2:0;
			}
		}
	}

	// Wendigo/IceLich Balls
	void A_IceGuyMissileExplode(string missiletype = "IceGuyFX2", int numshots = 8, double pitch = -0.3)
	{
		for (int i = 0; i < numshots; i++)
		{
			Actor mo = SpawnMissileAngleZ (pos.z+3, missiletype, i*45., pitch);
			if (mo)
			{
				mo.target = target;
			}
		}
	}	

	//
	void A_MntrFloorFire(string missiletype = "MinotaurFX3")
	{
		SetZ(floorz);
		double x = Random2[MntrFloorFire]() / 64.;
		double y = Random2[MntrFloorFire]() / 64.;
		
		Actor mo = Spawn(missiletype, Vec2OffsetZ(x, y, floorz), ALLOW_REPLACE);
		if (mo != null)
		{
			mo.target = target;
			mo.Vel.X = MinVel; // Force block checking
			mo.CheckMissileSpawn (radius);
		}
	}

	// Quietus Sword Flames
	void A_FSwordFlames()
	{
		for (int i = random[FSwordFlame](1, 4); i; i--)
		{
			double xo = (random[FSwordFlame]() - 128) / 16.;
			double yo = (random[FSwordFlame]() - 128) / 16.;
			double zo = (random[FSwordFlame]() - 128) / 8.;
			Spawn ("FSwordFlame", Vec3Offset(xo, yo, zo), ALLOW_REPLACE);
		}
	}

	// DragonFX2
	void A_DragonFX2(string missiletype = "DragonExplosion")
	{
		int delay = 16+(random[DragonFX2]()>>3);
		for (int i = random[DragonFX2](1, 4); i; i--)
		{
			double xo = (random[DragonFX2]() - 128) / 4.;
			double yo = (random[DragonFX2]() - 128) / 4.;
			double zo = (random[DragonFX2]() - 128) / 16.;

			Actor mo = Spawn (missiletype, Vec3Offset(xo, yo, zo), ALLOW_REPLACE);
			if (mo)
			{
				mo.tics = delay + (random[DragonFX2](0, 3)) * i*2;
				mo.target = target;
			}
		}
	}

	// WraithVerge
	void A_CHolyAttack2(string missiletype = "HolySpirit", int spiritnums = 4, int spiritfuse = 105, int spiritfusedm = 85)
	{
		for (int j = 0; j < spiritnums; j++)
		{
			Actor mo = Spawn(missiletype, Pos, ALLOW_REPLACE);
			if (!mo)
			{
				continue;
			}
			switch (j)
			{
				// float bob index

				case 0:
					mo.WeaveIndexZ = random[HolyAtk2]() & 7; // upper-left
					break;
				case 1:
					mo.WeaveIndexZ = 32 + (random[HolyAtk2]() & 7); // upper-right
					break;
				case 2:
					mo.WeaveIndexXY = 32 + (random[HolyAtk2]() & 7); // lower-left
					break;
				case 3:
					mo.WeaveIndexXY = 32 + (random[HolyAtk2]() & 7);
					mo.WeaveIndexZ = 32 + (random[HolyAtk2]() & 7);
					break;
			}
			mo.SetZ(pos.z);
			mo.angle = angle + 67.5 - 45.*j;
			mo.Thrust();
			mo.target = target;
			mo.args[0] = 10; // initial turn value
			mo.args[1] = 0; // initial look angle
			if (deathmatch)
			{
				// Ghosts last slightly less longer in DeathMatch
				mo.health = spiritfusedm;
				if (spiritfusedm <= 0) mo.health = 85;
			}
			else
			{
				mo.health = spiritfuse;
				if (spiritfuse <= 0) mo.health = 105;
			}
			if (tracer)
			{
				mo.tracer = tracer;
				mo.bNoClip = true;
				mo.bSkullFly = true;
				mo.bMissile = false;
			}
			HolyTail.SpawnSpiritTail (mo);
		}
	}

	// Sigil 1/Programmer Lightning Spawn Spot
	void A_SpectralLightning (string spawntype1 = "SpectralLightningV1", string spawntype2 = "SpectralLightningV2")
	{
		if (threshold != 0)
			--threshold;

		Vel.X += random2[Zap5](3);
		Vel.Y += random2[Zap5](3);

		double xo = random2[Zap5](3) * 50.;
		double yo = random2[Zap5](3) * 50.;
		
		class<Actor> cls;
		if (threshold > 25) cls = spawntype2;
		else cls = spawntype1;

		Actor flash = Spawn (cls, Vec2OffsetZ(xo, yo, ONCEILINGZ), ALLOW_REPLACE);

		if (flash != null)
		{
			flash.target = target;
			flash.Vel.Z = -18;
			flash.FriendPlayer = FriendPlayer;
		}

		flash = Spawn(spawntype2, (pos.xy, ONCEILINGZ), ALLOW_REPLACE);

		if (flash != null)
		{
			flash.target = target;
			flash.Vel.Z = -18;
			flash.FriendPlayer = FriendPlayer;
		}
	}

    // Player Sigil 2 Shots
	void A_SpectralLightningTail ()
	{
		Actor foo = Spawn("SpectralLightningHTail", Vec3Offset(-Vel.X, -Vel.Y, 0.), ALLOW_REPLACE);
		if (foo != null)
		{
			foo.Angle = Angle;
			foo.FriendPlayer = FriendPlayer;
		}
	}

	// Sigil5 Shots
	void A_SpectralBigBallLightning (string spawntype = "SpectralLightningH3")
	{
		Class<Actor> cls = spawntype;
		if (cls)
		{
			angle += 90.;
			if (target) SpawnSubMissile (cls, target); else SpawnSubMissile (cls, self);
			angle += 180.;
			if (target) SpawnSubMissile (cls, target); else SpawnSubMissile (cls, self);
			angle -= 270.;
			if (target) SpawnSubMissile (cls, target); else SpawnSubMissile (cls, self);
		}
	}
	
	void A_HadesSphereExplode(int basedmg = 112, int baserad = 112)
	{
		int newdmg = basedmg;
		int newrad = baserad;
		if (target)
		{
			AetheriusMonsterZSC DVDSActor;
			DVDSActor = AetheriusMonsterZSC(target);
			if (DVDSActor)
			{
				int maxhp;
				if (DVDSActor.user_MaxHP > 0) maxhp = DVDSActor.user_MaxHP;
				else maxhp = DVDSActor.SpawnHealth();
				maxhp *= (1.0 + (DVDSActor.user_monsterlevel * 0.0111111112)); // +100% damage every ~90 levels
				maxhp *= 0.25; // +100% damage every ~180 levels
				newdmg += maxhp;
				int healthleft = DVDSActor.hsexphealth;
				healthleft *= (1.0 + (DVDSActor.user_monsterlevel * 0.0222222223)); // +100% damage every ~45 levels
				healthleft *= 0.5;
				newdmg += healthleft;

				int maxhp2;
				if (DVDSActor.user_MaxHP > 0) maxhp2 = DVDSActor.user_MaxHP;
				else maxhp2 = DVDSActor.SpawnHealth();
				maxhp2 *= (1.0 + (DVDSActor.user_monsterlevel * 0.005555556)); // +100% radius every ~180 levels
				maxhp2 *= 0.125;
				newrad += maxhp2;
				int healthleft2 = DVDSActor.hsexphealth;
				healthleft2 *= (1.0 + (DVDSActor.user_monsterlevel * 0.011111112)); // +100% radius every ~90 levels
				healthleft2 *= 0.25;
				newrad += healthleft2;
				
				if (dvdsdebug_showmiscdmginformation) Console.Printf("NewDmg: %d (%d), NewRad: %d (%d), MaxHP: %d, HealthLeft: %d, MaxHP2: %d, HealthLeft2: %d", newdmg, basedmg, newrad, baserad, maxhp, healthleft, maxhp2, healthleft2);
			}
		}
		A_Explode(newdmg,newrad,0,(newrad*0.334));
	}

	void A_SpawnRck(int type = 0)
	{
		string spawntype1 = "PossessedBalloon";
		string spawntype2 = "JumpingSkull";
		if (type == 0)
		{
			Actor spawn1 = A_SpawnProjectile(spawntype1, 64, 64, 60, 0);
			Actor spawn2 = A_SpawnProjectile(spawntype1, 32, -32, 0, 0);
			Actor spawn3 = A_SpawnProjectile(spawntype1, 32, 0, 0, 0);
			Actor spawn4 = A_SpawnProjectile(spawntype2, 0, 0, 0, 0);
			if (target && target.bFRIENDLY)
			{
				
				if (spawn1) { spawn1.bFRIENDLY = true; }
				if (spawn2) { spawn2.bFRIENDLY = true; }
				if (spawn3) { spawn3.bFRIENDLY = true; }
				if (spawn4) { spawn4.bFRIENDLY = true; }
			}
		}
		
		if (type == 1)
		{
			Actor spawn1 = A_SpawnProjectile(spawntype1, 64, 64, 60, 0);
			Actor spawn2 = A_SpawnProjectile(spawntype1, 0, 0, 60, 0);
			Actor spawn3 = A_SpawnProjectile(spawntype1, 32, -32, 0, 0);
			Actor spawn4 = A_SpawnProjectile(spawntype1, 32, 0, 0, 0);
			Actor spawn5 = A_SpawnProjectile(spawntype1, 0, -32, 0, 0);
			Actor spawn6 = A_SpawnProjectile(spawntype1, 0, 32, 0, 0);
			Actor spawn7 = A_SpawnProjectile(spawntype2, 0, 0, 0, 0);
			Actor spawn8 = A_SpawnProjectile(spawntype2, 32, 0, 0, 0);
			Actor spawn9 = A_SpawnProjectile(spawntype2, 0, 32, 0, 0);
			if (target && target.bFRIENDLY)
			{
				if (spawn1) { spawn1.bFRIENDLY = true; }
				if (spawn2) { spawn2.bFRIENDLY = true; }
				if (spawn3) { spawn3.bFRIENDLY = true; }
				if (spawn4) { spawn4.bFRIENDLY = true; }
				if (spawn5) { spawn5.bFRIENDLY = true; }
				if (spawn6) { spawn6.bFRIENDLY = true; }
				if (spawn7) { spawn7.bFRIENDLY = true; }
				if (spawn8) { spawn8.bFRIENDLY = true; }
				if (spawn9) { spawn9.bFRIENDLY = true; }
			}
		}
		
	}
}

// Base FastProjectile Class
class AetheriusFastProjectileZSC : AetheriusBaseProjectileZSC
{
	Default
	{
		Projectile;
		MissileHeight 0;
	}
	
	int projtouchedshieldactor;
	
	virtual void Effect()
	{
		class<Actor> trail = MissileName;
		if (trail != null)
		{
			double hitz = pos.z - 8;

			if (hitz < floorz)
			{
				hitz = floorz;
			}
			// Do not clip this offset to the floor.
			hitz += MissileHeight;
			
			Actor act = Spawn (trail, (pos.xy, hitz), ALLOW_REPLACE);
			if (act != null)
			{
				if (bGetOwner && target != null)
					act.target = target;
				else
					act.target = self;
				
				act.angle = angle;
				act.pitch = pitch;
				
				BaseWandMissile act2;
				act2 = BaseWandMissile(self);
				if (act2 && act2.wandmissleeraseproj)
				{
					act.scale.x *= 1.25;
					act.scale.y *= 1.25;
					act.A_SetRenderStyle(act.alpha*0.667,6);
				}
			}
		}
	}
	
	//----------------------------------------------------------------------------
	//
	// AFastProjectile :: Tick
	//
	// Thinker for the ultra-fast projectiles used by Heretic and Hexen
	//
	//----------------------------------------------------------------------------

	override void Tick()
	{
		if (GetAge() == 1)
		{
			BaseWandMissile act2;
			act2 = BaseWandMissile(self);
			if (act2 && act2.wandmissleeraseproj)
			{
				scale.x *= 1.25;
				scale.y *= 1.25;
				A_SetRenderStyle(alpha*0.667,6);
			}
		}
		if (GetAge() <= 4)
		{
			if (GetClassName() == "STGrenade" || GetClassName() == "STGrenadeNoAOE" || 
					GetClassName() == "RocketPlayer" || GetClassName() == "RocketPlayerNoAOE" || 
					GetClassName() == "RocketPlayerSeeking" || GetClassName() == "RocketPlayerSeekingNoAOE") { finaldamagedealt = A_GetPlayerAttackDamage(8,0); }

			if (GetClassName() == "RepeaterPuffPlayer") { finaldamagedealt = A_GetPlayerAttackDamage(10,0); }
			if (GetClassName() == "PlasmaBallPlayer") { finaldamagedealt = A_GetPlayerAttackDamage(11,0); }
			if (GetClassName() == "PlasmaBall1Player") { finaldamagedealt = A_GetPlayerAttackDamage(12,0); }
			if (GetClassName() == "PlasmaBall2Player") { finaldamagedealt = A_GetPlayerAttackDamage(13,0); }
			if (GetClassName() == "BFGBallPlayer") { finaldamagedealt = A_GetPlayerAttackDamage(14,0); }

			if (GetClassName() == "KsawBoltPlayer") { finaldamagedealt = A_GetPlayerAttackDamage(16,0); }

			if (GetClassName() == "DiarisHolyArrow") { finaldamagedealt = A_GetPlayerAttackDamage(18,0); }
			if (GetClassName() == "DiarisHolyArrow2XDmg") { finaldamagedealt = A_GetPlayerAttackDamage(19,0); }
			if (GetClassName() == "DiarisHolyArrow3XDmg") { finaldamagedealt = A_GetPlayerAttackDamage(20,0); }
			if (GetClassName() == "CrossbowFX1New") { finaldamagedealt = A_GetPlayerAttackDamage(21,0); }
			if (GetClassName() == "CrossbowFX2New") { finaldamagedealt = A_GetPlayerAttackDamage(22,0); }
			if (GetClassName() == "CrossbowFX3New") { finaldamagedealt = A_GetPlayerAttackDamage(23,0); }
			if (GetClassName() == "RipperNew") { finaldamagedealt = A_GetPlayerAttackDamage(24,0); }
			if (GetClassName() == "ElectricBoltNew") { finaldamagedealt = A_GetPlayerAttackDamage(25,0); }
			if (GetClassName() == "PoisonBoltNew") { finaldamagedealt = A_GetPlayerAttackDamage(26,0); }

			if (GetClassName() == "BlasterFX1New") { finaldamagedealt = A_GetPlayerAttackDamage(28,0); }

			if (GetClassName() == "HornRodFX1New") { finaldamagedealt = A_GetPlayerAttackDamage(31,0); }
			if (GetClassName() == "HornRodFX2New") { finaldamagedealt = A_GetPlayerAttackDamage(32,0); }
			if (GetClassName() == "PhoenixFX1New" || GetClassName() == "PhoenixFX1NoAOE") { finaldamagedealt = A_GetPlayerAttackDamage(33,0); }
			if (GetClassName() == "PhoenixFX2New") { finaldamagedealt = A_GetPlayerAttackDamage(34,0); }
			if (GetClassName() == "MaceFX1New") { finaldamagedealt = A_GetPlayerAttackDamage(35,0); }
			if (GetClassName() == "MaceFX2New") { finaldamagedealt = A_GetPlayerAttackDamage(36,0); }
			if (GetClassName() == "MaceFX3New") { finaldamagedealt = A_GetPlayerAttackDamage(37,0); }
			if (GetClassName() == "MaceFX4New") { finaldamagedealt = A_GetPlayerAttackDamage(38,0); }
			if (GetClassName() == "Sorcerer2FX1Player") { finaldamagedealt = A_GetPlayerAttackDamage(39,0); }
			if (GetClassName() == "Sorcerer2FX3") { finaldamagedealt = A_GetPlayerAttackDamage(40,0); }
			if (GetClassName() == "GoldWandFX1New") { finaldamagedealt = A_GetPlayerAttackDamage(41,0); }
			if (GetClassName() == "GoldWandFX2New") { finaldamagedealt = A_GetPlayerAttackDamage(42,0); }
			if (GetClassName() == "RainPillarNew") { finaldamagedealt = A_GetPlayerAttackDamage(43,0); }
			if (GetClassName() == "MageWandMissileNew") { finaldamagedealt = A_GetPlayerAttackDamage(44,0); }
			if (GetClassName() == "MageWandMissile2New") { finaldamagedealt = A_GetPlayerAttackDamage(45,0); }
			if (GetClassName() == "HubbleBubbleSmall") { finaldamagedealt = A_GetPlayerAttackDamage(46,0); }
			if (GetClassName() == "HubbleBubbleLarge") { finaldamagedealt = A_GetPlayerAttackDamage(47,0); }
			if (GetClassName() == "EvilWarriorShieldBall" || GetClassName() == "EvilWarriorShieldBallCrisis") { finaldamagedealt = A_GetPlayerAttackDamage(52,0); }
			if (GetClassName() == "SonicNail") { finaldamagedealt = A_GetPlayerAttackDamage(63,0); }
			if (GetClassName() == "UnmakerLaser" || GetClassName() == "UnmakerLaserCrisis") { finaldamagedealt = A_GetPlayerAttackDamage(71,0); }
		}
		// Mostly Original FastProjectile Code Beneath here.

		ClearInterpolation();
		double oldz = pos.Z;

		if (!bNoTimeFreeze)
		{
			//Added by MC: Freeze mode.
			if (isFrozen())
			{
				return;
			}
		}

		// [RH] Ripping is a little different than it was in Hexen
		FCheckPosition tm;
		tm.DoRipping = bRipper;

		int count = 8;
		if (radius > 0)
		{
			while (abs(Vel.X) >= radius * count || abs(Vel.Y) >= radius * count)
			{
				// we need to take smaller steps.
				count += count;
			}
		}

		if (height > 0)
		{
			while (abs(Vel.Z) >= height * count)
			{
				count += count;
			}
		}

		// Handle movement
		if (Vel != (0, 0, 0) || (pos.Z != floorz))
		{
			// force some lateral movement so that collision detection works as intended.
			if (bMissile && Vel.X == 0 && Vel.Y == 0 && !IsZeroDamage())
			{
				Vel.X = MinVel;
			}

			Vector3 frac = Vel / count;
			int changexy = frac.X != 0 || frac.Y != 0;
			int ripcount = count / 8;
			for (int i = 0; i < count; i++)
			{
				if (changexy)
				{
					if (--ripcount <= 0)
					{
						tm.ClearLastRipped();	// [RH] Do rip damage each step, like Hexen
					}
					
					if (!TryMove (Pos.XY + frac.XY, true, NULL, tm))
					{ // Blocked move
						if (!bSkyExplode)
						{
							let l = tm.ceilingline;
							if (l &&
								l.backsector &&
								l.backsector.GetTexture(sector.ceiling) == skyflatnum)
							{
								let posr = PosRelative(l.backsector);
								if (pos.Z >= l.backsector.ceilingplane.ZatPoint(posr.XY))
								{
									// Hack to prevent missiles exploding against the sky.
									// Does not handle sky floors.
									Destroy ();
									return;
								}
							}
							// [RH] Don't explode on horizon lines.
							if (BlockingLine != NULL && BlockingLine.special == Line_Horizon)
							{
								Destroy ();
								return;
							}
						}

						ExplodeMissile (BlockingLine, BlockingMobj);
						return;
					}
				}
				AddZ(frac.Z);
				UpdateWaterLevel();
				oldz = pos.Z;
				if (oldz <= floorz)
				{ // Hit the floor

					if (floorpic == skyflatnum && !bSkyExplode)
					{
						// [RH] Just remove the missile without exploding it
						//		if this is a sky floor.
						Destroy ();
						return;
					}

					SetZ(floorz);
					HitFloor ();
					ExplodeMissile (NULL, NULL);
					return;
				}
				if (pos.Z + height > ceilingz)
				{ // Hit the ceiling

					if (ceilingpic == skyflatnum && !bSkyExplode)
					{
						Destroy ();
						return;
					}

					SetZ(ceilingz - Height);
					ExplodeMissile (NULL, NULL);
					return;
				}
				CheckPortalTransition();
				if (changexy && ripcount <= 0) 
				{
					ripcount = count >> 3;

					// call the 'Effect' method.
					Effect();
				}
			}
		}
		if (!CheckNoDelay())
			return;		// freed itself
		// Advance the state
		if (tics != -1)
		{
			if (tics > 0) tics--;
			while (!tics)
			{
				if (!SetState (CurState.NextState))
				{ // mobj was removed
					return;
				}
			}
		}

		tic++;
	}
}

class AetheriusEffectFastProjectile : AetheriusFastProjectileZSC
{
	int user_canafflict;
	default
	{
		+HITMASTER;
	}
	
	void A_StatusEffectChecker(int basechance)
	{
		user_ailmentmaxchance = basechance;
		if (CountInv("EWShieldIdleMode",AAPTR_PLAYER1) > 0) user_ailmentmaxchance * 4;
		if (DivineAvatarTimer > 0) user_ailmentmaxchance * 4;

		user_canafflict = 1;
		if (master != null && master.health <= 0) user_canafflict = 0;
		if (CountInv("InvulnerabilitySpell",AAPTR_MASTER) > 0 || 
				CountInv("IsInvulnerable",AAPTR_MASTER) > 0 || 
				CountInv("MenuInvulnerability",AAPTR_MASTER) > 0 ||
				CountInv("EvadeAnAttack",AAPTR_MASTER) > 0 || 
				CountInv("PlayerDashing",AAPTR_MASTER) > 0) 
				{
					user_canafflict = 0;
				}

		AetheriusPlayerPawn playpawn;
		if (master) playpawn = AetheriusPlayerPawn(master);
		if (playpawn)
		{
			if (playpawn.player.cheats & CF_GODMODE2 || playpawn.player.cheats & CF_GODMODE) user_canafflict = 0;
		}
	}
}

// Base Bullet Tracer Class
class AetheriusBulletTracerZSC : AetheriusFastProjectileZSC
{
	override void PostBeginPlay()
	{
		A_ScaleVelocity(dvds_tracervelmulti);

		Super.PostBeginPlay();
	}
	
	action void A_SpawnTracerTrail(string name = "ZombieBulletTracerTrail", int extranum = 6, double spread = -2.5)
	{
		double posx = 0.0;
		A_SpawnItemEx(name,posx,0,0,0,0,0,0,128,0);
		for (int trailnum = 0; trailnum < extranum; trailnum++)
		{
			posx += spread;
			A_SpawnItemEx(name,posx,0,0,0,0,0,0,128,0);
		}
	}
}

// Base Puff Class
class AetheriusPuffZSC : AetheriusBaseProjectileZSC
{
	int user_hitsparkrand;
	int user_sparksizelevel;
	double user_sparkscalemulti;

	Default
	{
		+NOBLOCKMAP
		+NOGRAVITY
		+ALLOWPARTICLES
		+RANDOMIZE
		+ZDOOMTRANS
		RenderStyle "Translucent";
		Alpha 0.5;
		VSpeed 1;
		Mass 5;
	}

	void A_HitSparkGetSize()
	{
		user_sparksizelevel = MartialArtsMastery + BerserkerFit;
		if (user_sparksizelevel <= 0) { A_SetScale(0.3125); A_FadeTo(0.6875); }
		if (user_sparksizelevel == 1) { A_SetScale(0.375); A_FadeTo(0.75); }
		if (user_sparksizelevel == 2) { A_SetScale(0.4375); A_FadeTo(0.8125); }
		if (user_sparksizelevel == 3) { A_SetScale(0.5); A_FadeTo(0.875); }
		if (user_sparksizelevel == 4) { A_SetScale(0.5625); A_FadeTo(0.9375); }
		if (user_sparksizelevel >= 5) { A_SetScale(0.625); A_FadeTo(1.0); }
		//Console.Printf("ScaleX: %.4f, ScaleY: %.4f, ALPHAZ: %.4f", self.scale.x, self.scale.y, self.alpha);
	}
	void A_HitSparkGetSize2()
	{
		user_sparkscalemulti = (StamUpPerkLevel * 0.05) + (StamUpEXPerkLevel * 0.125);
		user_sparkscalemulti += 1.00;
		scale.x *= user_sparkscalemulti;
		scale.y *= user_sparkscalemulti;
		//Console.Printf("ScaleX: %.4f, ScaleY: %.4f, MULTI: %.4f", self.scale.x, self.scale.y, user_sparkscalemulti);
	}

	void A_HitSparkResize()
	{
		double base;
		if (user_sparksizelevel <= 0) base = 0.25;
		if (user_sparksizelevel == 1) base = 0.275;
		if (user_sparksizelevel == 2) base = 0.30;
		if (user_sparksizelevel == 3) base = 0.325;
		if (user_sparksizelevel == 4) base = 0.35;
		if (user_sparksizelevel >= 5) base = 0.375;

		user_sparkscalemulti = frandom(base,(base*1.5));
		scale.x *= user_sparkscalemulti;
		scale.y *= user_sparkscalemulti;
		//Console.Printf("ScaleX: %.4f, ScaleY: %.4f", self.scale.x, self.scale.y);
	}

	States
	{
		Spawn:
			PUFF A 4 Bright;
			PUFF B 4;
		Melee:
			PUFF CD 4;
			Stop;
	}
}

// Base Crisis Particle
class AetheriusCrisisParticle : AetheriusBaseZSC
{
	double user_basealpha; 
	double user_basescaleX;
	double user_basescaleY;

	default
	{
		Speed 0.2;
		Vspeed -32;
		+NOBLOCKMAP
		+NOGRAVITY
		+NOTELEPORT
		+CANNOTPUSH
		+NOINTERACTION
		RenderStyle "Add";
		scale 0.67;
		Alpha 0.67;
	}

	void A_CrisisParticleInit()
	{
		alpha *= 0.67;
		scale.x *= 0.67;
		scale.y *= 0.67;
		user_basealpha = alpha * 0.10;
		user_basescaleX = scale.x * 0.10;
		user_basescaleY = scale.y * 0.10;
		//Console.Printf("BASEScaleX: %.4f, BASEScaleY: %.4f, BASEALPHAZ: %.4f", user_basescaleX, user_basescaleY, user_basealpha);
	}

	void A_CrisisParticleDo()
	{
		A_FadeOut(user_basealpha);
		self.scale.x -= user_basescaleX;
		self.scale.y -= user_basescaleY;
		//ThrustThingZ (0, 8, 0, 0);
		//Console.Printf("ScaleX: %.4f, ScaleY: %.4f, ALPHAZ: %.4f", self.scale.x, self.scale.y, self.alpha);

		if (self.scale.x < 0.00 && self.scale.y < 0.00) { A_FadeOut(2); }
	}

	States
	{
		Spawn:
			"####" "#" 0 Bright NoDelay A_CrisisParticleInit();
			goto Idle;
		Idle:
			"####" "#" 2 Bright A_CrisisParticleDo();
			loop;
	}
}
	
class AetheriusSpawnShotZSC : SpawnShot
{
	private void SpawnFlyDS(class<Actor> spawntype, sound snd)
	{
		Actor newmobj;
		Actor fog;
		Actor eye = master; // The eye is the spawnshot's master, not the target!
		Actor targ = target; // Unlike other projectiles, the target is the intended destination.
		int r;
			
		// [GZ] Should be more viable than a countdown...
		if (special2 != 0)
		{
			if (special2 > level.maptime)
				return;		// still flying
		}
		else
		{
			if (reactiontime == 0 || --reactiontime != 0)
				return;		// still flying
		}
		
		if (spawntype)
		{
			fog = Spawn (spawntype, targ.pos, ALLOW_REPLACE);
			if (fog) A_StartSound(snd, CHAN_BODY);
		}

		class<Actor> SpawnName = null;

		DropItem di;   // di will be our drop item list iterator
		DropItem drop; // while drop stays as the reference point.
		int n = 0;

		// First see if this cube has its own actor list
		drop = GetDropItems();

		// If not, then default back to its master's list
		if (drop == null && eye != null)
			drop = eye.GetDropItems();

		if (drop != null)
		{
			for (di = drop; di != null; di = di.Next)
			{
				if (di.Name != 'None')
				{
					if (di.Amount < 0)
					{
						//di.Amount = 1; // default value is -1, we need a positive value.
					}
					n += di.Amount; // this is how we can weight the list.
				}
			}
			di = drop;
			n = random[pr_spawnfly](0, n);
			while (n >= 0)
			{
				if (di.Name != 'none')
				{
					n -= di.Amount; // logically, none of the -1 values have survived by now.
				}
				if ((di.Next != null) && (n >= 0))
				{
					di = di.Next;
				}
				else
				{
					n = -1;
				}
			}
			SpawnName = di.Name;
		}
		if (SpawnName == null)
		{
			// Randomly select monster to spawn.
			r = random(1,256); // r = random[pr_spawnfly](0, 255);

			// Probability distribution (kind of :),
			// decreasing likelihood.
			if (r < 16)  SpawnName = "Zombieman";		// 16/256
			else if (r < 32)  SpawnName = "ShotgunGuy";  	// 16/256 
			else if (r < 48)  SpawnName = "ChaingunGuy";	// 16/256 
			else if (r < 72)  SpawnName = "DoomImp";  		// 24/256 
			else if (r < 96)  SpawnName = "Demon";  		// 24/256 
			else if (r < 108) SpawnName = "PainElemental";	// 12/256
			else if (r < 132) SpawnName = "Cacodemon";		// 24/256
			else if (r < 144) SpawnName = "Revenant";		// 12/256
			else if (r < 168) SpawnName = "Arachnotron";	// 24/256
			else if (r < 192) SpawnName = "Fatso";			// 24/256
			else if (r < 216) SpawnName = "HellKnight";		// 24/256
			else if (r < 228) SpawnName = "BaronOfHell";	// 12/256
			else if (r < 240) SpawnName = "HellCleric";		// 12/256
			else if (r < 244) SpawnName = "Archvile";		// 4/256
			else if (r < 248) SpawnName = "FlyingBalrog";	// 4/256
			else if (r < 252) SpawnName = "Cyberdemon";		// 4/256
			else SpawnName = "HadesOverlord";	// 4/256
		}
		if (spawnname != null)
		{
			newmobj = Spawn (spawnname, targ.pos, ALLOW_REPLACE);
			if (newmobj != null)
			{
				// Make the new monster hate what the boss eye hates
				if (eye != null)
				{
					newmobj.CopyFriendliness (eye, false);
				}
				// Make it act as if it was around when the player first made noise
				// (if the player has made noise).
				newmobj.LastHeard = newmobj.CurSector.SoundTarget;

				if (newmobj.SeeState != null && newmobj.LookForPlayers (true))
				{
					newmobj.SetState (newmobj.SeeState);
				}
				if (!newmobj.bDestroyed)
				{
					// telefrag anything in this spot
					newmobj.TeleportMove (newmobj.pos, true);
				}
				newmobj.bBossSpawned = true;
			}
		}

		// remove self (i.e., cube).
		Destroy ();
	}

	void A_SpawnFlyDS(class<Actor> spawntype = null)
	{
		sound snd; 
		if (spawntype != null) 
		{
			snd = GetDefaultByType(spawntype).SeeSound;
		}
		else
		{
			spawntype = "SpawnFire";
			snd = "brain/spawn";
		}
		SpawnFlyDS(spawntype, snd);
	}

	void A_SpawnSoundDS()
	{
		// travelling cube sound
		A_StartSound("brain/cube", CHAN_BODY);
		SpawnFlyDS("SpawnFire", "brain/spawn");
	}	
}

class AetheriusEffectProjectile : AetheriusProjectileZSC
{
	int user_canafflict;
	default
	{
		+HITMASTER;
	}
	
	void A_StatusEffectChecker(int basechance)
	{
		user_ailmentmaxchance = basechance;
		if (CountInv("EWShieldIdleMode",AAPTR_PLAYER1) > 0) user_ailmentmaxchance * 4;
		if (DivineAvatarTimer > 0) user_ailmentmaxchance * 4;

		user_canafflict = 1;
		if (master != null && master.health <= 0) user_canafflict = 0;
		if (CountInv("InvulnerabilitySpell",AAPTR_MASTER) > 0 || 
				CountInv("IsInvulnerable",AAPTR_MASTER) > 0 || 
				CountInv("MenuInvulnerability",AAPTR_MASTER) > 0 ||
				CountInv("EvadeAnAttack",AAPTR_MASTER) > 0 || 
				CountInv("PlayerDashing",AAPTR_MASTER) > 0) 
				{
					user_canafflict = 0;
				}

		AetheriusPlayerPawn playpawn;
		if (master) playpawn = AetheriusPlayerPawn(master);
		if (playpawn)
		{
			if (playpawn.player.cheats & CF_GODMODE2 || playpawn.player.cheats & CF_GODMODE) user_canafflict = 0;
		}
	}
}

class AetheriusWhirlwind : AetheriusProjectileZSC
{
	default
	{
		Accuracy 8;
		DamageType "Wind";
	}

	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		int randVal;
		Accuracy = clamp(Accuracy, 1, Accuracy);
		int whirltimer = level.time & (Accuracy-1);
		int whirldmg = 3 * randompick(1,1,1,1,1,1,1,1,2,2,2,3);            
		if (Stamina == 30) whirldmg *= CrisisMultiplier;

		if (!target.bDontThrust)
		{
			target.angle += Random2[WhirlwindDamage]() * (360 / 4096.);
			target.Vel.X += Random2[WhirlwindDamage]() / 64.;
			target.Vel.Y += Random2[WhirlwindDamage]() / 64.;
		}

		if ((level.time & 16) && !target.bBoss && !target.bDontThrust)
		{
			randVal = min(160, random[WhirlwindSeek]());
			target.Vel.Z += randVal / 32.;
			target.Vel.Z = clamp(target.Vel.Z, target.Vel.Z, 12);
		}

		if (whirltimer == 0)
		{
			target.DamageMobj (null, target, whirldmg, 'Wind');
		}
		return -1;
	}

	void A_WhirlwindSeek()
	{
		health -= 3;
		if (health < 0)
		{
			Vel = (0,0,0);
			SetStateLabel("Death");
			bMissile = false;
			return;
		}
		if ((threshold -= 3) < 0)
		{
			threshold = 58 + (random[WhirlwindSeek]() & 31);
			A_StartSound("ironlich/attack3", CHAN_BODY);
		}
		if (tracer && tracer.bShadow)
		{
			return;
		}
		A_SeekerMissile(10, 30);
	}
	
}

// Holy Spirit --------------------------------------------------------------
class HolySpiritBase : AetheriusDoomSpellZSC
{
	Default
	{
		Health 105;
		Speed 12;
		Radius 10;
		Height 6;
		Damage 3;
		Projectile;
		+RIPPER +SEEKERMISSILE
		+FOILINVUL +SKYEXPLODE +NOEXPLODEFLOOR +CANBLAST
		+EXTREMEDEATH +NOSHIELDREFLECT
		RenderStyle "Translucent";
		Alpha 0.4;
		DeathSound "SpiritDie";
		Obituary "$OB_MPCWEAPWRAITHVERGE";
	}

	States
	{
		Spawn:
			SPIR AAB 2 A_CHolySeek;
			SPIR B 2 A_CHolyCheckScream;
			Loop;
		Death:
			SPIR D 4;
			SPIR E 4 A_Scream;
			SPIR FGHI 4;
			Stop;
	}
	
	//============================================================================
	//
	//
	//
	//============================================================================

	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		int RandCall;

		string nm, nn, no, np;

		AetheriusMonsterZSC s2; 
		s2 = AetheriusMonsterZSC(target);
		
		string s2name;

		if (s2 != null)
		{
			s2name = s2.GetClassName();
			nm = "DSparilUnmountedNew";

			if (s2name == nm)
			{
				// D'Sparil teleports away
				if (MagiUpPerkLevel <= 0) RandCall = 4;
				if (MagiUpPerkLevel == 1) RandCall = 4;
				if (MagiUpPerkLevel == 2) RandCall = 3;
				if (MagiUpPerkLevel == 3) RandCall = 3;
				if (MagiUpPerkLevel == 4) RandCall = 2;
				if (MagiUpPerkLevel >= 5) RandCall = 2;

				if (random(1,1024) <= RandCall)
				{
					s2.DSparilTeleport();
					return -1;
				}
				return damage;
			}
			return damage;
		}
		return damage;
	}

	override bool Slam(Actor thing)
	{
		if (thing.bShootable && thing != target)
		{
			if (multiplayer && !deathmatch && thing.player && target.player)
			{
				// don't attack other co-op players
				return true;
			}
			if (thing.bReflective && (thing.player || thing.bBoss))
			{
				tracer = target;
				target = thing;
				return true;
			}
			if (thing.bIsMonster || thing.player)
			{
				tracer = thing;
			}
			if (random[SpiritSlam]() < 96)
			{
				int dam = 12;
				if (thing.player || thing.bBoss)
				{
					dam = 3;
					// ghost burns out faster when attacking players/bosses
					health -= 6;
				}
				if (Stamina == 30) { dam *= CrisisMultiplier; }

				thing.DamageMobj(self, target, dam, 'Melee');
				if (random[SpiritSlam]() < 128)
				{
					Spawn("HolyPuff", Pos, ALLOW_REPLACE);
					A_StartSound("SpiritAttack", CHAN_WEAPON);
					if (thing.bIsMonster && random[SpiritSlam]() < 128)
					{
						thing.Howl();
					}
				}
			}
			if (thing.health <= 0)
			{
				tracer = null;
			}
		}
		return true;
	}

	override bool SpecialBlastHandling (Actor source, double strength)
	{
		if (tracer == source)
		{
			tracer = target;
			target = source;
		}
		return true;
	}

	//============================================================================
	//
	// CHolyFindTarget
	//
	//============================================================================

	private void CHolyFindTarget ()
	{
		Actor target;

		if ( (target = RoughMonsterSearch (6, true)) )
		{
			tracer = target;
			bNoClip = true;
			bSkullFly = true;
			bMissile = false;
		}
	}

	//============================================================================
	//
	// CHolySeekerMissile
	//
	// Similar to P_SeekerMissile, but seeks to a random Z on the target
	//============================================================================

	private void CHolySeekerMissile (double thresh, double turnMax)
	{
		Actor target = tracer;
		if (target == NULL)
		{
			return;
		}
		if (!target.bShootable || (!target.bIsMonster && !target.player))
		{
			// Target died/target isn't a player or creature
			tracer = null;
			bNoClip = false;
			bSkullFly = false;
			bMissile = true;
			CHolyFindTarget();
			return;
		}
		double ang = deltaangle(angle, AngleTo(target));
		double delta = abs(ang);
		
		if (delta > thresh)
		{
			delta /= 2;
			if (delta > turnMax)
			{
				delta = turnMax;
			}
		}
		if (ang > 0)
		{
			// Turn clockwise
			angle += delta;
		}
		else
		{
			// Turn counter clockwise
			angle -= delta;
		}
		VelFromAngle();

		if (!(level.time&15) 
			|| pos.z > target.pos.z + target.height
			|| pos.z + height < target.pos.z)
		{
			double newZ = target.pos.z + ((random[HolySeeker]()*target.Height) / 256.);
			double deltaZ = newZ - pos.z;
			if (abs(deltaZ) > 15)
			{
				if (deltaZ > 0)
				{
					deltaZ = 15;
				}
				else
				{
					deltaZ = -15;
				}
			}
			Vel.Z = deltaZ / DistanceBySpeed(target, Speed);
		}
	}

	//============================================================================
	//
	// A_CHolySeek
	//
	//============================================================================

	void A_CHolySeek()
	{
		health--;
		if (health <= 0)
		{
			Vel.X /= 4;
			Vel.Y /= 4;
			Vel.Z = 0;
			SetStateLabel ("Death");
			tics -= random[HolySeeker]()&3;
			return;
		}
		if (tracer)
		{
			CHolySeekerMissile (args[0], args[0]*2.);
			if (!((level.time+7)&15))
			{
				args[0] = 5+(random[HolySeeker]()/20);
			}
		}

		int xyspeed = (random[HolySeeker]() % 5);
		int zspeed = (random[HolySeeker]() % 5);
		A_Weave(xyspeed, zspeed, 4., 2.);
	}

	//============================================================================
	//
	// A_CHolyCheckScream
	//
	//============================================================================

	void A_CHolyCheckScream()
	{
		A_CHolySeek();
		if (random[HolyScream]() < 20)
		{
			A_StartSound("SpiritActive", CHAN_VOICE);
		}
		if (!tracer)
		{
			CHolyFindTarget();
		}
	}
}

// Mage Staff FX2 (Bloodscourge) --------------------------------------------
class MageStaffFX2Base : AetheriusProjectileZSC
{
	Default
	{
		Speed 17;
		Height 8;
		Damage 4;
		DamageType "Fire";
		Projectile;
		+SEEKERMISSILE
		+SCREENSEEKER
		+EXTREMEDEATH
		DeathSound "MageStaffExplode";
		Obituary "$OB_MPMWEAPBLOODSCOURGE";
	}


	States
	{
		Spawn:
			MSP2 ABCD 2 Bright A_MStaffTrack;
			Loop;
		Death:
			MSP2 E 4 Bright A_SetTranslucent(1,1);
			MSP2 F 5 Bright A_Explode (80, 192, 0);
			MSP2 GH 5 Bright;
			MSP2 I 4 Bright;
			Stop;
	}
	
	//============================================================================
	//
	//
	//
	//============================================================================

	override int SpecialMissileHit (Actor victim)
	{
		if (victim != target && !victim.player && !victim.bBoss)
		{
			int dam = 10;
			if (Stamina == 30) { dam *= CrisisMultiplier; }

			victim.DamageMobj (self, target, dam, 'Fire');
			return 1;	// Keep going
		}
		return -1;
	}

	override bool SpecialBlastHandling (Actor source, double strength)
	{
		// Reflect to originator
		tracer = target;	
		target = source;
		return true;
	}

	//============================================================================
	//
	// A_MStaffTrack
	//
	//============================================================================

	void A_MStaffTrack()
	{
		if (tracer == null && random[MStaffTrack]() < 50)
		{
			tracer = RoughMonsterSearch (10, true);
		}
		A_SeekerMissile(2, 10);
	}
}

class HealMissile : AetheriusProjectileZSC
{
	// A_SeekerMissile variant that seeks out friends in need of healing.
	action void A_HealingSeekerMissile(int threshold, int maxturnangle, int flags = 0, int chance = 50, int distance = 10, int healtype = 0)
	{
		int maxhealth;
		if (
			(flags & SMF_LOOK) // this projectile should seek new targets
			&& target // this projectile's shooter is known
			&& (!tracer || !(tracer.bShootable && CanSeek(tracer))) // not already seeking something
			&& ((chance >= 255) || ((random() & 255) < chance)) // the random roll checks out
		)
		{
			for (let it = BlockThingsIterator.Create(self, distance); it.Next();)
			if (target != it.thing && target.isFriend(it.thing) && it.thing is "AetheriusMonsterZSC")
			{
				let healee = AetheriusMonsterZSC(it.thing);
				if (healtype == 0) maxhealth = healee.User_MaxHP; else maxhealth = healee.User_MaxHP*2;
				if (healee.health > 0 && healee.health < maxhealth)
				{
						tracer = it.thing;
						break;
				}
			}
		}
		A_SeekerMissile(threshold,maxturnangle,flags & ~SMF_LOOK,chance,distance);
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			if (!other.bFRIENDLY) return false;
		}
		// We don't really care about others making the check.
		return true;
	}

	override int SpecialMissileHit (Actor victim)
 	{
		AetheriusMonsterZSC healee;
		if (victim) healee = AetheriusMonsterZSC(victim);

 		if (healee == target) return 1;
 		if (healee && healee == tracer && !healee.bFRIENDLY) return 1;
		if (healee && healee.bFRIENDLY)
		{
			if (self.GetClassName() == "Heal1Shot")
			{
				if (healee.health > 0 && healee.health < healee.User_MaxHP)
				{
					healee.health += CallACS("Healing_Actor",0,1); 
					if (healee.health > healee.User_MaxHP) healee.health = healee.User_MaxHP;
					return -1;
				}
				else { return 1; }
			}

			if (self.GetClassName() == "Heal2Shot")
			{
				if (healee.health > 0 && healee.health < healee.User_MaxHP)
				{
					healee.health += CallACS("Healing_Actor",1,1);
					if (healee.health > healee.User_MaxHP) healee.health = healee.User_MaxHP;
					return -1;
				}
				else { return 1; }
			}

			if (self.GetClassName() == "Heal3Shot")
			{
				if (healee.health > 0 && healee.health < (healee.User_MaxHP*2))
				{
					healee.health += CallACS("Healing_Actor",2,1); 
					if (healee.health > (healee.User_MaxHP*2)) healee.health = (healee.User_MaxHP*2);
					return -1;
				}
				else { return 1; }
			}
		}

 		return -1;
 	}
}

// Converts Monsters to Friendlys [base for items like Monster Munchies]
class CharmMissile : AetheriusProjectileZSC
{
	override bool CanCollideWith(Actor other, bool passive)
	{
		AetheriusMonsterZSC DVDSActor;
		DVDSActor = AetheriusMonsterZSC(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			if (DVDSActor)
			{
				if (DVDSActor.bFRIENDLY)
					return false;
				else
					return true;
			}
			else
				return false;
		}
		// We don't really care about others making the check.
		return true;
	}

	override int SpecialMissileHit (Actor victim)
	{
		if (victim == target) return 1;
		if (victim == tracer && victim.bFRIENDLY) return 1;
		return -1;
	}
}

class AetheriusBaseLightning : AetheriusProjectileZSC
{
	Default
	{
		MissileType "LightningZap";
		AttackSound "MageLightningZap";
		ActiveSound "MageLightningContinuous";
		Obituary "$OB_MPMWEAPLIGHTNING";
		Mass 3;
		Stamina 1;
		Accuracy 1;
		ProjectileKickback 0;
	}
	
	override int SpecialMissileHit (Actor thing)
	{
		int dmg = self.mass * random(self.stamina,self.accuracy);

		if (thing.bShootable && thing != target)
		{
			if (thing.Mass < LARGE_MASS)
			{
				thing.Vel.X += Vel.X / 16;
				thing.Vel.Y += Vel.Y / 16;
			}
			if ((!thing.player && !thing.bBoss) || !(level.time&1))
			{
				thing.DamageMobj(self, target, dmg, 'Electric');
				A_StartSound(AttackSound, CHAN_WEAPON|CHAN_NOSTOP, CHANF_DEFAULT, 1);
				if (thing.bIsMonster && random[LightningHit]() < 64)
				{
					thing.Howl ();
				}
			}
			health--;
			if (health <= 0 || thing.health <= 0)
			{
				return 0;
			}
			if (bFloorHugger)
			{
				if (lastenemy && ! lastenemy.tracer)
				{
					lastenemy.tracer = thing;
				}
			}
			else if (!tracer)
			{
				tracer = thing;
			}
		}
		return 1; // lightning zaps through all sprites
	}
	
}

class AetheriusLightningTop : AetheriusBaseLightning
{
	const ZAGSPEED = 1;

	Default
	{
		Health 144;
		Speed 25;
		Radius 16;
		Height 40;
		Damage 8;
		Projectile;
		+CEILINGHUGGER
		RenderStyle "Add";
		ProjectileKickback 0;
	}

	States
	{
		Spawn:
			MLFX A 2 Bright A_LightningZap;
			MLFX BCD 2 Bright A_LightningClip;
			Loop;
		Death:
			MLF2 A 2 Bright A_LightningRemove;
			MLF2 BCDEKLM 3 Bright;
			ACLO E 35;
			MLF2 NO 3 Bright;
			MLF2 P 4 Bright;
			MLF2 QP 3 Bright;
			MLF2 Q 4 Bright;
			MLF2 P 3 Bright;
			MLF2 O 3 Bright;
			MLF2 P 3 Bright;
			MLF2 P 1 Bright A_HideThing;
			ACLO E 1050;
			Stop;
	}
	
	//============================================================================
	//
	// A_LightningClip
	//
	//============================================================================

	void A_LightningClip()
	{
		Actor cMo;
		Actor target = NULL;
		int zigZag;

		if (bFloorHugger)
		{
			if (lastenemy == NULL)
			{
				return;
			}
			SetZ(floorz);
			target = lastenemy.tracer;
		}
		else if (bCeilingHugger)
		{
			SetZ(ceilingz - Height);
			target = tracer;
		}
		if (bFloorHugger)
		{
			// floor lightning zig-zags, and forces the ceiling lightning to mimic
			cMo = lastenemy;
			zigZag = random[LightningClip]();
			if ((zigZag > 128 && special1 < 2) || special1 < -2)
			{
				Thrust(ZAGSPEED, angle + 90);
				if (cMo)
				{
					cMo.Thrust(ZAGSPEED, angle + 90);
				}
				special1++;
			}
			else
			{
				Thrust(ZAGSPEED,angle - 90);
				if (cMo)
				{
					cMo.Thrust(ZAGSPEED, angle - 90);
				}
				special1--;
			}
		}
		if (target)
		{
			if (target.health <= 0)
			{
				ExplodeMissile();
			}
			else
			{
				angle = AngleTo(target);
				VelFromAngle(Speed / 2);
			}
		}
	}


	//============================================================================
	//
	// A_LightningZap
	//
	//============================================================================

	void A_LightningZap(string MissileName = "LightningZap", int fusedrain = 8)
	{
		Class<Actor> lightning = MissileName;
		if (lightning == NULL) lightning = "LightningZap";

		A_LightningClip();

		health -= fusedrain;
		if (health <= 0)
		{
			SetStateLabel ("Death");
			return;
		}
		double deltaX = (random[LightningZap]() - 128) * radius / 256;
		double deltaY = (random[LightningZap]() - 128) * radius / 256;
		double deltaZ = (bFloorHugger) ? 10 : -10;

		Actor mo = Spawn(lightning, Vec3Offset(deltaX, deltaY, deltaZ), ALLOW_REPLACE);
		if (mo)
		{
			mo.lastenemy = self;
			mo.Vel.X = Vel.X;
			mo.Vel.Y = Vel.Y;
			mo.Vel.Z = (bFloorHugger) ? 20 : -20;
			mo.target = target;
		}
		if (bFloorHugger && random[LightningZap]() < 160)
		{
			A_StartSound(ActiveSound, CHAN_BODY);
		}
	}

	//============================================================================
	//
	// A_LightningRemove
	//
	//============================================================================

	void A_LightningRemove()
	{
		Actor mo = lastenemy;
		if (mo)
		{
			bNoTarget = true;	// tell A_ZapMimic that we are dead. The original code did a state pointer compare which is not safe.
			mo.lastenemy = NULL;
			mo.ExplodeMissile ();
		}
	}
	
}

class AetheriusLightningBottom : AetheriusLightningTop
{
	Default
	{
		-CEILINGHUGGER
		+FLOORHUGGER
		RenderStyle "Add";
		ProjectileKickback 0;
	}

	States
	{
	Spawn:
		MLFX E 2 Bright A_LightningZap;
		MLFX FGH 2 Bright A_LightningClip;
		Loop;
	Death:
		MLF2 F 2 Bright A_LightningRemove;
		MLF2 GHIJKLM 3 Bright;
		ACLO E 20;
		MLF2 NO 3 Bright;
		MLF2 P 4 Bright;
		MLF2 QP 3 Bright;
		MLF2 Q 4 Bright A_LastZap;
		MLF2 POP 3 Bright;
		MLF2 P 1 Bright A_HideThing;
		Goto Super::Death + 19;
	}
	
	//============================================================================
	//
	// A_LastZap
	//
	//============================================================================

	void A_LastZap(string MissileName = "LightningZap")
	{
		Class<Actor> lightning = MissileName;
		if (lightning == NULL) lightning = "LightningZap";
		
		Actor mo = Spawn(lightning, self.Pos, ALLOW_REPLACE);
		if (mo)
		{
			mo.SetStateLabel ("Death");
			mo.Vel.Z = 40;
			mo.SetDamage(0);
		}
	}
}

class AetheriusLightningZap : AetheriusProjectileZSC
{
	Default
	{
		Radius 15;
		Height 35;
		Damage 2;
		Projectile;
		-ACTIVATEIMPACT
		-ACTIVATEPCROSS
		RenderStyle "Add";
		Obituary "$OB_MPMWEAPLIGHTNING";
	}

	States
	{
		Spawn:
			MLFX IJKLM 2 Bright A_ZapMimic;
			Loop;
		Death:
			MLFX NOPQRSTU 2 Bright;
			Stop;
	}
	
	override int SpecialMissileHit (Actor thing)
	{
		Actor lmo;

		if (thing.bShootable && thing != target)
		{
			lmo = lastenemy;
			if (lmo)
			{
				if (lmo.bFloorHugger)
				{
					if (lmo.lastenemy && !lmo.lastenemy.tracer)
					{
						lmo.lastenemy.tracer = thing;
					}
				}
				else if (!lmo.tracer)
				{
					lmo.tracer = thing;
				}
				if (!(level.time&3))
				{
					lmo.health--;
				}
			}
		}
		return -1;
	}
	
	//============================================================================
	//
	// A_ZapMimic
	//
	//============================================================================

	void A_ZapMimic()
	{
		Actor mo = lastenemy;
		if (mo)
		{
			if (mo.bNoTarget)
			{
				ExplodeMissile ();
			}
			else
			{
				Vel.X = mo.Vel.X;
				Vel.Y = mo.Vel.Y;
			}
		}
	}
}

// Projectiles derived from this class should rip through actors,
// but not actually hit them more than once.
class SingleDamageRipper : AetheriusProjectileZSC
{
	default
	{
			Projectile;
			+RIPPER;
	}
	
	Array<Actor> ActorsAlreadyHit;
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		AetheriusPlayerPawn playpawn;
		AetheriusPlayerPawn playpawn2;
		AetheriusMonsterZSC DVDSActor;
		AetheriusMonsterZSC DVDSActor2;
		playpawn = AetheriusPlayerPawn(target);
		playpawn2 = AetheriusPlayerPawn(other);
		DVDSActor = AetheriusMonsterZSC(target);
		DVDSActor2 = AetheriusMonsterZSC(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer() > 0) return false;
					if (A_CheckFriendCollisionProjTypePlayer2() > 0) return false;
				}
			}
			else
			if (DVDSActor && DVDSActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1() > 0) return false;
				}
			}
			else 
			{
				if (GetClassName() == "HubbleBubbleSmall" || GetClassName() == "HubbleBubbleLarge") return false;
			}
		}
		// We don't really care about others making the check.

		for (let i = 0, size = ActorsAlreadyHit.Size(); i < size; i++)
				if (other == ActorsAlreadyHit[i])
						return false;
		
		return true;
	}
}

class SingleDamageFastRipper : AetheriusFastProjectileZSC
{
	default
	{
			Projectile;
			+RIPPER;
	}
	
	Array<Actor> ActorsAlreadyHit;
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		AetheriusPlayerPawn playpawn;
		AetheriusPlayerPawn playpawn2;
		AetheriusMonsterZSC DVDSActor;
		AetheriusMonsterZSC DVDSActor2;
		playpawn = AetheriusPlayerPawn(target);
		playpawn2 = AetheriusPlayerPawn(other);
		DVDSActor = AetheriusMonsterZSC(target);
		DVDSActor2 = AetheriusMonsterZSC(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer() > 0) return false;
					if (A_CheckFriendCollisionProjTypePlayer2() > 0) return false;
				}
			}
			else
			if (DVDSActor && DVDSActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1() > 0) return false;
				}
			}
			else 
			{
				if (GetClassName() == "HubbleBubbleSmall" || GetClassName() == "HubbleBubbleLarge") return false;
			}
		}
		// We don't really care about others making the check.

		for (let i = 0, size = ActorsAlreadyHit.Size(); i < size; i++)
				if (other == ActorsAlreadyHit[i])
						return false;
		
		return true;
	}
}

class SingleDamageEffectFastRipper : AetheriusEffectFastProjectile
{
	default
	{
		Projectile;
		+RIPPER;
		+HITMASTER;
	}
	
	void A_StatusEffectChecker(int basechance)
	{
		user_ailmentmaxchance = basechance;
		if (CountInv("EWShieldIdleMode",AAPTR_PLAYER1) > 0) user_ailmentmaxchance * 4;
		if (DivineAvatarTimer > 0) user_ailmentmaxchance * 4;

		user_canafflict = 1;
		if (master != null && master.health <= 0) user_canafflict = 0;
		if (CountInv("InvulnerabilitySpell",AAPTR_MASTER) > 0 || 
				CountInv("IsInvulnerable",AAPTR_MASTER) > 0 || 
				CountInv("MenuInvulnerability",AAPTR_MASTER) > 0 ||
				CountInv("EvadeAnAttack",AAPTR_MASTER) > 0 || 
				CountInv("PlayerDashing",AAPTR_MASTER) > 0) 
				{
					user_canafflict = 0;
				}

		AetheriusPlayerPawn playpawn;
		if (master) playpawn = AetheriusPlayerPawn(master);
		if (playpawn)
		{
			if (playpawn.player.cheats & CF_GODMODE2 || playpawn.player.cheats & CF_GODMODE) user_canafflict = 0;
		}
	}
}

class AetheriusFrostMissile : AetheriusDoomSpellZSC
{
	const SHARDSPAWN_LEFT	= 1;
	const SHARDSPAWN_RIGHT	= 2;
	const SHARDSPAWN_UP		= 4;
	const SHARDSPAWN_DOWN	= 8;
	
	Default
	{
		Speed 25;
		Radius 13;
		Height 8;
		Damage 1;
		DamageType "Ice";
		Projectile;
		DeathSound "MageShardsExplode";
		Obituary "$OB_MPMWEAPFROST";
	}

	States
	{
		Spawn:
			SHRD A 2 Bright;
			SHRD A 3 Bright A_ShedShard;
			SHRD B 3 Bright;
			SHRD C 3 Bright;
			Loop;
		Death:
			SHEX ABCDE 5 Bright;
			Stop;
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		AetheriusPlayerPawn playpawn;
		AetheriusPlayerPawn playpawn2;
		AetheriusMonsterZSC DVDSActor;
		AetheriusMonsterZSC DVDSActor2;
		playpawn = AetheriusPlayerPawn(target);
		playpawn2 = AetheriusPlayerPawn(other);
		DVDSActor = AetheriusMonsterZSC(target);
		DVDSActor2 = AetheriusMonsterZSC(other);

		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			// if fired by a player actor, check for friendliness from the passive actor
			if (playpawn) 
			{
				// Pass through different species of select types.
				if (other.bFRIENDLY == 1)
				{
					if (A_CheckFriendCollisionProjTypePlayer() > 0) return false;
					if (A_CheckFriendCollisionProjTypePlayer2() > 0) return false;
				}
			}
			else
			if (DVDSActor && DVDSActor.bFRIENDLY)
			{
				// Pass through different species of select types or players
				if (other.bFRIENDLY == 1 || playpawn2)
				{
					if (A_CheckFriendCollisionProjTypeFriendlyDoom() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHeretic() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyHexen() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyStrife() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendlyOthers() > 0) return false;
					else if (A_CheckFriendCollisionProjTypeFriendly1() > 0) return false;
				}
			}
			else 
			{
				if (GetClassName() == "HubbleBubbleSmall" || GetClassName() == "HubbleBubbleLarge") return false;
			}

			let checkedenemy = Actor(other);
			if (!checkedenemy.bICECORPSE == 0) return false; else return true; // Makes the ice projectiles move PAST the frozen monster to hit other monsters.
		}
		// We don't really care about others making the check.

		return true;
	}
	
	override int DoSpecialDamage (Actor victim, int damage, Name damagetype)
	{
		if (special2 > 0)
		{
			damage <<= special2;
		}
		return damage;
	}

	//============================================================================
	//
	// A_ShedShard
	//
	//============================================================================

	void A_ShedShard()
	{
		int spawndir = special1;
		int spermcount = special2;
		Actor mo;

		if (spermcount <= 0)
		{
			return;				// No sperm left
		}
		special2 = 0;
		spermcount--;

		// every so many calls, spawn a new missile in its set directions
		if (spawndir & SHARDSPAWN_LEFT)
		{
			mo = SpawnMissileAngleZSpeed(pos.z, "FrostMissile", angle + 5, 0, (20. + 2 * spermcount), target);
			if (mo)
			{
				mo.special1 = SHARDSPAWN_LEFT;
				mo.special2 = spermcount;
				mo.Vel.Z = Vel.Z;
				mo.args[0] = (spermcount==3)?2:0;
			}
		}
		if (spawndir & SHARDSPAWN_RIGHT)
		{
			mo = SpawnMissileAngleZSpeed(pos.z, "FrostMissile",	angle - 5, 0, (20. + 2 * spermcount), target);
			if (mo)
			{
				mo.special1 = SHARDSPAWN_RIGHT;
				mo.special2 = spermcount;
				mo.Vel.Z = Vel.Z;
				mo.args[0] = (spermcount==3)?2:0;
			}
		}
		if (spawndir & SHARDSPAWN_UP)
		{
			mo = SpawnMissileAngleZSpeed(pos.z + 8., "FrostMissile", angle, 0, (15. + 2 * spermcount), target);
			if (mo)
			{
				mo.Vel.Z = Vel.Z;
				if (spermcount & 1)			// Every other reproduction
					mo.special1 = SHARDSPAWN_UP | SHARDSPAWN_LEFT | SHARDSPAWN_RIGHT;
				else
					mo.special1 = SHARDSPAWN_UP;
				mo.special2 = spermcount;
				mo.args[0] = (spermcount==3)?2:0;
			}
		}
		if (spawndir & SHARDSPAWN_DOWN)
		{
			mo = SpawnMissileAngleZSpeed(pos.z - 4., "FrostMissile", angle, 0, (15. + 2 * spermcount), target);
			if (mo)
			{
				mo.Vel.Z = Vel.Z;
				if (spermcount & 1)			// Every other reproduction
					mo.special1 = SHARDSPAWN_DOWN | SHARDSPAWN_LEFT | SHARDSPAWN_RIGHT;
				else
					mo.special1 = SHARDSPAWN_DOWN;
				mo.special2 = spermcount;
				mo.target = target;
				mo.args[0] = (spermcount==3)?2:0;
			}
		}
	}
}

class AetheriusIceShard : AetheriusFrostMissile
{
	Default
	{
		DamageType "Ice";
		-ACTIVATEIMPACT
		-ACTIVATEPCROSS
	}
	States
	{
		Spawn:
			SHRD ABC 3 Bright;
			Loop;
	}
}

class CFlameMissileNew : AetheriusFastProjectileZSC
{
	Default
	{
		Speed 200;
		Radius 14;
		Height 8;
		Damage 8;
		DamageType "Fire";
		+INVISIBLE
		+ZDOOMTRANS
		RenderStyle "Add";
		Obituary "$OB_MPCWEAPFLAME";
	}
	
	States
	{
		Spawn:
			CFFX A 4 Bright;
			CFFX A 1 A_CFlamePuff;
			Goto Death + 1;
		Death:
			CFFX A 1 Bright A_CFlameMissile;
			CFFX ABC 3 Bright;
			CFFX D 4 Bright;
			CFFX E 3 Bright;
			CFFX F 4 Bright;
			CFFX G 3 Bright;
			CFFX H 4 Bright;
			CFFX I 3 Bright;
			CFFX J 4 Bright;
			CFFX K 3 Bright;
			CFFX L 4 Bright;
			CFFX M 3 Bright;
			Stop;
	}
	
	override void BeginPlay ()
	{
		special1 = 2;
	}

	override void Effect ()
	{
		if (!--special1)
		{
			special1 = 4;
			double newz = pos.z - 12;
			if (newz < floorz)
			{
				newz = floorz;
			}
			Actor mo = Spawn ("CFlameFloor", (pos.xy, newz), ALLOW_REPLACE);
			if (mo)
			{
				mo.angle = angle;
			}
		}
	}
	
	//============================================================================
	//
	// A_CFlamePuff
	//
	//============================================================================

	void A_CFlamePuff()
	{
		bInvisible = false;
		bMissile = false;
		Vel = (0,0,0);
		A_StartSound("ClericFlameExplode", CHAN_BODY);
	}

	//============================================================================
	//
	// A_CFlameMissile
	//
	//============================================================================

	void A_CFlameMissile(string actorname = "CircleFlame")
	{
		bInvisible = false;
		A_StartSound("ClericFlameExplode", CHAN_BODY);
		if (BlockingMobj && BlockingMobj.bShootable)
		{ // Hit something, so spawn the flame circle around the thing
			double dist = BlockingMobj.radius + 18;
			for (int i = 0; i < 4; i++)
			{
				double an = i*45.;
				Actor mo = Spawn (actorname, BlockingMobj.Vec3Angle(dist, an, 5), ALLOW_REPLACE);
				if (mo)
				{
					mo.angle = an;
					mo.target = target;
					mo.VelFromAngle(CircleFlame.FLAMESPEED);
					mo.specialf1 = mo.Vel.X;
					mo.specialf2 = mo.Vel.Y;
					mo.tics -= random[FlameMissile]()&3;
				}
				an += 180;
				mo = Spawn(actorname, BlockingMobj.Vec3Angle(dist, an, 5), ALLOW_REPLACE);
				if (mo)
				{
					mo.angle = an;
					mo.target = target;
					mo.VelFromAngle(-CircleFlame.FLAMESPEED);
					mo.specialf1 = mo.Vel.X;
					mo.specialf2 = mo.Vel.Y;
					mo.tics -= random[FlameMissile]()&3;
				}
			}
			SetState (SpawnState);
		}
	}
}

class CircleFlameNew : AetheriusProjectileZSC
{
	const FLAMESPEED = 0.45;
	const FLAMEROTSPEED = 2.;
	
	Default
	{
		Radius 6;
		Damage 2;
		DamageType "Fire";
		Projectile;
		-ACTIVATEIMPACT
		-ACTIVATEPCROSS
		+ZDOOMTRANS
		RenderStyle "Add";
		DeathSound "ClericFlameCircle";
		Obituary "$OB_MPCWEAPFLAME";
	}

	States
	{
		Spawn:
			CFCF A 4 Bright;
			CFCF B 2 Bright A_CFlameRotate;
			CFCF C 2 Bright;
			CFCF D 1 Bright;
			CFCF E 2 Bright;
			CFCF F 2 Bright A_CFlameRotate;
			CFCF G 1 Bright;
			CFCF HI 2 Bright;
			CFCF J 1 Bright A_CFlameRotate;
			CFCF K 2 Bright;
			CFCF LM 3 Bright;
			CFCF N 2 Bright A_CFlameRotate;
			CFCF O 3 Bright;
			CFCF P 2 Bright;
			Stop;
		Death:
			CFCF QR 3 Bright;
			CFCF S 3 Bright A_Explode(20, 20, 0);
			CFCF TUVWXYZ 3 Bright;
			Stop;
	}
	
	//============================================================================
	//
	// A_CFlameRotate
	//
	//============================================================================

	void A_CFlameRotate()
	{
		double an = Angle + 90.;
		VelFromAngle(FLAMEROTSPEED, an);
		Vel.XY += (specialf1, specialf2);
		Angle += 6;
	}
}

class BishopFXNew : AetheriusProjectileZSC
{
	Default
	{
		Radius 10;
		Height 6;
		Speed 10;
		Damage 1;
		Projectile;
		+SEEKERMISSILE
		-ACTIVATEIMPACT -ACTIVATEPCROSS
		+STRIFEDAMAGE +ZDOOMTRANS
		RenderStyle "Add";
		DeathSound "BishopMissileExplode";
	}
	States
	{
	Spawn:
		BPFX ABAB 1 Bright A_BishopMissileWeave;
		BPFX B 0 Bright A_SeekerMissile(2,3);
		Loop;
	Death:
		BPFX CDEF 4 Bright;
		BPFX GH 3 Bright;
		Stop;
	}
}

class BlasterFX1Base : AetheriusFastProjectileZSC
{
	Default
	{
		Radius 12;
		Height 8;
		Speed 184;
		Damage 2;
		SeeSound "weapons/blastershoot";
		DeathSound "weapons/blasterhit";
		+SPAWNSOUNDSOURCE
		Obituary "$OB_MPPBLASTER";
	}

	States
	{
		Spawn:
			ACLO E 200;
			Loop;
		Death:
			FX18 A 3 BRIGHT A_SpawnRippers;
			FX18 B 3 BRIGHT;
			FX18 CDEFG 4 BRIGHT;
			Stop;
	}
	
	//----------------------------------------------------------------------------
	//
	// 
	//
	//----------------------------------------------------------------------------

	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		string nm, nn, no, np;
		nm = "IronLichNew";
		nn = "IceLich";
		no = "Goldlich";
		np = "BloodLich";
		if (target is "Ironlich" || target is nm || target is nn || target is no || target is np)
		{ // Less damage to Ironlich bosses
			damage /= 16; // random[BlasterFX]() & 1;
			if (!damage)
			{
				return -1;
			}
		}
		return damage;
	}

	override void Effect ()
	{
		if (random[BlasterFX]() < 64)
		{
			Spawn("BlasterSmoke", (pos.xy, max(pos.z - 8, floorz)), ALLOW_REPLACE);
		}
	}

	//----------------------------------------------------------------------------
	//
	// PROC A_SpawnRippers
	//
	//----------------------------------------------------------------------------

	void A_SpawnRippers(string atktype = "Ripper", int numshots = 8, double circ = 360.0)
	{
		numshots += ((WandMastPerkLvl / 2) + WandMastEXPerkLvl);

		for(int i = 0; i < numshots; i++)
		{
			Actor ripper = Spawn(atktype, pos, ALLOW_REPLACE);
			if (ripper != null)
			{
				ripper.target = target;
				ripper.angle = i*(circ/numshots);
				ripper.VelFromAngle();
				ripper.CheckMissileSpawn (radius);
			}
		}
	}
}

class RipperBase : AetheriusProjectileZSC
{
	Default
	{
		Radius 8;
		Height 6;
		Speed 14;
		Damage 1;
		Projectile;
		+RIPPER
		DeathSound "weapons/blasterpowhit";
		Obituary "$OB_MPPBLASTER";
	}

	States
	{
		Spawn:
			FX18 M 4;
			FX18 N 5;
			Loop;
		Death:
			FX18 OPQRS 4 BRIGHT;
			Stop;
	}
	
	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		string nm, nn, no, np;
		nm = "IronLichNew";
		nn = "IceLich";
		no = "Goldlich";
		np = "BloodLich";
		if (target is "Ironlich" || target is nm || target is nn || target is no || target is np)
		{ // Less damage to Ironlich bosses
			damage /= 8; // random[Ripper]() & 1;
			if (!damage)
			{
				return -1;
			}
		}
		return damage;
	}
	
}

// Horn Rod FX 2 ------------------------------------------------------------
class HornRodFX2Base : AetheriusProjectileZSC
{
	Default
	{
		Radius 12;
		Height 8;
		Speed 22;
		Damage 10;
		Health 140;
		Projectile;
		RenderStyle "Add";
		SeeSound "weapons/hornrodpowshoot";
		DeathSound "weapons/hornrodpowhit";
		Obituary "$OB_MPPSKULLROD";
	}

	States
	{
		Spawn:	
			FX00 C 3 BRIGHT;
			FX00 D 3 BRIGHT A_SeekerMissile(10, 30);
			FX00 E 3 BRIGHT;
			FX00 F 3 BRIGHT A_SeekerMissile(10, 30);
			Loop;
		Death:
			FX00 H 5 BRIGHT A_AddPlayerRain;
			FX00 I 5 BRIGHT;
			FX00 J 4 BRIGHT;
			FX00 KLM 3 BRIGHT;
			FX00 G 1 A_HideInCeiling;
			FX00 G 1 A_SkullRodStorm;
			Wait;
	}
	
	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		int RandCall;

		string nm, nn, no, np;

		AetheriusMonsterZSC s2; 
		s2 = AetheriusMonsterZSC(target);
		
		string s2name;

		if (s2 != null)
		{
			s2name = s2.GetClassName();
			nm = "DSparilUnmountedNew";

			if (s2name == nm)
			{
				// D'Sparil teleports away
				if (WandMastPerkLvl <= 0) RandCall = 96;
				if (WandMastPerkLvl == 1) RandCall = 92;
				if (WandMastPerkLvl == 2) RandCall = 86;
				if (WandMastPerkLvl == 3) RandCall = 78;
				if (WandMastPerkLvl == 4) RandCall = 68;
				if (WandMastPerkLvl >= 5) RandCall = 56;

				if (random[HornRodFX2]() <= RandCall)
				{
					s2.DSparilTeleport();
					return -1;
				}
				return damage;
			}
			return damage;
		}

		return damage;
	}
	
	//----------------------------------------------------------------------------
	//
	// PROC A_AddPlayerRain
	//
	//----------------------------------------------------------------------------

	void A_AddPlayerRain()
	{
		RainTracker tracker;

		if (target == null || target.health <= 0)
		{
			// Shooter is dead or nonexistant
			return;
		}

		tracker = RainTracker(target.FindInventory("RainTracker"));

		// They player is only allowed two rainstorms at a time. Shooting more
		// than that will cause the oldest one to terminate.
		if (tracker != null)
		{
			if (tracker.Rain1 && tracker.Rain2)
			{
				// Terminate an active rain
				if (tracker.Rain1.health < tracker.Rain2.health)
				{
					tracker.Rain1.health = clamp(tracker.Rain1.health, tracker.Rain1.health, 16);
					tracker.Rain1 = null;
				}
				else
				{
					tracker.Rain2.health = clamp(tracker.Rain2.health, tracker.Rain2.health, 16);
					tracker.Rain2 = null;
				}
			}
		}
		else
		{
			tracker = RainTracker(target.GiveInventoryType("RainTracker"));
		}
		// Add rain mobj to list
		if (tracker.Rain1)
		{
			tracker.Rain2 = self;
		}
		else
		{
			tracker.Rain1 = self;
		}
		ActiveSound = "misc/rain";
	}
	
	//----------------------------------------------------------------------------
	//
	// PROC A_HideInCeiling
	//
	//----------------------------------------------------------------------------

	void A_HideInCeiling()
	{
		// This no longer hides in the ceiling. It just makes the actor invisible and keeps it in place.
		// We need its actual position to determine the correct ceiling height in A_SkullRodStorm.
		bInvisible = true;
		bSolid = false;
		bMissile = false;
		Vel = (0,0,0);
	}
	
	//----------------------------------------------------------------------------
	//
	// PROC A_SkullRodStorm [CUSTOMIZED for Aetherius Acid Rain stuff] :V
	//
	//----------------------------------------------------------------------------
	void A_AcidRainDrop(Class<Actor> missiletype, int xradius = 64, int yradius = 64)
	{
		static const Name translations[] =
		{
			"RainPillar1", "RainPillar2", "RainPillar3", "RainPillar4",
			"RainPillar5", "RainPillar6", "RainPillar7", "RainPillar8"
		};

		double xo = random(-xradius,xradius); // ((Random[SkullRodStorm]() & 127) - 64);
		double yo = random(-yradius,yradius); // ((Random[SkullRodStorm]() & 127) - 64);
		Vector3 spawnpos = Vec2OffsetZ(xo, yo, pos.z);
		Actor mo = Spawn(missiletype, spawnpos, ALLOW_REPLACE);
		if (!mo) return;
		
		// Find the ceiling above the spawn location. This may come from 3D floors but will not reach through portals.
		// (should probably be fixed for portals, too.)
		double newz = mo.CurSector.NextHighestCeilingAt(mo.pos.x, mo.pos.y, mo.pos.z, mo.pos.z, FFCF_NOPORTALS) - mo.height;
		mo.SetZ(newz);
    
		if (multiplayer && target.player)
		{
			mo.A_SetTranslation(translations[target.PlayerNumber()]);
		}
		mo.target = target;
		mo.Vel.X = MinVel; // Force collision detection
		mo.Vel.Z = -mo.Speed;
		mo.CheckMissileSpawn (radius);
		if (ActiveSound > 0) A_StartSound(ActiveSound, CHAN_BODY, CHANF_DEFAULT, 1);
	}

	void A_SkullRodStorm(Class<Actor> missiletype = "RainPillar", 
			int xradius =             64,	int yradius =             64, 
			int rainspawnchance1 =   231,	int rainspawnchance2 =    16,	int rainspawnchance3 =     0,	int rainspawnchance4 =     0, 
			int rainspawnchance5 =     0,	int rainspawnchance6 =     0,	int rainspawnchance7 =     0,	int rainspawnchance8 =     0, 
			int rainspawnchance9 =     0,	int rainspawnchance10 =    0,	int rainspawnchance11 =    0,	int rainspawnchance12 =    0, 
			int rainspawnchance13 =    0,	int rainspawnchance14 =    0,	int rainspawnchance15 =    0,	int rainspawnchance16 =    0)
	{
		if (health-- == 0)
		{
			A_StopSound (CHAN_BODY);
			if (target == null)
			{
				// Player left the game
				Destroy ();
				return;
			}
			RainTracker tracker = RainTracker(target.FindInventory("RainTracker"));
			if (tracker != null)
			{
				if (tracker.Rain1 == self)
				{
					tracker.Rain1 = null;
				}
				else if (tracker.Rain2 == self)
				{
					tracker.Rain2 = null;
				}
			}
			Destroy ();
			return;
		}
		if (Random[SkullRodStorm](1,256) <= rainspawnchance1) A_AcidRainDrop(missiletype,xradius,yradius);
		if (Random[SkullRodStorm](1,256) <= rainspawnchance2) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance3) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance4) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance5) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance6) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance7) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance8) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance9) A_AcidRainDrop(missiletype,xradius,yradius);
		if (Random[SkullRodStorm](1,256) <= rainspawnchance10) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance11) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance12) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance13) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance14) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance15) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance16) A_AcidRainDrop(missiletype,xradius,yradius); 
	}
}

class RainPillarBase : AetheriusProjectileZSC
{
	Default
	{
		Radius 5;
		Height 12;
		Speed 12;
		Damage 5;
		Mass 5;
		Projectile;
		-ACTIVATEPCROSS
		-ACTIVATEIMPACT
		+ZDOOMTRANS
		RenderStyle "Add";
		Obituary "$OB_MPPSKULLROD";
	}

	States
	{
		Spawn:
			FX22 A -1 BRIGHT;
			Stop;
		Death:
			FX22 B 4 BRIGHT A_RainImpact;
			FX22 CDEF 4 BRIGHT;
			Stop;
		NotFloor:
			FX22 GHI 4 BRIGHT;
			Stop;
	}
	
	//----------------------------------------------------------------------------
	//
	// PROC A_RainImpact
	//
	//----------------------------------------------------------------------------

	void A_RainImpact()
	{
		if (pos.z > floorz)
		{
			SetStateLabel("NotFloor");
		}
		else if (random[RainImpact]() < 40)
		{
			HitFloor ();
		}
	}

	// Rain pillar 1 ------------------------------------------------------------

	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		if (target.bBoss)
		{ // Decrease damage for bosses
			damage /= random(4,5); // damage = random[RainDamage](1, 8);
		}
		return damage;
	}
}

class PhoenixFX1Base : AetheriusProjectileZSC
{
	Default
	{
		Radius 11;
		Height 8;
		Speed 20;
		Damage 20;
		DamageType "Fire";
		Projectile;
		+THRUGHOST
		+SPECIALFIREDAMAGE
		SeeSound "weapons/phoenixshoot";
		DeathSound "weapons/phoenixhit";
		Obituary "$OB_MPPHOENIXROD";
	}

	States
	{
		Spawn:
			FX04 A 4 BRIGHT A_PhoenixPuff;
			Loop;
		Death:
			FX08 A 6 BRIGHT A_Explode;
			FX08 BC 5 BRIGHT;
			FX08 DEFGH 4 BRIGHT;
			Stop;
	}
	
	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		int RandCall;

		string nm, nn, no, np;

		AetheriusMonsterZSC s2; 
		s2 = AetheriusMonsterZSC(target);
		
		string s2name;

		if (s2 != null)
		{
			s2name = s2.GetClassName();
			nm = "DSparilUnmountedNew";

			if (s2name == nm)
			{
				// D'Sparil teleports away
				if (WandMastPerkLvl <= 0) RandCall = 96;
				if (WandMastPerkLvl == 1) RandCall = 92;
				if (WandMastPerkLvl == 2) RandCall = 86;
				if (WandMastPerkLvl == 3) RandCall = 78;
				if (WandMastPerkLvl == 4) RandCall = 68;
				if (WandMastPerkLvl >= 5) RandCall = 56;

				if (random[HornRodFX2]() <= RandCall)
				{
					s2.DSparilTeleport();
					return -1;
				}
				return damage;
			}
			return damage;
		}
		return damage;
	}

	//----------------------------------------------------------------------------
	//
	// PROC A_PhoenixPuff
	//
	//----------------------------------------------------------------------------

	void A_PhoenixPuff(string missiletype = "PhoenixPuff", double anglediff = 90.0, double puffspeed = 1.3)
	{
		//[RH] Heretic never sets the target for seeking
		//P_SeekerMissile (self, 5, 10);
		Actor puff = Spawn(missiletype, Pos, ALLOW_REPLACE);
		if (puff != null)
		{
			puff.Vel.XY = AngleToVector(Angle + anglediff, puffspeed);
		}

		puff = Spawn(missiletype, Pos, ALLOW_REPLACE);
		if (puff != null)
		{
			puff.Vel.XY = AngleToVector(Angle - anglediff, puffspeed);
		}
	}
}

class PhoenixFX2Base : AetheriusProjectileZSC
{
	Default
	{
		Radius 6;
		Height 8;
		Speed 10;
		Damage 2;
		DamageType "Fire";
		Projectile;
		RenderStyle "Add";
		+ZDOOMTRANS
		Obituary "$OB_MPPPHOENIXROD";
	}

	States
	{
		Spawn:
			FX09 ABABA 2 BRIGHT;
			FX09 B 2 BRIGHT A_FlameEnd;
			FX09 CDEF 2 BRIGHT;
			Stop;
		Death:
			FX09 G 3 BRIGHT;
			FX09 H 3 BRIGHT A_FloatPuff;
			FX09 I 4 BRIGHT;
			FX09 JK 5 BRIGHT;
			Stop;
	}
	

	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		if (target.player && Random[PhoenixFX2]() < 128)
		{ // Freeze player for a bit
			target.reactiontime += 4;
		}
		return damage;
	}
	
	//----------------------------------------------------------------------------
	//
	// PROC A_FlameEnd
	//
	//----------------------------------------------------------------------------

	void A_FlameEnd()
	{
		Vel.Z += 1.5;
	}

	//----------------------------------------------------------------------------
	//
	// PROC A_FloatPuff
	//
	//----------------------------------------------------------------------------

	void A_FloatPuff()
	{
		Vel.Z += 1.8;
	}
}

class MaceFX1Base : AetheriusProjectileZSC
{
	const MAGIC_JUNK = 1234;
	
	Default
	{
		Radius 8;
		Height 6;
		Speed 20;
		Damage 2;
		Projectile;
		+THRUGHOST
		BounceType "HereticCompat";
		SeeSound "weapons/maceshoot";
		Obituary "$OB_MPMACE";
	}

	States
	{
		Spawn:
			FX02 AB 4 A_MacePL1Check;
			Loop;
		Death:
			FX02 F 4 BRIGHT A_MaceBallImpact;
			FX02 GHIJ 4 BRIGHT;
			Stop;
	}
	
	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		int olddmg = damage;
		AetheriusMonsterZSC DVDSActor; DVDSActor = AetheriusMonsterZSC(target);
		if (DVDSActor && DVDSActor.user_legendaryevolved) damage *= MACELDLDMGMULTI;
		if (dvdsdebug_actordmgdisplays) Console.Printf("    (\czProjectile Damage Output [DoSpecialDamage]\c-: \cxolddmg = %d\c-, \cydmg = %d\c-)", olddmg, damage);
		return damage;
	}

	//----------------------------------------------------------------------------
	//
	// PROC A_MacePL1Check
	//
	//----------------------------------------------------------------------------

	void A_MacePL1Check()
	{
		if (special1 == 0) return;
		special1 -= 4;
		if (special1 > 0) return;
		special1 = 0;
		bNoGravity = false;
		Gravity = 1. / 8;
		// [RH] Avoid some precision loss by scaling the velocity directly
		double velscale = 7 / Vel.XY.Length();
		Vel.XY *= velscale;
		Vel.Z *= 0.5;
	}

	//----------------------------------------------------------------------------
	//
	// PROC A_MaceBallImpact
	//
	//----------------------------------------------------------------------------

	void A_MaceBallImpact()
	{
		if ((health != MAGIC_JUNK) && bInFloat)
		{ // Bounce
			health = MAGIC_JUNK;
			Vel.Z *= 0.75;
			bBounceOnFloors = bBounceOnCeilings = false;
			SetState (SpawnState);
			A_StartSound("weapons/macebounce", CHAN_BODY);
		}
		else
		{ // Explode
			Vel = (0,0,0);
			bNoGravity = true;
			Gravity = 1;
			A_StartSound("weapons/macehit", CHAN_BODY);
		}
	}
}

class MaceFX2Base : MaceFX1Base
{
	Default
	{
		Speed 10;
		Damage 6;
		Gravity 0.125;
		-NOGRAVITY
		SeeSound "";
	}

	States
	{
		Spawn:
			FX02 CD 4;
			Loop;
		Death:
			FX02 F 4 A_MaceBallImpact2;
			goto Super::Death+1;
	}
	
	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		int olddmg = damage;
		AetheriusMonsterZSC DVDSActor; DVDSActor = AetheriusMonsterZSC(target);
		if (DVDSActor && DVDSActor.user_legendaryevolved) damage *= MACELDLDMGMULTI;
		if (dvdsdebug_actordmgdisplays) Console.Printf("    (\czProjectile Damage Output [DoSpecialDamage]\c-: \cxolddmg = %d\c-, \cydmg = %d\c-)", olddmg, damage);
		return damage;
	}

	//----------------------------------------------------------------------------
	//
	// PROC A_MaceBallImpact2
	//
	//----------------------------------------------------------------------------

	void A_MaceBallImpact2()
	{
		if ((pos.Z <= floorz) && HitFloor ())
		{ // Landed in some sort of liquid
			Destroy ();
			return;
		}
		if (bInFloat)
		{
			if (Vel.Z >= 2)
			{
				// Bounce
				Vel.Z *= 0.75;
				SetState (SpawnState);

				Actor tiny = Spawn("MaceFX3", Pos, ALLOW_REPLACE);
				if (tiny != null)
				{
					tiny.target = target;
					tiny.angle = angle + 90.;
					tiny.VelFromAngle(Vel.Z - 1.);
					tiny.Vel += (Vel.XY * 0.5, Vel.Z);
					tiny.CheckMissileSpawn (radius);
				}

				tiny = Spawn("MaceFX3", Pos, ALLOW_REPLACE);
				if (tiny != null)
				{
					tiny.target = target;
					tiny.angle = angle - 90.;
					tiny.VelFromAngle(Vel.Z - 1.);
					tiny.Vel += (Vel.XY * 0.5, Vel.Z);
					tiny.CheckMissileSpawn (radius);
				}
				return;
			}
		}
		Vel = (0,0,0);
		bNoGravity = true;
		bBounceOnFloors = bBounceOnCeilings = false;
		Gravity = 1;
	}
}

class MaceFX3Base : MaceFX1Base
{
	Default
	{
		Speed 7;
		Damage 4;
		-NOGRAVITY;
		Gravity 0.125;
	}

	States
	{
		Spawn:
			FX02 AB 4;
			Loop;
	}

	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		int olddmg = damage;
		AetheriusMonsterZSC DVDSActor; DVDSActor = AetheriusMonsterZSC(target);
		if (DVDSActor && DVDSActor.user_legendaryevolved) damage *= MACELDLDMGMULTI;
		if (dvdsdebug_actordmgdisplays) Console.Printf("    (\czProjectile Damage Output [DoSpecialDamage]\c-: \cxolddmg = %d\c-, \cydmg = %d\c-)", olddmg, damage);
		return damage;
	}
}

class MaceFX4Base : AetheriusProjectileZSC
{
	Default
	{
		Radius 8;
		Height 6;
		Speed 7;
		Damage 18;
		Gravity 0.125;
		Projectile;
		-NOGRAVITY
		+TELESTOMP
		+THRUGHOST
		-NOTELEPORT
		BounceType "HereticCompat";
		SeeSound "";
		Obituary "$OB_MPPMACE";
	}

	States
	{
		Spawn:
			FX02 E 99;
			Loop;
		Death:
			TNT1 A 0 
			{
				A_Quake(1, 4, 0, 512, "");
				A_Quake(4, 4, 0, 256, "");
			}
			FX02 C 4 A_DeathBallImpact;
			FX02 GHIJ 4 BRIGHT;
			Stop;
	}
	
	//---------------------------------------------------------------------------
	//
	// FUNC P_AutoUseChaosDevice
	//
	//---------------------------------------------------------------------------

	private bool AutoUseChaosDevice (PlayerInfo player)
	{
		Inventory arti = player.mo.FindInventory("ArtiTeleport");

		if (arti != null)
		{
			player.mo.UseInventory (arti);
			player.health = player.mo.health = (player.health+1)/2;
			return true;
		}
		return false;
	}
	
	//----------------------------------------------------------------------------
	//
	// PROC DoSpecialDamage
	//
	//----------------------------------------------------------------------------

	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		int olddmg = damage;
		AetheriusMonsterZSC DVDSActor; DVDSActor = AetheriusMonsterZSC(target);

		int legendarycheck = 0;
		int monstermaxhp;
		if (DVDSActor) monstermaxhp = DVDSActor.user_MaxHP * 10; else monstermaxhp = SpawnHealth() * 10;
		if (DVDSActor && DVDSActor.user_legendaryevolved) legendarycheck = 1;

		if (target.bBoss || target.bDontSquash || legendarycheck || target.IsTeammate (self.target))
		{ // Don't allow cheap boss kills and don't instagib teammates
			if (legendarycheck) damage *= MACELDLDMGMULTI;
			if (dvdsdebug_actordmgdisplays) Console.Printf("    (\czProjectile Damage Output [DoSpecialDamage]\c-: \cxolddmg = %d\c-, \cydmg = %d\c-)", olddmg, damage);
			return damage;
		}
		else if (target.player)
		{ // Player specific checks
			if (target.player.mo.bInvulnerable)
			{ // Can't hurt invulnerable players
				return -1;
			}
			if (AutoUseChaosDevice (target.player))
			{ // Player was saved using chaos device
				return -1;
			}
		}
		damage = monstermaxhp;
		if (dvdsdebug_actordmgdisplays) Console.Printf("    (\czProjectile Damage Output [DoSpecialDamage]\c-: \cxolddmg = %d\c-, \cydmg = %d\c-)", olddmg, damage);
		return damage; // Something's probably gonna die
	}

	//----------------------------------------------------------------------------
	//
	// PROC A_DeathBallImpact
	//
	//----------------------------------------------------------------------------

	void A_DeathBallImpact()
	{
		FTranslatedLineTarget t;

		if ((pos.Z <= floorz) && HitFloor ())
		{ // Landed in some sort of liquid
			Destroy ();
			return;
		}
		if (bInFloat)
		{
			if (Vel.Z >= 2)
			{
				// Bounce
				bool newAngle = false;
				double ang = 0;
				if (tracer)
				{
					if (!tracer.bShootable)
					{ // Target died
						tracer = null;
					}
					else
					{ // Seek
						ang = AngleTo(tracer);
						newAngle = true;
					}
				}
				else
				{ // Find new target
					ang = 0.;
					for (int i = 0; i < 32; i++)
					{
						AimLineAttack (ang, 1280., t, 0., ALF_NOFRIENDS|ALF_PORTALRESTRICT, null, target);
						if (t.linetarget && target != t.linetarget)
						{
							tracer = t.linetarget;
							ang = t.angleFromSource;
							newAngle = true;
							break;
						}
						ang += 11.25;
					}
				}
				if (newAngle)
				{
					angle = ang;
					VelFromAngle();
				}
				SetState (SpawnState);
				A_StartSound("weapons/macestop", CHAN_BODY);
				return;
			}
		}
		Vel = (0,0,0);
		bNoGravity = true;
		Gravity = 1;
		A_StartSound("weapons/maceexplode", CHAN_BODY);
	}
}

class LoreShotBase : AetheriusProjectileZSC
{
	Default
	{
		Speed 20;
		Height 14;
		Radius 10;
		Projectile;
		+STRIFEDAMAGE
		Damage 2;
		MaxStepHeight 4;
		SeeSound "loremaster/chain";
		ActiveSound "loremaster/swish";
	}

	States
	{
	Spawn:
		OCLW A 2 A_LoremasterChain;
		Loop;
	Death:
		OCLW A 6;
		Stop;
	}
	
	override int DoSpecialDamage (Actor victim, int damage, Name damagetype)
	{
		if (victim != NULL && target != NULL && !victim.bDontThrust)
		{
			Vector3 thrust = victim.Vec3To(target);
			victim.Vel += thrust.Unit() * (255. * 50 / max(victim.Mass, 1));
		}
		return damage;
	}

	void A_LoremasterChain ()
	{
		A_StartSound("loremaster/active", CHAN_BODY);
		Spawn("LoreShot2", Pos, ALLOW_REPLACE);
		Spawn("LoreShot2", Vec3Offset(-Vel.x/2., -Vel.y/2., -Vel.z/2.), ALLOW_REPLACE);
		Spawn("LoreShot2", Vec3Offset(-Vel.x, -Vel.y, -Vel.z), ALLOW_REPLACE);
	}
	
}

class GravityHPBall : AetheriusFastProjectileZSC
{
	default
	{
		Damage (0);
		+MISSILE
		+PAINLESS
		+NODAMAGETHRUST
		+CANNOTPUSH
		+NOTIMEFREEZE
		+FOILINVUL
		RenderStyle "Add";
		Alpha 0.0;
		Speed 511;
		Radius 1;
		Height 1;
		FastSpeed 511;
		SeeSound "null";
		DeathSound "null";
	}

	override int SpecialMissileHit (Actor victim)
 	{
		int TrueGameSkill = dvds_gendifficultycurve + Skill;
		double GravityEffectFactor, FinalGravityFactor;
		int PropertyValue;
		int LevelFactor;
		double EffectChance;
		string vict;

		AetheriusMonsterZSC svictim;
		if (victim) svictim = AetheriusMonsterZSC(victim);

		if (svictim && svictim.bISMONSTER)
		{
			vict = svictim.GetClassName();
			if (vict == "PracticeTarget" || vict == "PracticeTarget2") EffectChance = 0;
			else if (vict == "ProgrammerNew" || vict == "StrifeBishopNew" || vict == "OracleNew" || vict == "Macil1New" || vict == "LoremasterNew" ||
							 vict == "AlienSpectre1New" || vict == "AlienSpectre2New" || vict == "AlienSpectre3New" || vict == "AlienSpectre4New" || vict == "AlienSpectre5New" ||
							 vict == "EntityBossNew" || vict == "EntitySecondNew" || vict == "EntityAscended") EffectChance = 0;
			else if (vict == "SirenNightmareNew" || vict == "CeilingTurretNew") EffectChance = 0;
			else if (vict == "ThamuzNew" || vict == "TchernobogNew") EffectChance = 0.03125;
			else if (vict == "DSparilMountedNew" || vict == "DSparilUnmountedNew" || vict == "KoraxNew" || vict == "Zakachi") EffectChance = 1;
			else if (vict == "Daedabus") EffectChance = 8;
			else if (vict == "Macil2New") EffectChance = 8;
			else if (vict == "HeresiarchNew" || vict == "ClericBossNew" || vict == "FighterBossNew" || vict == "FighterBossNew") EffectChance = 16;
			else if (vict == "VampireDVDS" || vict == "ReaverNew" || vict == "CrusaderNew" || vict == "SentinelNew" || vict == "OStalkerNew") EffectChance = 32;
			else if (vict == "Bormereth" || vict == "DragonNew") EffectChance = 64;
			else if (vict == "MaulotaurNew" || vict == "TNTSpider") EffectChance = 85;
			else if (vict == "Hierophant" || vict == "TemplarNew") EffectChance = 128;
			else EffectChance = 256;
			
			double roll = frandom(0.1,256.0);
			//Console.Printf("    (\czINFO:\c- \Roll vs EffectChance [%s]\c-: \cy%.8f vs %.8f\c-)", vict, roll, EffectChance);
			if (frandom(0.1,256.0) <= EffectChance)
			{
				//Console.Printf("    (\czINFO:\c- \EffectChance Successful!\c-)");
				if (TrueGameSkill <= SKILL_VERY_EASY) GravityEffectFactor = 0.125;  
				if (TrueGameSkill == SKILL_EASY) GravityEffectFactor = 0.250;  
				if (TrueGameSkill == SKILL_NORMAL) GravityEffectFactor = 0.500;  
				if (TrueGameSkill == SKILL_HARD) GravityEffectFactor = 0.750;  
				if (TrueGameSkill == SKILL_VERY_HARD) GravityEffectFactor = 0.875;  
				if (TrueGameSkill == SKILL_EXTREME) GravityEffectFactor = 0.900;  
				if (TrueGameSkill == SKILL_HORRIBLE) GravityEffectFactor = 0.925;  
				if (TrueGameSkill == SKILL_IMPOSSIBLE) GravityEffectFactor = 0.950;  
				if (TrueGameSkill >= SKILL_OMEGA) GravityEffectFactor = 0.980;
				
				LevelFactor = 512 - svictim.user_monsterlevel;
				GravityEffectFactor = GravityEffectFactor * LevelFactor / 512;
				
				FinalGravityFactor = 1.000 - GravityEffectFactor;
				GravityEffectFactor = clamp(GravityEffectFactor, 0.000, GravityEffectFactor);
				if (GravityEffectFactor > 0.000)
				{
					PropertyValue = svictim.health;
					PropertyValue = PropertyValue * FinalGravityFactor;
				
					PropertyValue = clamp(PropertyValue, 1, PropertyValue);
					svictim.health = PropertyValue;
					svictim.A_StartSound("diabloistgravityend");
					svictim.A_SpawnItem("DiabloistGravityHPTargeter");
				}
				else
				{
					svictim.A_StartSound("diabloistgravitymiss");
				}
			}
			else
			{
				svictim.A_StartSound("diabloistgravitymiss");
			}
		}
		return -1;
	}

	States
	{
		Spawn:
			TNT1 A 0;
			TNT1 A 1 A_SeekerMissile(360,90,SMF_LOOK|SMF_PRECISE|SMF_CURSPEED,256,64);
			loop;
		Death:
			TNT1 A 0;
			stop;
	}
}

class BaseWandMissile : SingleDamageFastRipper
{
	bool wandmissleeraseproj;
	double properangle;
	double properpitch;
	int setpitch;
	int setpitch2;

	void A_WandMissileGuard()
	{
		double xpos;
		double zpos;
		setpitch2 = setpitch % 2;
		//Console.Printf("%d, %d", setpitch, setpitch2);
		if (!setpitch) { angle = properangle; pitch += properpitch; }
		setpitch++;
		if (setpitch > 1)
		{
			if (!(CountInv("AetheriusTimeFreezer",AAPTR_PLAYER1) || CountInv("AetheriusTimeFreezerMenu",AAPTR_PLAYER1) || isFrozen()))
			{
				double newradius = 8.0 * (1.0 + (0.2 * WandMastPerkLvl));
				double ahead = -184.0 - (newradius * 2); // 184 speed

				int maxgoes = ((-ahead)) / (newradius * 2);
				if (dvdsdebug_shieldactorghosts) Console.Printf("maxgoes: %d, newradius: %.2f", maxgoes, newradius);

				for (int i; i < maxgoes; i++)
				{
					ahead += (newradius * 2);
					xpos = 0 + (cos(pitch) * (0 + ahead));
					zpos = 4 - (sin(pitch) * (0 + ahead));
					A_SpawnItemEx("MageWandGuard",xpos,0,zpos,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH);
					if (dvdsdebug_shieldactorghosts) Console.Printf("i: %d, angle: %.8f, pitch: %.8f, ahead: %.8f, xpos: %.8f, zpos: %.8f", i, angle, pitch, ahead, xpos, zpos);
				}
			}
		}
	}
	
	override void PostBeginPlay()
	{
		properangle = (angle % 360);
		properpitch = pitch;
		if (dvdsdebug_shieldactorghosts) Console.Printf("(PBP) Angle: %.8f, Pitch: %.8f", properangle, properpitch);
		if (wandmissleeraseproj) 
		{
			A_StartSound("MageWandFireSpecial", 9, CHANF_DEFAULT, frandom(1.125,1.375));
		}
		Super.PostBeginPlay();
	}

	override void Die(Actor source, Actor inflictor, int dmgflags)
	{
		if (wandmissleeraseproj) A_WandMissileGuard();
		Super.Die(source, inflictor, dmgflags);
	}

	override void Tick()
	{
		if (wandmissleeraseproj) A_WandMissileGuard();
		Super.Tick();
	}
}

class BaseDiarisHolyArrow : SingleDamageFastRipper
{
	double properangle;
	double properpitch;
	int setpitch;
	int setpitch2;

	void A_ArrowGuard()
	{
		double xpos;
		double zpos;
		setpitch2 = setpitch % 2;

		if (!setpitch) { pitch += properpitch; angle = properangle; }
		setpitch++;
		if (setpitch > 1)
		{
			if (!(CountInv("AetheriusTimeFreezer",AAPTR_PLAYER1) || CountInv("AetheriusTimeFreezerMenu",AAPTR_PLAYER1) || isFrozen()))
			{
				double newradius = 16.0 * (1.0 + (0.2 * ArcheryMasteryPerkLevel));
				int ahead = -320 - (newradius * 2);
				int maxgoes = ((-ahead)) / (newradius * 2);
				if (dvdsdebug_shieldactorghosts) Console.Printf("maxgoes: %d, newradius: %.2f", maxgoes, newradius);

				for (int i; i < maxgoes; i++)
				{
					ahead += (newradius * 2);
					xpos = 0 + (cos(pitch) * (0 + ahead));
					zpos = 4 - (sin(pitch) * (0 + ahead));
					A_SpawnItemEx("DiarisArrowGuard",xpos,0,zpos,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH); 
					if (dvdsdebug_shieldactorghosts) Console.Printf("i: %d, angle: %.8f, pitch: %.8f, ahead: %.8f, xpos: %.8f, zpos: %.8f", i, angle, pitch, ahead, xpos, zpos);
				}
			}
		}
	}

	override void PostBeginPlay()
	{
		properangle = (angle % 360);
		properpitch = pitch;
		if (dvdsdebug_shieldactorghosts) Console.Printf("(PBP) Angle: %.8f, Pitch: %.8f", properangle, properpitch);
		Super.PostBeginPlay();
	}

	override void Die(Actor source, Actor inflictor, int dmgflags)
	{
		A_ArrowGuard();
		Super.Die(source, inflictor, dmgflags);
	}

	override void Tick()
	{
		A_ArrowGuard();
		Super.Tick();
	}
}

class AetheriusDoomSpellZSC : AetheriusProjectileZSC
{
}

class AetheriusFastDoomSpellZSC : AetheriusFastProjectileZSC
{
}

class BFGBallBase : AetheriusProjectileZSC
{
	double user_radiusdmg; 
	double user_radiussize; 
	int user_detonationtimer;
	int user_projtimer;
	
	default
	{
		Radius 13;
		Height 8;
		Speed 25;
		DamageFunction 100;
		Projectile;
		+RANDOMIZE;
		RenderStyle "Add";
		Alpha 0.75;
		DeathSound "weapons/bfgx";
		Obituary "$OB_MPBFG_BOOM";
	}
	States
	{
		Spawn:
			BFS1 AB 4 Bright;
			Loop;
		Death:
			TNT1 A 0 
			{
				A_StartSound("weapons/bfgx",CHAN_7);
				A_Quake(1, 12, 0, 768, "");
				A_Quake(5, 12, 0, 512, "");
			}
			BFE1 AB 8 Bright;
			BFE1 C 8 Bright A_BFGSpray();
			BFE1 DEF 8 Bright;
			Stop;

		ShotDown:
			TNT1 A 0 
			{
				A_ScaleVelocity(0);
				A_StartSound("weapons/bfgx",CHAN_7, CHANF_DEFAULT, 0.5);
				A_Quake(1, 12, 0, 384, "");
				A_Quake(5, 12, 0, 256, "");
			}
			BFE1 ABCDEF 4 Bright;
			Stop;
	}
}
