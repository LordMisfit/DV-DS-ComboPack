// Base Projectile Class
class AetheriusBaseProjectileZSC : AetheriusBaseZSC
{
	void A_GetPlayerAttackDamage(int type = 0, int puff = 0)
	{
		int baserand1, baserand2;
		int damage, extradmg1, extradmg2, extradmg3, extradmg4, extradmg5, extradmg6, finaldmg;
		int rand1, rand2;
		int flagchecktype = 0;
		double perkfactor = 1.00;
		double chargefactor = 1.00;
		int playershot = 0;

		perkfactor = 1.00;
		// Bullet
		if (type == 1 ||
				type == 2 ||
				type == 5 ||
				type == 6)
				perkfactor += (CallACS("MiscVarCheckDECORATE",10019) * 0.02) + (CallACS("MiscVarCheckDECORATE",10020) * 0.10);
		// Pellet
		if (type == 3 || 
				type == 4)
				perkfactor += (CallACS("MiscVarCheckDECORATE",10021) * 0.02) + (CallACS("MiscVarCheckDECORATE",10022) * 0.10);
		// Plasma
		if (type == 7 || 
				type == 10 || 
				type == 11 || 
				type == 12 || 
				type == 13)
				perkfactor += ((CallACS("MiscVarCheckDECORATE",10023) * 0.02) + (CallACS("MiscVarCheckDECORATE",10024) * 0.10));
		// Demolition
		if (type == 8 || 
				type == 9)
				perkfactor += (CallACS("MiscVarCheckDECORATE",10025) * frandom(0.07,0.14)) + (CallACS("MiscVarCheckDECORATE",10026) * frandom(0.07,0.14));
		// Karasawa
		if (type == 16 || 
				type == 17)
				perkfactor += (CallACS("MiscVarCheckDECORATE",10027) * 0.25) + (CallACS("MiscVarCheckDECORATE",10028) * 0.75);
		// BFG
		if (type == 12 || 
				type == 13 || 
				type == 14 || 
				type == 15)
				perkfactor += (CallACS("MiscVarCheckDECORATE",10029) * 0.025) + (CallACS("MiscVarCheckDECORATE",10030) * 0.125);
		// Archery
		if (type == 18 || 
				type == 19 || 
				type == 20)
				perkfactor += (CallACS("MiscVarCheckDECORATE",10031) * frandom(0.09,0.15)) + (CallACS("MiscVarCheckDECORATE",10030) * frandom(0.36,0.60));

		if (type == 1) // Pistol [Single]
		{
			damage = random(1,4) * random(5,7); // 5 to 28
			extradmg1 = CallACS("MiscVarCheckDECORATE",31) * 1.50; // 150% of Agility
			extradmg2 = CallACS("MiscVarCheckDECORATE",35) * 0.35; // 35% of Strength
		}
		if (type == 2) // Pistol [Dual]
		{
			damage = random(2,4) * random(6,7); // 12 to 28
			extradmg1 = CallACS("MiscVarCheckDECORATE",31) * 1.75; // 175% of Agility
			extradmg2 = CallACS("MiscVarCheckDECORATE",35) * 0.40; // 40% of Strength
		}
		if (type == 3) // Shotgun
		{
			damage = random(2,3) * 5; // 10 to 15
			extradmg1 = CallACS("MiscVarCheckDECORATE",31) * 2.00; // 200% of Agility
			extradmg2 = CallACS("MiscVarCheckDECORATE",35) * 0.175; // 17.5% of Strength
		}
		if (type == 4) // Super Shotgun
		{
			damage = random(2,3) * random(5,6); // 10 to 18
			extradmg1 = CallACS("MiscVarCheckDECORATE",31) * 2.50; // 175% of Agility
			extradmg2 = CallACS("MiscVarCheckDECORATE",35) * 0.25; // 25% of Strength
		}
		if (type == 5) // Chaingun
		{
			damage = random(2,4) * random(5,7); // 10 to 28
			extradmg1 = CallACS("MiscVarCheckDECORATE",31) * 1.75; // 175% of Agility
			extradmg2 = CallACS("MiscVarCheckDECORATE",35) * 0.40; // 40% of Strength 
		}
		if (type == 6) // Minigun
		{
			damage = random(3,4) * random(6,7); // 18 to 28
			extradmg1 = CallACS("MiscVarCheckDECORATE",31) * 2.00; // 175% of Agility
			extradmg2 = CallACS("MiscVarCheckDECORATE",35) * 0.50; // 40% of Strength 
		}
		if (type == 7) // Repeater
		{
			baserand1 = 1 + (CallACS("MiscVarCheckDECORATE",10023) * 0.50);
			baserand2 = 3 + CallACS("MiscVarCheckDECORATE",10023) + (CallACS("MiscVarCheckDECORATE",10024) * 1.50);
			
			damage = random(baserand1,baserand2) * 6; // 6 to 18
			extradmg1 = CallACS("MiscVarCheckDECORATE",31) * 3.00; // 300% of Agility
			extradmg2 = CallACS("MiscVarCheckDECORATE",35) * 0.75; // 75% of Strength 
		}
		if (type == 8) // Rocket/Grenade [main hit]
		{
			baserand1 = 1 + CallACS("MiscVarCheckDECORATE",10025);
			baserand2 = 8 + (CallACS("MiscVarCheckDECORATE",10025) * 0.50) + (CallACS("MiscVarCheckDECORATE",10026) * 1.25);
			
			damage = random(baserand1,baserand2) * 20; // 20 to 160
			extradmg1 = CallACS("MiscVarCheckDECORATE",31) * 2.50; // 250% of Agility
			extradmg2 = CallACS("MiscVarCheckDECORATE",35) * 1.125; // 112.5% of Strength 
		}
		if (type == 9) // Rocket/Grenade [explosion]
		{
			damage = 128 + (CallACS("MiscVarCheckDECORATE",10025) * 12) + (CallACS("MiscVarCheckDECORATE",10026) * 30);
			extradmg1 = CallACS("MiscVarCheckDECORATE",31) * 2.50; // 250% of Agility
			extradmg2 = CallACS("MiscVarCheckDECORATE",35) * 1.125; // 112.5% of Strength 
		}
		if (type == 10) // Repeater [explosion]
		{
			damage = 7 + (CallACS("MiscVarCheckDECORATE",10023) * 4) + (CallACS("MiscVarCheckDECORATE",10024) * 10); // 7
			extradmg1 = CallACS("MiscVarCheckDECORATE",31) * 0.40; // 40% of Agility
			extradmg2 = CallACS("MiscVarCheckDECORATE",35) * 14.28282829; // 14.28~% of Strength 
		}

		if (type == 11) // Plasma
		{
			baserand1 = 1 + CallACS("MiscVarCheckDECORATE",10023);
			baserand2 = 8 + (CallACS("MiscVarCheckDECORATE",10023) * 0.5) + (CallACS("MiscVarCheckDECORATE",10024) * 1.25);
			damage = random(baserand1,baserand2) * 5; // 5 to 40
			extradmg1 = CallACS("MiscVarCheckDECORATE",31) * 0.9334; // 93.34% of Agility
			extradmg2 = CallACS("MiscVarCheckDECORATE",35) * 0.45; // 45% of Strength 
		}
		if (type == 12) // Plasma1 [BFG2704]
		{
			baserand1 = 1 + CallACS("MiscVarCheckDECORATE",10023);
			baserand2 = 8 + (CallACS("MiscVarCheckDECORATE",10023) * 0.5) + (CallACS("MiscVarCheckDECORATE",10024) * 1.25);
			damage = random(baserand1,baserand2) * 4; // 4 to 32
			extradmg1 = CallACS("MiscVarCheckDECORATE",31) * 1.00; // 100% of Agility
			extradmg2 = CallACS("MiscVarCheckDECORATE",35) * 0.55; // 55% of Strength 
		}
		if (type == 13) // Plasma2 [BFG2704]
		{
			baserand1 = 1 + CallACS("MiscVarCheckDECORATE",10023);
			baserand2 = 8 + (CallACS("MiscVarCheckDECORATE",10023) * 0.5) + (CallACS("MiscVarCheckDECORATE",10024) * 1.25);
			damage = random(baserand1,baserand2) * 4; // 4 to 32
			extradmg1 = CallACS("MiscVarCheckDECORATE",31) * 1.10; // 110% of Agility
			extradmg2 = CallACS("MiscVarCheckDECORATE",35) * 0.50; // 50% of Strength 
		}

		if (type == 14) // BFG [Main]
		{
			baserand1 = (CallACS("MiscVarCheckDECORATE",10023) * 2);
			if (CallACS("MiscVarCheckDECORATE",10029) <= 0) baserand1 += 2;
			if (CallACS("MiscVarCheckDECORATE",10029) == 1) baserand1 += 4;
			if (CallACS("MiscVarCheckDECORATE",10029) >= 2) baserand1 += 8;
			baserand2 = CallACS("MiscVarCheckDECORATE",10023) + (CallACS("MiscVarCheckDECORATE",10024) * 1.5);
			if (CallACS("MiscVarCheckDECORATE",10029) <= 0) baserand2 += 16;
			if (CallACS("MiscVarCheckDECORATE",10029) == 1) baserand2 += 17;
			if (CallACS("MiscVarCheckDECORATE",10029) >= 2) baserand2 += 20;
			damage = random(baserand1,baserand2) * 50; // 100 to 800
			extradmg1 = (CallACS("MiscVarCheckDECORATE",31) * 11); // 1100% of Agility
			if (CallACS("MiscVarCheckDECORATE",10029) == 1) extradmg1 = (CallACS("MiscVarCheckDECORATE",31) * 12); // 1200% of Agility
			if (CallACS("MiscVarCheckDECORATE",10029) == 2) extradmg1 = (CallACS("MiscVarCheckDECORATE",31) * 15); // 1500% of Agility
			extradmg2 = (CallACS("MiscVarCheckDECORATE",35) * 5.5); // 550% of Strength 
			if (CallACS("MiscVarCheckDECORATE",10029) == 1) extradmg2 = (CallACS("MiscVarCheckDECORATE",35) * 6); // 600% of Strength 
			if (CallACS("MiscVarCheckDECORATE",10029) == 2) extradmg2 = (CallACS("MiscVarCheckDECORATE",35) * 7.5); // 750% of Strength 
		}
	}
}

// Base Normal Projectile Class
class AetheriusProjectileZSC : AetheriusBaseProjectileZSC
{
	const SHARDSPAWN_LEFT	= 1;
	const SHARDSPAWN_RIGHT	= 2;
	const SHARDSPAWN_UP		= 4;
	const SHARDSPAWN_DOWN	= 8;

	int user_noseektimer, user_seektimer; // For Magic Missiles

	override void PostBeginPlay()
	{
		float basexvel = vel.x;
		float baseyvel = vel.y;
		float basezvel = vel.z;
		float speedmulti;
		float speedmulti2;
		float speedmulti3;
		float monsprojboostfactor = dvds_monsprojboostfactor;
		float mprojectilevelmulti = dvds_mprojectilevelmulti;
		float pprojectilevelmulti = dvds_pprojectilevelmulti;
		let IsPlayer = PlayerPawn(target);
		if (!IsPlayer) A_ScaleVelocity(mprojectilevelmulti); else A_ScaleVelocity(pprojectilevelmulti);

		let IsMonster = AetheriusMonsterZSC(target);
		if (dvds_monsterprojectileboost == 1)
		{
			if (IsMonster)
			{
				speedmulti = IsMonster.speed / IsMonster.user_basespeed;
				speedmulti2 = ((speedmulti - 1.0) * monsprojboostfactor) + 1.0;
				A_ScaleVelocity(speedmulti2);
			}
		}
		if (IsMonster)
		{
			speedmulti3 = 1.0;
			let IsMonsterLegendary = IsMonster.user_legendaryevolved;
			if (IsMonsterLegendary) speedmulti3 = LD_projspeedmulti;
			A_ScaleVelocity(speedmulti3);
		}
		float newxvel = vel.x;
		float newyvel = vel.y;
		float newzvel = vel.z;

		if (dvdsdebug_showmiscdmginformation && IsMonster) Console.Printf("PROJECTILE SPEED: \czXVelOld\c-: \cz%.4f\c-, \cyXVelNew\c-: \cy%.4f\c-, \czYVelOld\c-: \cz%.4f\c-, \cyYVelNew\c-: \cy%.4f\c-, \czZVelOld\c-: \cz%.4f\c-, \cyZVelNew\c-: \cy%.4f\c-, \cxSpeedMulti\c-: \cx%.4f\c-, \cwSpeedMulti2\c-: \cw%.4f\c-, \cvSpeedMulti3\c-: \cv%.4f\c-", basexvel, newxvel, baseyvel, newyvel, basezvel, newzvel, speedmulti, speedmulti2, speedmulti3);
		Super.PostBeginPlay(); // KEEP THIS HERE ELSE OTHER FUNCTIONS RELATED TO PostBeginPlay() BREAK :V
	}

	override void Tick()
	{
		if (dvdsdebug_showmiscdmginformation) Console.Printf("PROJECTILE SPEED: \cyXVel\c-: \cy%.4f\c-, \cyYVel\c-: \cy%.4f\c-, \cyZVelNew\c-: \cy%.4f\c-", vel.x, vel.y, vel.z);
		Super.Tick(); 
	}

	void A_PlayCrisisAtkSound ()
	{
		A_PlaySound("crisisattack",6);
		A_PlaySound("crisisattack2",7);
	}

	// A_SeekerMissile that will clear its tracer pointer if the tracer is friendly.
	void A_NFSeekerMissile(int threshold, int maxturnangle, int flags = 0, int chance = 50, int distance = 10)
	{
		A_SeekerMissile(threshold,maxturnangle,flags,chance,distance);
		// Clears if the tracer is friendly.
		if (tracer && tracer.bFRIENDLY == 1) tracer = null;
	}	
	
	void A_CharmSeek(int maxtime = 2)
	{
		user_seektimer += 1;
		if (user_seektimer >= maxtime) 
		{
			A_SeekerMissile(90,90,SMF_LOOK|SMF_PRECISE|SMF_CURSPEED,256,64); 
			user_seektimer = 0;
		}
		//A_LogInt(user_seektimer);
	}

	void A_MMSeek(int maxtime = 2)
	{
		user_seektimer += 1;
		if (user_seektimer >= maxtime) 
		{
			A_NFSeekerMissile(22,44,SMF_LOOK|SMF_PRECISE|SMF_CURSPEED,128,16);
			user_seektimer = 0;
		}
		//A_LogInt(user_seektimer);
	}

	void A_CharmCheckNoSeekTimer(int maxchance = 16, int charmseek = 2)
	{
		user_noseektimer -= 1;
		if (random(1,maxchance) == 1) 
		{ 
			A_CharmSeek(charmseek);
			user_noseektimer += 1;
		}
		//A_LogInt(user_noseektimer);
	}
	
	void A_MMCheckNoSeekTimer(int maxchance = 16, int mmseek = 2)
	{
		user_noseektimer -= 1;
		if (random(1,maxchance) == 1) 
		{ 
			A_MMSeek(mmseek);
			user_noseektimer += 1;
		}
		//A_LogInt(user_noseektimer);
	}

	void A_MMSeekerClearBounce(int timerset = 6, int randomset = 0)
	{
		if (user_noseektimer <= 0) 
		{ 
			user_noseektimer = timerset + random(-randomset,randomset);
			A_RearrangePointers(AAPTR_DEFAULT, AAPTR_DEFAULT, AAPTR_NULL);
			//A_LogInt(user_noseektimer);
		} 
	}



	// Customizable version of A_Tracer, allowing you to change the puff and smoke, as well as the tracing angle.
	void A_CustomTracer(double traceang = 16.875, string pufftype = "BulletPuff", string smoketype = "RevenantTracerSmoke")
	{
		// killough 1/18/98: this is why some missiles do not have smoke
		// and some do. Also, internal demos start at random gametics, thus
		// the bug in which revenants cause internal demos to go out of sync.
		//
		// killough 3/6/98: fix revenant internal demo bug by subtracting
		// levelstarttic from gametic:
		//
		// [RH] level.time is always 0-based, so nothing special to do here.

		if (level.time & 3)	return;
	
		// spawn a puff of smoke behind the rocket
		SpawnPuff (pufftype, pos, angle, angle, 3);
		Actor smoke = Spawn ("RevenantTracerSmoke", Vec3Offset(-Vel.X, -Vel.Y, 0.), ALLOW_REPLACE);
	
		if (smoke != null)
		{
			smoke.Vel.Z = 1.;
			smoke.tics -= random[Tracer](0, 3);
			if (smoke.tics < 1)
				smoke.tics = 1;
		}

		// The rest of this function was identical with Strife's version, except for the angle being used.
		A_Tracer2(traceang);
	}

	void A_FlameDie()
	{
		bNoGravity = true;
		Vel.Z = random[FlameDie]() & 3;
	}

	void A_WraithFX2()
	{
		for (int i = 2; i; --i)
		{
			Actor mo = Spawn ("WraithFX2", Pos, ALLOW_REPLACE);
			if(mo)
			{
				double newangle = random[WraithFX2]() * (360 / 1024.f);
				if (random[WraithFX2]() >= 128)
				{
					newangle = -newangle;
				}
				newangle += angle;
				mo.Vel.X = ((random[WraithFX2]() / 512.) + 1) * cos(newangle);
				mo.Vel.Y = ((random[WraithFX2]() / 512.) + 1) * sin(newangle);
				mo.Vel.Z = 0;
				mo.target = self;
				mo.Floorclip = 10;
			}
		}
	}

	// D'Sparil Bolt
	void A_BlueSpark ()
	{
		for (int i = 0; i < 2; i++)
		{
			Actor mo = Spawn("Sorcerer2FXSpark", pos, ALLOW_REPLACE);
			if (mo != null)
			{
				mo.Vel.X = Random2[BlueSpark]() / 128.;
				mo.Vel.Y = Random2[BlueSpark]() / 128.;
				mo.Vel.Z = 1. + Random[BlueSpark]() / 256.;
			}
		}
	}

	void A_GenWizard ()
	{
		Actor mo = Spawn("Wizard", pos, ALLOW_REPLACE);
		if (mo != null)
		{
			mo.AddZ(-mo.Default.Height / 2, false);
			if (!mo.TestMobjLocation ())
			{ // Didn't fit
				mo.ClearCounters();
				mo.Destroy ();
			}
			else
			{ // [RH] Make the new wizards inherit D'Sparil's target
				mo.CopyFriendliness (self.target, true);

				Vel = (0,0,0);
				SetStateLabel('Death');
				bMissile = false;
				mo.master = target;
				SpawnTeleportFog(pos, false, true);
			}
		}
	}

	// Red Axe [Heretic]
	void A_DripBlood (string missiletype = "Blood")
	{
		double xo = random2[DripBlood]() / 32.0;
		double yo = random2[DripBlood]() / 32.0;
		Actor mo = Spawn (missiletype, Vec3Offset(xo, yo, 0.), ALLOW_REPLACE);
		if (mo != null)
		{
			mo.Vel.X = random2[DripBlood]() / 64.0;
			mo.Vel.Y = random2[DripBlood]() / 64.0;
			mo.Gravity = 1./8;
		}
	}

	// Ice Ball Splits
	void A_LichIceImpact(string missiletype = "HeadFX2")
	{
		for (int i = 0; i < 8; i++)
		{
			Actor shard = Spawn(missiletype, Pos, ALLOW_REPLACE);
			if (shard != null)
			{
				shard.target = target;
				shard.angle = i*45.;
				shard.VelFromAngle();
				shard.Vel.Z = -.6;
				shard.CheckMissileSpawn (radius);
			}
		}
	}

	// Lich Fire Pillar
	void A_LichFireGrow ()
	{
		health--;
		AddZ(9.);
		if (health == 0)
		{
			RestoreDamage();
			SetStateLabel("NoGrow");
		}
	}

	// Ice Shards
	void A_ShedShard()
	{
		int spawndir = special1;
		int spermcount = special2;
		Actor mo;

		if (spermcount <= 0)
		{
			return;				// No sperm left
		}
		special2 = 0;
		spermcount--;

		// every so many calls, spawn a new missile in its set directions
		if (spawndir & SHARDSPAWN_LEFT)
		{
			mo = SpawnMissileAngleZSpeed(pos.z, "FrostMissile", angle + 5, 0, (20. + 2 * spermcount), target);
			if (mo)
			{
				mo.special1 = SHARDSPAWN_LEFT;
				mo.special2 = spermcount;
				mo.Vel.Z = Vel.Z;
				mo.args[0] = (spermcount==3)?2:0;
			}
		}
		if (spawndir & SHARDSPAWN_RIGHT)
		{
			mo = SpawnMissileAngleZSpeed(pos.z, "FrostMissile",	angle - 5, 0, (20. + 2 * spermcount), target);
			if (mo)
			{
				mo.special1 = SHARDSPAWN_RIGHT;
				mo.special2 = spermcount;
				mo.Vel.Z = Vel.Z;
				mo.args[0] = (spermcount==3)?2:0;
			}
		}
		if (spawndir & SHARDSPAWN_UP)
		{
			mo = SpawnMissileAngleZSpeed(pos.z + 8., "FrostMissile", angle, 0, (15. + 2 * spermcount), target);
			if (mo)
			{
				mo.Vel.Z = Vel.Z;
				if (spermcount & 1)			// Every other reproduction
					mo.special1 = SHARDSPAWN_UP | SHARDSPAWN_LEFT | SHARDSPAWN_RIGHT;
				else
					mo.special1 = SHARDSPAWN_UP;
				mo.special2 = spermcount;
				mo.args[0] = (spermcount==3)?2:0;
			}
		}
		if (spawndir & SHARDSPAWN_DOWN)
		{
			mo = SpawnMissileAngleZSpeed(pos.z - 4., "FrostMissile", angle, 0, (15. + 2 * spermcount), target);
			if (mo)
			{
				mo.Vel.Z = Vel.Z;
				if (spermcount & 1)			// Every other reproduction
					mo.special1 = SHARDSPAWN_DOWN | SHARDSPAWN_LEFT | SHARDSPAWN_RIGHT;
				else
					mo.special1 = SHARDSPAWN_DOWN;
				mo.special2 = spermcount;
				mo.target = target;
				mo.args[0] = (spermcount==3)?2:0;
			}
		}
	}

	// Wendigo/IceLich Balls
	void A_IceGuyMissileExplode(string missiletype = "IceGuyFX2")
	{
		for (int i = 0; i < 8; i++)
		{
			Actor mo = SpawnMissileAngleZ (pos.z+3, missiletype, i*45., -0.3);
			if (mo)
			{
				mo.target = target;
			}
		}
	}	

	//
	void A_MntrFloorFire(string missiletype = "MinotaurFX3")
	{
		SetZ(floorz);
		double x = Random2[MntrFloorFire]() / 64.;
		double y = Random2[MntrFloorFire]() / 64.;
		
		Actor mo = Spawn(missiletype, Vec2OffsetZ(x, y, floorz), ALLOW_REPLACE);
		if (mo != null)
		{
			mo.target = target;
			mo.Vel.X = MinVel; // Force block checking
			mo.CheckMissileSpawn (radius);
		}
	}

	// DragonFX2
	void A_DragonFX2(string missiletype = "DragonExplosion")
	{
		int delay = 16+(random[DragonFX2]()>>3);
		for (int i = random[DragonFX2](1, 4); i; i--)
		{
			double xo = (random[DragonFX2]() - 128) / 4.;
			double yo = (random[DragonFX2]() - 128) / 4.;
			double zo = (random[DragonFX2]() - 128) / 16.;

			Actor mo = Spawn (missiletype, Vec3Offset(xo, yo, zo), ALLOW_REPLACE);
			if (mo)
			{
				mo.tics = delay + (random[DragonFX2](0, 3)) * i*2;
				mo.target = target;
			}
		}
	}

	// WraithVerge
	void A_CHolyAttack2(string missiletype = "HolySpirit", int spiritnums = 4, int spiritfuse = 105, int spiritfusedm = 85)
	{
		for (int j = 0; j < spiritnums; j++)
		{
			Actor mo = Spawn(missiletype, Pos, ALLOW_REPLACE);
			if (!mo)
			{
				continue;
			}
			switch (j)
			{
				// float bob index

				case 0:
					mo.WeaveIndexZ = random[HolyAtk2]() & 7; // upper-left
					break;
				case 1:
					mo.WeaveIndexZ = 32 + (random[HolyAtk2]() & 7); // upper-right
					break;
				case 2:
					mo.WeaveIndexXY = 32 + (random[HolyAtk2]() & 7); // lower-left
					break;
				case 3:
					mo.WeaveIndexXY = 32 + (random[HolyAtk2]() & 7);
					mo.WeaveIndexZ = 32 + (random[HolyAtk2]() & 7);
					break;
			}
			mo.SetZ(pos.z);
			mo.angle = angle + 67.5 - 45.*j;
			mo.Thrust();
			mo.target = target;
			mo.args[0] = 10; // initial turn value
			mo.args[1] = 0; // initial look angle
			if (deathmatch)
			{
				// Ghosts last slightly less longer in DeathMatch
				mo.health = spiritfusedm;
				if (spiritfusedm <= 0) mo.health = 85;
			}
			else
			{
				mo.health = spiritfuse;
				if (spiritfuse <= 0) mo.health = 105;
			}
			if (tracer)
			{
				mo.tracer = tracer;
				mo.bNoClip = true;
				mo.bSkullFly = true;
				mo.bMissile = false;
			}
			HolyTail.SpawnSpiritTail (mo);
		}
	}

	// Sigil 1/Programmer Lightning Spawn Spot
	void A_SpectralLightning (string spawntype1 = "SpectralLightningV1", string spawntype2 = "SpectralLightningV2")
	{
		if (threshold != 0)
			--threshold;

		Vel.X += random2[Zap5](3);
		Vel.Y += random2[Zap5](3);

		double xo = random2[Zap5](3) * 50.;
		double yo = random2[Zap5](3) * 50.;
		
		class<Actor> cls;
		if (threshold > 25) cls = spawntype2;
		else cls = spawntype1;

		Actor flash = Spawn (cls, Vec2OffsetZ(xo, yo, ONCEILINGZ), ALLOW_REPLACE);

		if (flash != null)
		{
			flash.target = target;
			flash.Vel.Z = -18;
			flash.FriendPlayer = FriendPlayer;
		}

		flash = Spawn(spawntype2, (pos.xy, ONCEILINGZ), ALLOW_REPLACE);

		if (flash != null)
		{
			flash.target = target;
			flash.Vel.Z = -18;
			flash.FriendPlayer = FriendPlayer;
		}
	}

    // Player Sigil 2 Shots
	void A_SpectralLightningTail ()
	{
		Actor foo = Spawn("SpectralLightningHTail", Vec3Offset(-Vel.X, -Vel.Y, 0.), ALLOW_REPLACE);
		if (foo != null)
		{
			foo.Angle = Angle;
			foo.FriendPlayer = FriendPlayer;
		}
	}

	// Sigil5 Shots
	void A_SpectralBigBallLightning (string spawntype = "SpectralLightningH3")
	{
		Class<Actor> cls = spawntype;
		if (cls)
		{
			angle += 90.;
			SpawnSubMissile (cls, target);
			angle += 180.;
			SpawnSubMissile (cls, target);
			angle -= 270.;
			SpawnSubMissile (cls, target);
		}
	}
}

// Base FastProjectile Class
class AetheriusFastProjectileZSC : AetheriusBaseProjectileZSC
{
	Default
	{
		Projectile;
		MissileHeight 0;
	}
	
	virtual void Effect()
	{
		class<Actor> trail = MissileName;
		if (trail != null)
		{
			double hitz = pos.z - 8;

			if (hitz < floorz)
			{
				hitz = floorz;
			}
			// Do not clip this offset to the floor.
			hitz += MissileHeight;
			
			Actor act = Spawn (trail, (pos.xy, hitz), ALLOW_REPLACE);
			if (act != null)
			{
				if (bGetOwner && target != null)
					act.target = target;
				else
					act.target = self;
				
				act.angle = angle;
				act.pitch = pitch;
			}
		}
	}
	
	//----------------------------------------------------------------------------
	//
	// AFastProjectile :: Tick
	//
	// Thinker for the ultra-fast projectiles used by Heretic and Hexen
	//
	//----------------------------------------------------------------------------

	override void Tick ()
	{
		ClearInterpolation();
		double oldz = pos.Z;

		if (!bNoTimeFreeze)
		{
			//Added by MC: Freeze mode.
			if (globalfreeze || level.Frozen)
			{
				return;
			}
		}

		// [RH] Ripping is a little different than it was in Hexen
		FCheckPosition tm;
		tm.DoRipping = bRipper;

		int count = 8;
		if (radius > 0)
		{
			while (abs(Vel.X) >= radius * count || abs(Vel.Y) >= radius * count)
			{
				// we need to take smaller steps.
				count += count;
			}
		}

		if (height > 0)
		{
			while (abs(Vel.Z) >= height * count)
			{
				count += count;
			}
		}

		// Handle movement
		if (Vel != (0, 0, 0) || (pos.Z != floorz))
		{
			// force some lateral movement so that collision detection works as intended.
			if (bMissile && Vel.X == 0 && Vel.Y == 0 && !IsZeroDamage())
			{
				Vel.X = MinVel;
			}

			Vector3 frac = Vel / count;
			int changexy = frac.X != 0 || frac.Y != 0;
			int ripcount = count / 8;
			for (int i = 0; i < count; i++)
			{
				if (changexy)
				{
					if (--ripcount <= 0)
					{
						tm.ClearLastRipped();	// [RH] Do rip damage each step, like Hexen
					}
					
					if (!TryMove (Pos.XY + frac.XY, true, NULL, tm))
					{ // Blocked move
						if (!bSkyExplode)
						{
							let l = tm.ceilingline;
							if (l &&
								l.backsector &&
								l.backsector.GetTexture(sector.ceiling) == skyflatnum)
							{
								let posr = PosRelative(l.backsector);
								if (pos.Z >= l.backsector.ceilingplane.ZatPoint(posr.XY))
								{
									// Hack to prevent missiles exploding against the sky.
									// Does not handle sky floors.
									Destroy ();
									return;
								}
							}
							// [RH] Don't explode on horizon lines.
							if (BlockingLine != NULL && BlockingLine.special == Line_Horizon)
							{
								Destroy ();
								return;
							}
						}

						ExplodeMissile (BlockingLine, BlockingMobj);
						return;
					}
				}
				AddZ(frac.Z);
				UpdateWaterLevel ();
				oldz = pos.Z;
				if (oldz <= floorz)
				{ // Hit the floor

					if (floorpic == skyflatnum && !bSkyExplode)
					{
						// [RH] Just remove the missile without exploding it
						//		if this is a sky floor.
						Destroy ();
						return;
					}

					SetZ(floorz);
					HitFloor ();
					ExplodeMissile (NULL, NULL);
					return;
				}
				if (pos.Z + height > ceilingz)
				{ // Hit the ceiling

					if (ceilingpic == skyflatnum && !bSkyExplode)
					{
						Destroy ();
						return;
					}

					SetZ(ceilingz - Height);
					ExplodeMissile (NULL, NULL);
					return;
				}
				CheckPortalTransition();
				if (changexy && ripcount <= 0) 
				{
					ripcount = count >> 3;

					// call the 'Effect' method.
					Effect();
				}
			}
		}
		if (!CheckNoDelay())
			return;		// freed itself
		// Advance the state
		if (tics != -1)
		{
			if (tics > 0) tics--;
			while (!tics)
			{
				if (!SetState (CurState.NextState))
				{ // mobj was removed
					return;
				}
			}
		}
	}
}

// Base Puff Class
class AetheriusPuffZSC : AetheriusBaseProjectileZSC
{
	Default
	{
		+NOBLOCKMAP
		+NOGRAVITY
		+ALLOWPARTICLES
		+RANDOMIZE
		+ZDOOMTRANS
		RenderStyle "Translucent";
		Alpha 0.5;
		VSpeed 1;
		Mass 5;
	}

	States
	{
		Spawn:
			PUFF A 4 Bright;
			PUFF B 4;
		Melee:
			PUFF CD 4;
			Stop;
	}
}

// Base Crisis Particle
class AetheriusCrisisParticle : AetheriusBaseZSC
{
	double user_basealpha; 
	double user_basescaleX;
	double user_basescaleY;

	void A_CrisisParticleInit()
	{
		user_basealpha = alpha * 0.10;
		user_basescaleX = scale.x * 0.10;
		user_basescaleY = scale.y * 0.10;
		//Console.Printf("BASEScaleX: %.4f, BASEScaleY: %.4f, BASEALPHAZ: %.4f", user_basescaleX, user_basescaleY, user_basealpha);
	}

	void A_CrisisParticleDo()
	{
		A_FadeOut(user_basealpha);
		self.scale.x -= user_basescaleX;
		self.scale.y -= user_basescaleY;
		//Console.Printf("ScaleX: %.4f, ScaleY: %.4f, ALPHAZ: %.4f", self.scale.x, self.scale.y, self.alpha);

		if (self.scale.x < 0.00 && self.scale.y < 0.00) { A_FadeOut(2); }
	}
}

class AetheriusSpawnShotZSC : AetheriusProjectileZSC
{
	private void SpawnFlyDS(class<Actor> spawntype, sound snd)
	{
		Actor newmobj;
		Actor fog;
		Actor eye = master; // The eye is the spawnshot's master, not the target!
		Actor targ = target; // Unlike other projectiles, the target is the intended destination.
		int r;
			
		// [GZ] Should be more viable than a countdown...
		if (special2 != 0)
		{
			if (special2 > level.maptime)
				return;		// still flying
		}
		else
		{
			if (reactiontime == 0 || --reactiontime != 0)
				return;		// still flying
		}
		
		if (spawntype)
		{
			fog = Spawn (spawntype, targ.pos, ALLOW_REPLACE);
			if (fog) A_PlaySound(snd, CHAN_BODY);
		}

		class<Actor> SpawnName = null;

		DropItem di;   // di will be our drop item list iterator
		DropItem drop; // while drop stays as the reference point.
		int n = 0;

		// First see if this cube has its own actor list
		drop = GetDropItems();

		// If not, then default back to its master's list
		if (drop == null && eye != null)
			drop = eye.GetDropItems();

		if (drop != null)
		{
			for (di = drop; di != null; di = di.Next)
			{
				if (di.Name != 'None')
				{
					if (di.Amount < 0)
					{
						//di.Amount = 1; // default value is -1, we need a positive value.
					}
					n += di.Amount; // this is how we can weight the list.
				}
			}
			di = drop;
			n = random[pr_spawnfly](0, n);
			while (n >= 0)
			{
				if (di.Name != 'none')
				{
					n -= di.Amount; // logically, none of the -1 values have survived by now.
				}
				if ((di.Next != null) && (n >= 0))
				{
					di = di.Next;
				}
				else
				{
					n = -1;
				}
			}
			SpawnName = di.Name;
		}
		if (SpawnName == null)
		{
			// Randomly select monster to spawn.
			r = random(1,256); // r = random[pr_spawnfly](0, 255);

			// Probability distribution (kind of :),
			// decreasing likelihood.
			if (r < 16)  SpawnName = "Zombieman";		// 16/256
			else if (r < 32)  SpawnName = "ShotgunGuy";  	// 16/256 
			else if (r < 48)  SpawnName = "ChaingunGuy";	// 16/256 
			else if (r < 72)  SpawnName = "DoomImp";  		// 24/256 
			else if (r < 96)  SpawnName = "Demon";  		// 24/256 
			else if (r < 108) SpawnName = "PainElemental";	// 12/256
			else if (r < 132) SpawnName = "Cacodemon";		// 24/256
			else if (r < 144) SpawnName = "Revenant";		// 12/256
			else if (r < 168) SpawnName = "Arachnotron";	// 24/256
			else if (r < 192) SpawnName = "Fatso";			// 24/256
			else if (r < 216) SpawnName = "HellKnight";		// 24/256
			else if (r < 228) SpawnName = "BaronOfHell";	// 12/256
			else if (r < 240) SpawnName = "HellCleric";		// 12/256
			else if (r < 244) SpawnName = "Archvile";		// 4/256
			else if (r < 248) SpawnName = "FlyingBalrog";	// 4/256
			else if (r < 252) SpawnName = "Cyberdemon";		// 4/256
			else SpawnName = "HadesOverlord";	// 4/256
		}
		if (spawnname != null)
		{
			newmobj = Spawn (spawnname, targ.pos, ALLOW_REPLACE);
			if (newmobj != null)
			{
				// Make the new monster hate what the boss eye hates
				if (eye != null)
				{
					newmobj.CopyFriendliness (eye, false);
				}
				// Make it act as if it was around when the player first made noise
				// (if the player has made noise).
				newmobj.LastHeard = newmobj.CurSector.SoundTarget;

				if (newmobj.SeeState != null && newmobj.LookForPlayers (true))
				{
					newmobj.SetState (newmobj.SeeState);
				}
				if (!newmobj.bDestroyed)
				{
					// telefrag anything in this spot
					newmobj.TeleportMove (newmobj.pos, true);
				}
				newmobj.bBossSpawned = true;
			}
		}

		// remove self (i.e., cube).
		Destroy ();
	}

	void A_SpawnFlyDS(class<Actor> spawntype = null)
	{
		sound snd; 
		if (spawntype != null) 
		{
			snd = GetDefaultByType(spawntype).SeeSound;
		}
		else
		{
			spawntype = "SpawnFire";
			snd = "brain/spawn";
		}
		SpawnFlyDS(spawntype, snd);
	}

	void A_SpawnSoundDS()
	{
		// travelling cube sound
		A_PlaySound("brain/cube", CHAN_BODY);
		SpawnFlyDS("SpawnFire", "brain/spawn");
	}	
}

class AetheriusEffectProjectile : AetheriusProjectileZSC
{
	int user_canafflict;
	default
	{
		+HITMASTER;
	}
	
	void A_StatusEffectChecker(int basechance)
	{
		user_ailmentmaxchance = basechance;
		if (CountInv("EWShieldIdleMode",AAPTR_PLAYER1) > 0) user_ailmentmaxchance * 4;
		if (CallACS("GetBuffTimer",7) > 0) user_ailmentmaxchance * 4;

		user_canafflict = 1;
		if (CountInv("InvulnerabilitySpell",AAPTR_MASTER) > 0 || 
				CountInv("IsInvulnerable",AAPTR_MASTER) > 0 || 
				CountInv("MenuInvulnerability",AAPTR_MASTER) > 0 ||
				CountInv("EvadeAnAttack",AAPTR_MASTER) > 0 || 
				CountInv("PlayerDashing",AAPTR_MASTER) > 0) 
				{
					user_canafflict = 0;
				}

		AetheriusPlayerPawn playpawn;
		if (master) playpawn = AetheriusPlayerPawn(master);
		if (playpawn)
		{
			if (playpawn.player.cheats & CF_GODMODE2 || playpawn.player.cheats & CF_GODMODE) user_canafflict = 0;
		}
	}
}

class AetheriusWhirlwind : AetheriusProjectileZSC
{
	default
	{
		Accuracy 8;
		DamageType "Wind";
	}

	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		int randVal;
		if (Accuracy < 1) Accuracy = 1;
		int whirltimer = level.time & (Accuracy-1);
		int whirldmg = 3 * randompick(1,1,1,1,1,1,1,1,2,2,2,3);            
		if (Stamina == 30) whirldmg *= CallACS("CrisisMultiplier");

		if (!target.bDontThrust)
		{
			target.angle += Random2[WhirlwindDamage]() * (360 / 4096.);
			target.Vel.X += Random2[WhirlwindDamage]() / 64.;
			target.Vel.Y += Random2[WhirlwindDamage]() / 64.;
		}

		if ((level.time & 16) && !target.bBoss && !target.bDontThrust)
		{
			randVal = min(160, random[WhirlwindSeek]());
			target.Vel.Z += randVal / 32.;
			if (target.Vel.Z > 12)
			{
				target.Vel.Z = 12;
			}
		}

		if (whirltimer == 0)
		{
			target.DamageMobj (null, target, whirldmg, 'Wind');
		}
		return -1;
	}

	void A_WhirlwindSeek()
	{
		health -= 3;
		if (health < 0)
		{
			Vel = (0,0,0);
			SetStateLabel("Death");
			bMissile = false;
			return;
		}
		if ((threshold -= 3) < 0)
		{
			threshold = 58 + (random[WhirlwindSeek]() & 31);
			A_PlaySound("ironlich/attack3", CHAN_BODY);
		}
		if (tracer && tracer.bShadow)
		{
			return;
		}
		A_SeekerMissile(10, 30);
	}
	
}

// Holy Spirit --------------------------------------------------------------
class HolySpiritBase : AetheriusProjectileZSC
{
	Default
	{
		Health 105;
		Speed 12;
		Radius 10;
		Height 6;
		Damage 3;
		Projectile;
		+RIPPER +SEEKERMISSILE
		+FOILINVUL +SKYEXPLODE +NOEXPLODEFLOOR +CANBLAST
		+EXTREMEDEATH +NOSHIELDREFLECT
		RenderStyle "Translucent";
		Alpha 0.4;
		DeathSound "SpiritDie";
		Obituary "$OB_MPCWEAPWRAITHVERGE";
	}

	States
	{
		Spawn:
			SPIR AAB 2 A_CHolySeek;
			SPIR B 2 A_CHolyCheckScream;
			Loop;
		Death:
			SPIR D 4;
			SPIR E 4 A_Scream;
			SPIR FGHI 4;
			Stop;
	}
	
	//============================================================================
	//
	//
	//
	//============================================================================

	override bool Slam(Actor thing)
	{
		if (thing.bShootable && thing != target)
		{
			if (multiplayer && !deathmatch && thing.player && target.player)
			{
				// don't attack other co-op players
				return true;
			}
			if (thing.bReflective && (thing.player || thing.bBoss))
			{
				tracer = target;
				target = thing;
				return true;
			}
			if (thing.bIsMonster || thing.player)
			{
				tracer = thing;
			}
			if (random[SpiritSlam]() < 96)
			{
				int dam = 12;
				if (thing.player || thing.bBoss)
				{
					dam = 3;
					// ghost burns out faster when attacking players/bosses
					health -= 6;
				}
				if (Stamina == 30) { dam *= CallACS("CrisisMultiplier"); }

				thing.DamageMobj(self, target, dam, 'Melee');
				if (random[SpiritSlam]() < 128)
				{
					Spawn("HolyPuff", Pos, ALLOW_REPLACE);
					A_PlaySound("SpiritAttack", CHAN_WEAPON);
					if (thing.bIsMonster && random[SpiritSlam]() < 128)
					{
						thing.Howl();
					}
				}
			}
			if (thing.health <= 0)
			{
				tracer = null;
			}
		}
		return true;
	}

	override bool SpecialBlastHandling (Actor source, double strength)
	{
		if (tracer == source)
		{
			tracer = target;
			target = source;
		}
		return true;
	}

	//============================================================================
	//
	// CHolyFindTarget
	//
	//============================================================================

	private void CHolyFindTarget ()
	{
		Actor target;

		if ( (target = RoughMonsterSearch (6, true)) )
		{
			tracer = target;
			bNoClip = true;
			bSkullFly = true;
			bMissile = false;
		}
	}

	//============================================================================
	//
	// CHolySeekerMissile
	//
	// Similar to P_SeekerMissile, but seeks to a random Z on the target
	//============================================================================

	private void CHolySeekerMissile (double thresh, double turnMax)
	{
		Actor target = tracer;
		if (target == NULL)
		{
			return;
		}
		if (!target.bShootable || (!target.bIsMonster && !target.player))
		{
			// Target died/target isn't a player or creature
			tracer = null;
			bNoClip = false;
			bSkullFly = false;
			bMissile = true;
			CHolyFindTarget();
			return;
		}
		double ang = deltaangle(angle, AngleTo(target));
		double delta = abs(ang);
		
		if (delta > thresh)
		{
			delta /= 2;
			if (delta > turnMax)
			{
				delta = turnMax;
			}
		}
		if (ang > 0)
		{
			// Turn clockwise
			angle += delta;
		}
		else
		{
			// Turn counter clockwise
			angle -= delta;
		}
		VelFromAngle();

		if (!(level.time&15) 
			|| pos.z > target.pos.z + target.height
			|| pos.z + height < target.pos.z)
		{
			double newZ = target.pos.z + ((random[HolySeeker]()*target.Height) / 256.);
			double deltaZ = newZ - pos.z;
			if (abs(deltaZ) > 15)
			{
				if (deltaZ > 0)
				{
					deltaZ = 15;
				}
				else
				{
					deltaZ = -15;
				}
			}
			Vel.Z = deltaZ / DistanceBySpeed(target, Speed);
		}
	}

	//============================================================================
	//
	// A_CHolySeek
	//
	//============================================================================

	void A_CHolySeek()
	{
		health--;
		if (health <= 0)
		{
			Vel.X /= 4;
			Vel.Y /= 4;
			Vel.Z = 0;
			SetStateLabel ("Death");
			tics -= random[HolySeeker]()&3;
			return;
		}
		if (tracer)
		{
			CHolySeekerMissile (args[0], args[0]*2.);
			if (!((level.time+7)&15))
			{
				args[0] = 5+(random[HolySeeker]()/20);
			}
		}

		int xyspeed = (random[HolySeeker]() % 5);
		int zspeed = (random[HolySeeker]() % 5);
		A_Weave(xyspeed, zspeed, 4., 2.);
	}

	//============================================================================
	//
	// A_CHolyCheckScream
	//
	//============================================================================

	void A_CHolyCheckScream()
	{
		A_CHolySeek();
		if (random[HolyScream]() < 20)
		{
			A_PlaySound ("SpiritActive", CHAN_VOICE);
		}
		if (!tracer)
		{
			CHolyFindTarget();
		}
	}
}

// Mage Staff FX2 (Bloodscourge) --------------------------------------------
class MageStaffFX2Base : AetheriusProjectileZSC
{
	Default
	{
		Speed 17;
		Height 8;
		Damage 4;
		DamageType "Fire";
		Projectile;
		+SEEKERMISSILE
		+SCREENSEEKER
		+EXTREMEDEATH
		DeathSound "MageStaffExplode";
		Obituary "$OB_MPMWEAPBLOODSCOURGE";
	}


	States
	{
		Spawn:
			MSP2 ABCD 2 Bright A_MStaffTrack;
			Loop;
		Death:
			MSP2 E 4 Bright A_SetTranslucent(1,1);
			MSP2 F 5 Bright A_Explode (80, 192, 0);
			MSP2 GH 5 Bright;
			MSP2 I 4 Bright;
			Stop;
	}
	
	//============================================================================
	//
	//
	//
	//============================================================================

	override int SpecialMissileHit (Actor victim)
	{
		if (victim != target && !victim.player && !victim.bBoss)
		{
			int dam = 10;
			if (Stamina == 30) { dam *= CallACS("CrisisMultiplier"); }

			victim.DamageMobj (self, target, dam, 'Fire');
			return 1;	// Keep going
		}
		return -1;
	}

	override bool SpecialBlastHandling (Actor source, double strength)
	{
		// Reflect to originator
		tracer = target;	
		target = source;
		return true;
	}

	//============================================================================
	//
	// A_MStaffTrack
	//
	//============================================================================

	void A_MStaffTrack()
	{
		if (tracer == null && random[MStaffTrack]() < 50)
		{
			tracer = RoughMonsterSearch (10, true);
		}
		A_SeekerMissile(2, 10);
	}
}

class HealMissile : AetheriusProjectileZSC
{
	override bool CanCollideWith(Actor other, bool passive)
	{
		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			if (!other.bFRIENDLY)
				return false;
		}
		// We don't really care about others making the check.
		return true;
	}

	override int SpecialMissileHit (Actor victim)
 	{
		AetheriusMonsterZSC healee;
		if (victim) healee = AetheriusMonsterZSC(victim);

 		if (healee == target) return 1;
 		if (healee && healee == tracer && !healee.bFRIENDLY) return 1;
		if (healee && healee.bFRIENDLY)
		{
			if (self.CheckClass("Heal1Shot") == 1)
			{
				if (healee.health > 0 && healee.health < healee.User_MaxHP)
				{
					healee.health += CallACS("Healing_Actor",0,1); 
					if (healee.health > healee.User_MaxHP) healee.health = healee.User_MaxHP;
					return -1;
				}
				else { return 1; }
			}

			if (self.CheckClass("Heal2Shot") == 1) 
			{
				if (healee.health > 0 && healee.health < healee.User_MaxHP)
				{
					healee.health += CallACS("Healing_Actor",1,1);
					if (healee.health > healee.User_MaxHP) healee.health = healee.User_MaxHP;
					return -1;
				}
				else { return 1; }
			}

			if (self.CheckClass("Heal3Shot") == 1) 
			{
				if (healee.health > 0 && healee.health < (healee.User_MaxHP*2))
				{
					healee.health += CallACS("Healing_Actor",2,1); 
					if (healee.health > (healee.User_MaxHP*2)) healee.health = (healee.User_MaxHP*2);
					return -1;
				}
				else { return 1; }
			}
		}

 		return -1;
 	}

	
	override void Tick()
	{
		//if (tracer.bFRIENDLY) tracer = null;
		//This space for rent.
		super.Tick(); // KEEP THIS HERE ELSE OTHER FUNCTIONS RELATED TO THIS BREAK :V
	}
}

// Converts Monsters to Friendlys [base for items like Monster Munchies]
class CharmMissile : AetheriusProjectileZSC
{
	override bool CanCollideWith(Actor other, bool passive)
	{
		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			if (other.bFRIENDLY)
				return false;
		}
		// We don't really care about others making the check.
		return true;
	}

	override int SpecialMissileHit (Actor victim)
	{
		if (victim == target) return 1;
		if (victim == tracer && victim.bFRIENDLY) return 1;
		return -1;
	}
}

class AetheriusBaseLightning : AetheriusProjectileZSC
{
	Default
	{
		MissileType "LightningZap";
		AttackSound "MageLightningZap";
		ActiveSound "MageLightningContinuous";
		Obituary "$OB_MPMWEAPLIGHTNING";
		Mass 3;
		Stamina 1;
		Accuracy 1;
	}
	
	override int SpecialMissileHit (Actor thing)
	{
		int dmg = self.mass * random(self.stamina,self.accuracy);

		if (thing.bShootable && thing != target)
		{
			if (thing.Mass < LARGE_MASS)
			{
				thing.Vel.X += Vel.X / 16;
				thing.Vel.Y += Vel.Y / 16;
			}
			if ((!thing.player && !thing.bBoss) || !(level.time&1))
			{
				thing.DamageMobj(self, target, dmg, 'Electric');
				A_PlaySound(AttackSound, CHAN_WEAPON|CHAN_NOSTOP, 1, false);
				if (thing.bIsMonster && random[LightningHit]() < 64)
				{
					thing.Howl ();
				}
			}
			health--;
			if (health <= 0 || thing.health <= 0)
			{
				return 0;
			}
			if (bFloorHugger)
			{
				if (lastenemy && ! lastenemy.tracer)
				{
					lastenemy.tracer = thing;
				}
			}
			else if (!tracer)
			{
				tracer = thing;
			}
		}
		return 1; // lightning zaps through all sprites
	}
	
}

class AetheriusLightningTop : AetheriusBaseLightning
{
	const ZAGSPEED = 1;

	Default
	{
		Health 144;
		Speed 25;
		Radius 16;
		Height 40;
		Damage 8;
		Projectile;
		+CEILINGHUGGER
		RenderStyle "Add";
	}

	States
	{
		Spawn:
			MLFX A 2 Bright A_LightningZap;
			MLFX BCD 2 Bright A_LightningClip;
			Loop;
		Death:
			MLF2 A 2 Bright A_LightningRemove;
			MLF2 BCDEKLM 3 Bright;
			ACLO E 35;
			MLF2 NO 3 Bright;
			MLF2 P 4 Bright;
			MLF2 QP 3 Bright;
			MLF2 Q 4 Bright;
			MLF2 P 3 Bright;
			MLF2 O 3 Bright;
			MLF2 P 3 Bright;
			MLF2 P 1 Bright A_HideThing;
			ACLO E 1050;
			Stop;
	}
	
	//============================================================================
	//
	// A_LightningClip
	//
	//============================================================================

	void A_LightningClip()
	{
		Actor cMo;
		Actor target = NULL;
		int zigZag;

		if (bFloorHugger)
		{
			if (lastenemy == NULL)
			{
				return;
			}
			SetZ(floorz);
			target = lastenemy.tracer;
		}
		else if (bCeilingHugger)
		{
			SetZ(ceilingz - Height);
			target = tracer;
		}
		if (bFloorHugger)
		{
			// floor lightning zig-zags, and forces the ceiling lightning to mimic
			cMo = lastenemy;
			zigZag = random[LightningClip]();
			if((zigZag > 128 && special1 < 2) || special1 < -2)
			{
				Thrust(ZAGSPEED, angle + 90);
				if(cMo)
				{
					cMo.Thrust(ZAGSPEED, angle + 90);
				}
				special1++;
			}
			else
			{
				Thrust(ZAGSPEED,angle - 90);
				if(cMo)
				{
					cMo.Thrust(ZAGSPEED, angle - 90);
				}
				special1--;
			}
		}
		if(target)
		{
			if(target.health <= 0)
			{
				ExplodeMissile();
			}
			else
			{
				angle = AngleTo(target);
				VelFromAngle(Speed / 2);
			}
		}
	}


	//============================================================================
	//
	// A_LightningZap
	//
	//============================================================================

	void A_LightningZap(string MissileName = "LightningZap")
	{
		Class<Actor> lightning = MissileName;
		if (lightning == NULL) lightning = "LightningZap";

		A_LightningClip();

		health -= 8;
		if (health <= 0)
		{
			SetStateLabel ("Death");
			return;
		}
		double deltaX = (random[LightningZap]() - 128) * radius / 256;
		double deltaY = (random[LightningZap]() - 128) * radius / 256;
		double deltaZ = (bFloorHugger) ? 10 : -10;

		Actor mo = Spawn(lightning, Vec3Offset(deltaX, deltaY, deltaZ), ALLOW_REPLACE);
		if (mo)
		{
			mo.lastenemy = self;
			mo.Vel.X = Vel.X;
			mo.Vel.Y = Vel.Y;
			mo.Vel.Z = (bFloorHugger) ? 20 : -20;
			mo.target = target;
		}
		if (bFloorHugger && random[LightningZap]() < 160)
		{
			A_PlaySound (ActiveSound, CHAN_BODY);
		}
	}

	//============================================================================
	//
	// A_LightningRemove
	//
	//============================================================================

	void A_LightningRemove()
	{
		Actor mo = lastenemy;
		if (mo)
		{
			bNoTarget = true;	// tell A_ZapMimic that we are dead. The original code did a state pointer compare which is not safe.
			mo.lastenemy = NULL;
			mo.ExplodeMissile ();
		}
	}
	
}

class AetheriusLightningBottom : AetheriusLightningTop
{
	Default
	{
		-CEILINGHUGGER
		+FLOORHUGGER
		RenderStyle "Add";
	}

	States
	{
	Spawn:
		MLFX E 2 Bright A_LightningZap;
		MLFX FGH 2 Bright A_LightningClip;
		Loop;
	Death:
		MLF2 F 2 Bright A_LightningRemove;
		MLF2 GHIJKLM 3 Bright;
		ACLO E 20;
		MLF2 NO 3 Bright;
		MLF2 P 4 Bright;
		MLF2 QP 3 Bright;
		MLF2 Q 4 Bright A_LastZap;
		MLF2 POP 3 Bright;
		MLF2 P 1 Bright A_HideThing;
		Goto Super::Death + 19;
	}
	
	//============================================================================
	//
	// A_LastZap
	//
	//============================================================================

	void A_LastZap(string MissileName = "LightningZap")
	{
		Class<Actor> lightning = MissileName;
		if (lightning == NULL) lightning = "LightningZap";
		
		Actor mo = Spawn(lightning, self.Pos, ALLOW_REPLACE);
		if (mo)
		{
			mo.SetStateLabel ("Death");
			mo.Vel.Z = 40;
			mo.SetDamage(0);
		}
	}
}

class AetheriusLightningZap : AetheriusProjectileZSC
{
	Default
	{
		Radius 15;
		Height 35;
		Damage 2;
		Projectile;
		-ACTIVATEIMPACT
		-ACTIVATEPCROSS
		RenderStyle "Add";
		Obituary "$OB_MPMWEAPLIGHTNING";
	}

	States
	{
		Spawn:
			MLFX IJKLM 2 Bright A_ZapMimic;
			Loop;
		Death:
			MLFX NOPQRSTU 2 Bright;
			Stop;
	}
	
	override int SpecialMissileHit (Actor thing)
	{
		Actor lmo;

		if (thing.bShootable && thing != target)
		{
			lmo = lastenemy;
			if (lmo)
			{
				if (lmo.bFloorHugger)
				{
					if (lmo.lastenemy && !lmo.lastenemy.tracer)
					{
						lmo.lastenemy.tracer = thing;
					}
				}
				else if (!lmo.tracer)
				{
					lmo.tracer = thing;
				}
				if (!(level.time&3))
				{
					lmo.health--;
				}
			}
		}
		return -1;
	}
	
	//============================================================================
	//
	// A_ZapMimic
	//
	//============================================================================

	void A_ZapMimic()
	{
		Actor mo = lastenemy;
		if (mo)
		{
			if (mo.bNoTarget)
			{
				ExplodeMissile ();
			}
			else
			{
				Vel.X = mo.Vel.X;
				Vel.Y = mo.Vel.Y;
			}
		}
	}
}

// Projectiles derived from this class should rip through actors,
// but not actually hit them more than once.
class SingleDamageRipper : AetheriusProjectileZSC
{
	default
	{
			Projectile;
			+RIPPER;
	}
	
	Array<Actor> ActorsAlreadyHit;
	
	override bool CanCollideWith(Actor other, bool passive)
	{
			for (let i = 0, size = ActorsAlreadyHit.Size(); i < size; i++)
					if (other == ActorsAlreadyHit[i])
							return false;
			
			return true;
	}
}

class SingleDamageFastRipper : AetheriusFastProjectileZSC
{
	default
	{
			Projectile;
			+RIPPER;
	}
	
	Array<Actor> ActorsAlreadyHit;
	
	override bool CanCollideWith(Actor other, bool passive)
	{
			for (let i = 0, size = ActorsAlreadyHit.Size(); i < size; i++)
					if (other == ActorsAlreadyHit[i])
							return false;
			
			return true;
	}
}

class AetheriusFrostMissile : AetheriusProjectileZSC
{
	const SHARDSPAWN_LEFT	= 1;
	const SHARDSPAWN_RIGHT	= 2;
	const SHARDSPAWN_UP		= 4;
	const SHARDSPAWN_DOWN	= 8;
	
	Default
	{
		Speed 25;
		Radius 13;
		Height 8;
		Damage 1;
		DamageType "Ice";
		Projectile;
		DeathSound "MageShardsExplode";
		Obituary "$OB_MPMWEAPFROST";
	}

	States
	{
		Spawn:
			SHRD A 2 Bright;
			SHRD A 3 Bright A_ShedShard;
			SHRD B 3 Bright;
			SHRD C 3 Bright;
			Loop;
		Death:
			SHEX ABCDE 5 Bright;
			Stop;
	}
	
	override bool CanCollideWith(Actor other, bool passive)
	{
		// Non-passive means the one moving into the other is performing the checks.
		if (!passive)
		{
			let checkedenemy = Actor(other);
			if (!checkedenemy.bICECORPSE == 0) return false; else return true; // Makes the ice projectiles move PAST the frozen monster to hit other monsters.
		}
		// We don't really care about others making the check.
		return true;
	}
	
	override int DoSpecialDamage (Actor victim, int damage, Name damagetype)
	{
		if (special2 > 0)
		{
			damage <<= special2;
		}
		return damage;
	}

	//============================================================================
	//
	// A_ShedShard
	//
	//============================================================================

	void A_ShedShard()
	{
		int spawndir = special1;
		int spermcount = special2;
		Actor mo;

		if (spermcount <= 0)
		{
			return;				// No sperm left
		}
		special2 = 0;
		spermcount--;

		// every so many calls, spawn a new missile in its set directions
		if (spawndir & SHARDSPAWN_LEFT)
		{
			mo = SpawnMissileAngleZSpeed(pos.z, "FrostMissile", angle + 5, 0, (20. + 2 * spermcount), target);
			if (mo)
			{
				mo.special1 = SHARDSPAWN_LEFT;
				mo.special2 = spermcount;
				mo.Vel.Z = Vel.Z;
				mo.args[0] = (spermcount==3)?2:0;
			}
		}
		if (spawndir & SHARDSPAWN_RIGHT)
		{
			mo = SpawnMissileAngleZSpeed(pos.z, "FrostMissile",	angle - 5, 0, (20. + 2 * spermcount), target);
			if (mo)
			{
				mo.special1 = SHARDSPAWN_RIGHT;
				mo.special2 = spermcount;
				mo.Vel.Z = Vel.Z;
				mo.args[0] = (spermcount==3)?2:0;
			}
		}
		if (spawndir & SHARDSPAWN_UP)
		{
			mo = SpawnMissileAngleZSpeed(pos.z + 8., "FrostMissile", angle, 0, (15. + 2 * spermcount), target);
			if (mo)
			{
				mo.Vel.Z = Vel.Z;
				if (spermcount & 1)			// Every other reproduction
					mo.special1 = SHARDSPAWN_UP | SHARDSPAWN_LEFT | SHARDSPAWN_RIGHT;
				else
					mo.special1 = SHARDSPAWN_UP;
				mo.special2 = spermcount;
				mo.args[0] = (spermcount==3)?2:0;
			}
		}
		if (spawndir & SHARDSPAWN_DOWN)
		{
			mo = SpawnMissileAngleZSpeed(pos.z - 4., "FrostMissile", angle, 0, (15. + 2 * spermcount), target);
			if (mo)
			{
				mo.Vel.Z = Vel.Z;
				if (spermcount & 1)			// Every other reproduction
					mo.special1 = SHARDSPAWN_DOWN | SHARDSPAWN_LEFT | SHARDSPAWN_RIGHT;
				else
					mo.special1 = SHARDSPAWN_DOWN;
				mo.special2 = spermcount;
				mo.target = target;
				mo.args[0] = (spermcount==3)?2:0;
			}
		}
	}
}

class AetheriusIceShard : AetheriusFrostMissile
{
	Default
	{
		DamageType "Ice";
		-ACTIVATEIMPACT
		-ACTIVATEPCROSS
	}
	States
	{
		Spawn:
			SHRD ABC 3 Bright;
			Loop;
	}
}

class CFlameMissileNew : AetheriusFastProjectileZSC
{
	Default
	{
		Speed 200;
		Radius 14;
		Height 8;
		Damage 8;
		DamageType "Fire";
		+INVISIBLE
		+ZDOOMTRANS
		RenderStyle "Add";
		Obituary "$OB_MPCWEAPFLAME";
	}

	States
	{
		Spawn:
			CFFX A 4 Bright;
			CFFX A 1 A_CFlamePuff;
			Goto Death + 1;
		Death:
			CFFX A 1 Bright A_CFlameMissile;
			CFFX ABC 3 Bright;
			CFFX D 4 Bright;
			CFFX E 3 Bright;
			CFFX F 4 Bright;
			CFFX G 3 Bright;
			CFFX H 4 Bright;
			CFFX I 3 Bright;
			CFFX J 4 Bright;
			CFFX K 3 Bright;
			CFFX L 4 Bright;
			CFFX M 3 Bright;
			Stop;
	}
	
	override void BeginPlay ()
	{
		special1 = 2;
	}

	override void Effect ()
	{
		if (!--special1)
		{
			special1 = 4;
			double newz = pos.z - 12;
			if (newz < floorz)
			{
				newz = floorz;
			}
			Actor mo = Spawn ("CFlameFloor", (pos.xy, newz), ALLOW_REPLACE);
			if (mo)
			{
				mo.angle = angle;
			}
		}
	}
	
	//============================================================================
	//
	// A_CFlamePuff
	//
	//============================================================================

	void A_CFlamePuff()
	{
		bInvisible = false;
		bMissile = false;
		Vel = (0,0,0);
		A_PlaySound ("ClericFlameExplode", CHAN_BODY);
	}

	//============================================================================
	//
	// A_CFlameMissile
	//
	//============================================================================

	void A_CFlameMissile()
	{
		bInvisible = false;
		A_PlaySound ("ClericFlameExplode", CHAN_BODY);
		if (BlockingMobj && BlockingMobj.bShootable)
		{ // Hit something, so spawn the flame circle around the thing
			double dist = BlockingMobj.radius + 18;
			for (int i = 0; i < 4; i++)
			{
				double an = i*45.;
				Actor mo = Spawn ("CircleFlame", BlockingMobj.Vec3Angle(dist, an, 5), ALLOW_REPLACE);
				if (mo)
				{
					mo.angle = an;
					mo.target = target;
					mo.VelFromAngle(CircleFlame.FLAMESPEED);
					mo.specialf1 = mo.Vel.X;
					mo.specialf2 = mo.Vel.Y;
					mo.tics -= random[FlameMissile]()&3;
				}
				an += 180;
				mo = Spawn("CircleFlame", BlockingMobj.Vec3Angle(dist, an, 5), ALLOW_REPLACE);
				if(mo)
				{
					mo.angle = an;
					mo.target = target;
					mo.VelFromAngle(-CircleFlame.FLAMESPEED);
					mo.specialf1 = mo.Vel.X;
					mo.specialf2 = mo.Vel.Y;
					mo.tics -= random[FlameMissile]()&3;
				}
			}
			SetState (SpawnState);
		}
	}
}

class CircleFlameNew : AetheriusProjectileZSC
{
	const FLAMESPEED = 0.45;
	const FLAMEROTSPEED = 2.;
	
	Default
	{
		Radius 6;
		Damage 2;
		DamageType "Fire";
		Projectile;
		-ACTIVATEIMPACT
		-ACTIVATEPCROSS
		+ZDOOMTRANS
		RenderStyle "Add";
		DeathSound "ClericFlameCircle";
		Obituary "$OB_MPCWEAPFLAME";
	}

	States
	{
		Spawn:
			CFCF A 4 Bright;
			CFCF B 2 Bright A_CFlameRotate;
			CFCF C 2 Bright;
			CFCF D 1 Bright;
			CFCF E 2 Bright;
			CFCF F 2 Bright A_CFlameRotate;
			CFCF G 1 Bright;
			CFCF HI 2 Bright;
			CFCF J 1 Bright A_CFlameRotate;
			CFCF K 2 Bright;
			CFCF LM 3 Bright;
			CFCF N 2 Bright A_CFlameRotate;
			CFCF O 3 Bright;
			CFCF P 2 Bright;
			Stop;
		Death:
			CFCF QR 3 Bright;
			CFCF S 3 Bright A_Explode(20, 20, 0);
			CFCF TUVWXYZ 3 Bright;
			Stop;
	}
	
	//============================================================================
	//
	// A_CFlameRotate
	//
	//============================================================================

	void A_CFlameRotate()
	{
		double an = Angle + 90.;
		VelFromAngle(FLAMEROTSPEED, an);
		Vel.XY += (specialf1, specialf2);
		Angle += 6;
	}
}

class BishopFXNew : AetheriusProjectileZSC
{
	Default
	{
		Radius 10;
		Height 6;
		Speed 10;
		Damage 1;
		Projectile;
		+SEEKERMISSILE
		-ACTIVATEIMPACT -ACTIVATEPCROSS
		+STRIFEDAMAGE +ZDOOMTRANS
		RenderStyle "Add";
		DeathSound "BishopMissileExplode";
	}
	States
	{
	Spawn:
		BPFX ABAB 1 Bright A_BishopMissileWeave;
		BPFX B 0 Bright A_SeekerMissile(2,3);
		Loop;
	Death:
		BPFX CDEF 4 Bright;
		BPFX GH 3 Bright;
		Stop;
	}
}

class BlasterFX1Base : AetheriusFastProjectileZSC
{
	Default
	{
		Radius 12;
		Height 8;
		Speed 184;
		Damage 2;
		SeeSound "weapons/blastershoot";
		DeathSound "weapons/blasterhit";
		+SPAWNSOUNDSOURCE
		Obituary "$OB_MPPBLASTER";
	}

	States
	{
		Spawn:
			ACLO E 200;
			Loop;
		Death:
			FX18 A 3 BRIGHT A_SpawnRippers;
			FX18 B 3 BRIGHT;
			FX18 CDEFG 4 BRIGHT;
			Stop;
	}
	
	//----------------------------------------------------------------------------
	//
	// 
	//
	//----------------------------------------------------------------------------

	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		if (target is "Ironlich")
		{ // Less damage to Ironlich bosses
			damage = random[BlasterFX]() & 1;
			if (!damage)
			{
				return -1;
			}
		}
		return damage;
	}

	override void Effect ()
	{
		if (random[BlasterFX]() < 64)
		{
			Spawn("BlasterSmoke", (pos.xy, max(pos.z - 8, floorz)), ALLOW_REPLACE);
		}
	}

	//----------------------------------------------------------------------------
	//
	// PROC A_SpawnRippers
	//
	//----------------------------------------------------------------------------

	void A_SpawnRippers()
	{
		for(int i = 0; i < 8; i++)
		{
			Actor ripper = Spawn("Ripper", pos, ALLOW_REPLACE);
			if (ripper != null)
			{
				ripper.target = target;
				ripper.angle = i*45;
				ripper.VelFromAngle();
				ripper.CheckMissileSpawn (radius);
			}
		}
	}
}

class RipperBase : AetheriusProjectileZSC
{
	Default
	{
		Radius 8;
		Height 6;
		Speed 14;
		Damage 1;
		Projectile;
		+RIPPER
		DeathSound "weapons/blasterpowhit";
		Obituary "$OB_MPPBLASTER";
	}

	States
	{
		Spawn:
			FX18 M 4;
			FX18 N 5;
			Loop;
		Death:
			FX18 OPQRS 4 BRIGHT;
			Stop;
	}
	
	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		if (target is "Ironlich")
		{ // Less damage to Ironlich bosses
			damage = random[Ripper]() & 1;
			if (!damage)
			{
				return -1;
			}
		}
		return damage;
	}
	
}

// Horn Rod FX 2 ------------------------------------------------------------
class HornRodFX2Base : AetheriusProjectileZSC
{
	Default
	{
		Radius 12;
		Height 8;
		Speed 22;
		Damage 10;
		Health 140;
		Projectile;
		RenderStyle "Add";
		SeeSound "weapons/hornrodpowshoot";
		DeathSound "weapons/hornrodpowhit";
		Obituary "$OB_MPPSKULLROD";
	}

	States
	{
		Spawn:	
			FX00 C 3 BRIGHT;
			FX00 D 3 BRIGHT A_SeekerMissile(10, 30);
			FX00 E 3 BRIGHT;
			FX00 F 3 BRIGHT A_SeekerMissile(10, 30);
			Loop;
		Death:
			FX00 H 5 BRIGHT A_AddPlayerRain;
			FX00 I 5 BRIGHT;
			FX00 J 4 BRIGHT;
			FX00 KLM 3 BRIGHT;
			FX00 G 1 A_HideInCeiling;
			FX00 G 1 A_SkullRodStorm;
			Wait;
	}
	
	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		Sorcerer2 s2 = Sorcerer2(target);
		if (s2 != null && random[HornRodFX2]() < 96)
		{
			// D'Sparil teleports away
			s2.DSparilTeleport ();
			return -1;
		}
		return damage;
	}
	
	//----------------------------------------------------------------------------
	//
	// PROC A_AddPlayerRain
	//
	//----------------------------------------------------------------------------

	void A_AddPlayerRain()
	{
		RainTracker tracker;

		if (target == null || target.health <= 0)
		{
			// Shooter is dead or nonexistant
			return;
		}

		tracker = RainTracker(target.FindInventory("RainTracker"));

		// They player is only allowed two rainstorms at a time. Shooting more
		// than that will cause the oldest one to terminate.
		if (tracker != null)
		{
			if (tracker.Rain1 && tracker.Rain2)
			{
				// Terminate an active rain
				if (tracker.Rain1.health < tracker.Rain2.health)
				{
					if (tracker.Rain1.health > 16)
					{
						tracker.Rain1.health = 16;
					}
					tracker.Rain1 = null;
				}
				else
				{
					if (tracker.Rain2.health > 16)
					{
						tracker.Rain2.health = 16;
					}
					tracker.Rain2 = null;
				}
			}
		}
		else
		{
			tracker = RainTracker(target.GiveInventoryType("RainTracker"));
		}
		// Add rain mobj to list
		if (tracker.Rain1)
		{
			tracker.Rain2 = self;
		}
		else
		{
			tracker.Rain1 = self;
		}
		ActiveSound = "misc/rain";
	}
	
	//----------------------------------------------------------------------------
	//
	// PROC A_HideInCeiling
	//
	//----------------------------------------------------------------------------

	void A_HideInCeiling()
	{
		// This no longer hides in the ceiling. It just makes the actor invisible and keeps it in place.
		// We need its actual position to determine the correct ceiling height in A_SkullRodStorm.
		bInvisible = true;
		bSolid = false;
		bMissile = false;
		Vel = (0,0,0);
	}
	
	//----------------------------------------------------------------------------
	//
	// PROC A_SkullRodStorm [CUSTOMIZED for Aetherius Acid Rain stuff] :V
	//
	//----------------------------------------------------------------------------
	void A_AcidRainDrop(Class<Actor> missiletype, int xradius = 64, int yradius = 64)
	{
		static const Name translations[] =
		{
			"RainPillar1", "RainPillar2", "RainPillar3", "RainPillar4",
			"RainPillar5", "RainPillar6", "RainPillar7", "RainPillar8"
		};

		double xo = random(-xradius,xradius); // ((Random[SkullRodStorm]() & 127) - 64);
		double yo = random(-yradius,yradius); // ((Random[SkullRodStorm]() & 127) - 64);
		Vector3 spawnpos = Vec2OffsetZ(xo, yo, pos.z);
		Actor mo = Spawn(missiletype, spawnpos, ALLOW_REPLACE);
		if (!mo) return;
		
		// Find the ceiling above the spawn location. This may come from 3D floors but will not reach through portals.
		// (should probably be fixed for portals, too.)
		double newz = mo.CurSector.NextHighestCeilingAt(mo.pos.x, mo.pos.y, mo.pos.z, mo.pos.z, FFCF_NOPORTALS) - mo.height;
		mo.SetZ(newz);
    
		if (multiplayer && target.player)
		{
			mo.A_SetTranslation(translations[target.PlayerNumber()]);
		}
		mo.target = target;
		mo.Vel.X = MinVel; // Force collision detection
		mo.Vel.Z = -mo.Speed;
		mo.CheckMissileSpawn (radius);
		if (ActiveSound > 0) A_PlaySound(ActiveSound, CHAN_BODY, 1, true);
	}

	void A_SkullRodStorm(Class<Actor> missiletype = "RainPillar", 
			int xradius =             64,	int yradius =             64, 
			int rainspawnchance1 =   231,	int rainspawnchance2 =    16,	int rainspawnchance3 =     0,	int rainspawnchance4 =     0, 
			int rainspawnchance5 =     0,	int rainspawnchance6 =     0,	int rainspawnchance7 =     0,	int rainspawnchance8 =     0, 
			int rainspawnchance9 =     0,	int rainspawnchance10 =    0,	int rainspawnchance11 =    0,	int rainspawnchance12 =    0, 
			int rainspawnchance13 =    0,	int rainspawnchance14 =    0,	int rainspawnchance15 =    0,	int rainspawnchance16 =    0)
	{
		if (health-- == 0)
		{
			A_StopSound (CHAN_BODY);
			if (target == null)
			{
				// Player left the game
				Destroy ();
				return;
			}
			RainTracker tracker = RainTracker(target.FindInventory("RainTracker"));
			if (tracker != null)
			{
				if (tracker.Rain1 == self)
				{
					tracker.Rain1 = null;
				}
				else if (tracker.Rain2 == self)
				{
					tracker.Rain2 = null;
				}
			}
			Destroy ();
			return;
		}
		if (Random[SkullRodStorm](1,256) <= rainspawnchance1) A_AcidRainDrop(missiletype,xradius,yradius);
		if (Random[SkullRodStorm](1,256) <= rainspawnchance2) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance3) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance4) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance5) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance6) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance7) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance8) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance9) A_AcidRainDrop(missiletype,xradius,yradius);
		if (Random[SkullRodStorm](1,256) <= rainspawnchance10) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance11) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance12) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance13) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance14) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance15) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance16) A_AcidRainDrop(missiletype,xradius,yradius); 
	}
}

class RainPillarBase : AetheriusProjectileZSC
{
	Default
	{
		Radius 5;
		Height 12;
		Speed 12;
		Damage 5;
		Mass 5;
		Projectile;
		-ACTIVATEPCROSS
		-ACTIVATEIMPACT
		+ZDOOMTRANS
		RenderStyle "Add";
		Obituary "$OB_MPPSKULLROD";
	}

	States
	{
		Spawn:
			FX22 A -1 BRIGHT;
			Stop;
		Death:
			FX22 B 4 BRIGHT A_RainImpact;
			FX22 CDEF 4 BRIGHT;
			Stop;
		NotFloor:
			FX22 GHI 4 BRIGHT;
			Stop;
	}
	
	//----------------------------------------------------------------------------
	//
	// PROC A_RainImpact
	//
	//----------------------------------------------------------------------------

	void A_RainImpact()
	{
		if (pos.z > floorz)
		{
			SetStateLabel("NotFloor");
		}
		else if (random[RainImpact]() < 40)
		{
			HitFloor ();
		}
	}

	// Rain pillar 1 ------------------------------------------------------------

	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		if (target.bBoss)
		{ // Decrease damage for bosses
			damage = random[RainDamage](1, 8);
		}
		return damage;
	}
}

class PhoenixFX1Base : AetheriusProjectileZSC
{
	Default
	{
		Radius 11;
		Height 8;
		Speed 20;
		Damage 20;
		DamageType "Fire";
		Projectile;
		+THRUGHOST
		+SPECIALFIREDAMAGE
		SeeSound "weapons/phoenixshoot";
		DeathSound "weapons/phoenixhit";
		Obituary "$OB_MPPHOENIXROD";
	}

	States
	{
		Spawn:
			FX04 A 4 BRIGHT A_PhoenixPuff;
			Loop;
		Death:
			FX08 A 6 BRIGHT A_Explode;
			FX08 BC 5 BRIGHT;
			FX08 DEFGH 4 BRIGHT;
			Stop;
	}
	
	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		Sorcerer2 s2 = Sorcerer2(target);
		if (s2 != null && random[HornRodFX2]() < 96)
		{ // D'Sparil teleports away
			s2.DSparilTeleport ();
			return -1;
		}
		return damage;
	}

	//----------------------------------------------------------------------------
	//
	// PROC A_PhoenixPuff
	//
	//----------------------------------------------------------------------------

	void A_PhoenixPuff()
	{
		//[RH] Heretic never sets the target for seeking
		//P_SeekerMissile (self, 5, 10);
		Actor puff = Spawn("PhoenixPuff", Pos, ALLOW_REPLACE);
		if (puff != null)
		{
			puff.Vel.XY = AngleToVector(Angle + 90, 1.3);
		}

		puff = Spawn("PhoenixPuff", Pos, ALLOW_REPLACE);
		if (puff != null)
		{
			puff.Vel.XY = AngleToVector(Angle - 90, 1.3);
		}
	}
}

class PhoenixFX2Base : AetheriusProjectileZSC
{
	Default
	{
		Radius 6;
		Height 8;
		Speed 10;
		Damage 2;
		DamageType "Fire";
		Projectile;
		RenderStyle "Add";
		+ZDOOMTRANS
		Obituary "$OB_MPPPHOENIXROD";
	}

	States
	{
		Spawn:
			FX09 ABABA 2 BRIGHT;
			FX09 B 2 BRIGHT A_FlameEnd;
			FX09 CDEF 2 BRIGHT;
			Stop;
		Death:
			FX09 G 3 BRIGHT;
			FX09 H 3 BRIGHT A_FloatPuff;
			FX09 I 4 BRIGHT;
			FX09 JK 5 BRIGHT;
			Stop;
	}
	

	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		if (target.player && Random[PhoenixFX2]() < 128)
		{ // Freeze player for a bit
			target.reactiontime += 4;
		}
		return damage;
	}
	
	//----------------------------------------------------------------------------
	//
	// PROC A_FlameEnd
	//
	//----------------------------------------------------------------------------

	void A_FlameEnd()
	{
		Vel.Z += 1.5;
	}

	//----------------------------------------------------------------------------
	//
	// PROC A_FloatPuff
	//
	//----------------------------------------------------------------------------

	void A_FloatPuff()
	{
		Vel.Z += 1.8;
	}
}

class MaceFX1Base : AetheriusProjectileZSC
{
	const MAGIC_JUNK = 1234;
	
	Default
	{
		Radius 8;
		Height 6;
		Speed 20;
		Damage 2;
		Projectile;
		+THRUGHOST
		BounceType "HereticCompat";
		SeeSound "weapons/maceshoot";
		Obituary "$OB_MPMACE";
	}

	States
	{
		Spawn:
			FX02 AB 4 A_MacePL1Check;
			Loop;
		Death:
			FX02 F 4 BRIGHT A_MaceBallImpact;
			FX02 GHIJ 4 BRIGHT;
			Stop;
	}
	
	//----------------------------------------------------------------------------
	//
	// PROC A_MacePL1Check
	//
	//----------------------------------------------------------------------------

	void A_MacePL1Check()
	{
		if (special1 == 0) return;
		special1 -= 4;
		if (special1 > 0) return;
		special1 = 0;
		bNoGravity = false;
		Gravity = 1. / 8;
		// [RH] Avoid some precision loss by scaling the velocity directly
		double velscale = 7 / Vel.XY.Length();
		Vel.XY *= velscale;
		Vel.Z *= 0.5;
	}

	//----------------------------------------------------------------------------
	//
	// PROC A_MaceBallImpact
	//
	//----------------------------------------------------------------------------

	void A_MaceBallImpact()
	{
		if ((health != MAGIC_JUNK) && bInFloat)
		{ // Bounce
			health = MAGIC_JUNK;
			Vel.Z *= 0.75;
			bBounceOnFloors = bBounceOnCeilings = false;
			SetState (SpawnState);
			A_PlaySound ("weapons/macebounce", CHAN_BODY);
		}
		else
		{ // Explode
			Vel = (0,0,0);
			bNoGravity = true;
			Gravity = 1;
			A_PlaySound ("weapons/macehit", CHAN_BODY);
		}
	}
}

class MaceFX2Base : MaceFX1Base
{
	Default
	{
		Speed 10;
		Damage 6;
		Gravity 0.125;
		-NOGRAVITY
		SeeSound "";
	}

	States
	{
		Spawn:
			FX02 CD 4;
			Loop;
		Death:
			FX02 F 4 A_MaceBallImpact2;
			goto Super::Death+1;
	}
	
	//----------------------------------------------------------------------------
	//
	// PROC A_MaceBallImpact2
	//
	//----------------------------------------------------------------------------

	void A_MaceBallImpact2()
	{
		if ((pos.Z <= floorz) && HitFloor ())
		{ // Landed in some sort of liquid
			Destroy ();
			return;
		}
		if (bInFloat)
		{
			if (Vel.Z >= 2)
			{
				// Bounce
				Vel.Z *= 0.75;
				SetState (SpawnState);

				Actor tiny = Spawn("MaceFX3", Pos, ALLOW_REPLACE);
				if (tiny != null)
				{
					tiny.target = target;
					tiny.angle = angle + 90.;
					tiny.VelFromAngle(Vel.Z - 1.);
					tiny.Vel += (Vel.XY * .5, Vel.Z);
					tiny.CheckMissileSpawn (radius);
				}

				tiny = Spawn("MaceFX3", Pos, ALLOW_REPLACE);
				if (tiny != null)
				{
					tiny.target = target;
					tiny.angle = angle - 90.;
					tiny.VelFromAngle(Vel.Z - 1.);
					tiny.Vel += (Vel.XY * .5, Vel.Z);
					tiny.CheckMissileSpawn (radius);
				}
				return;
			}
		}
		Vel = (0,0,0);
		bNoGravity = true;
		bBounceOnFloors = bBounceOnCeilings = false;
		Gravity = 1;
	}
}

class MaceFX3Base : MaceFX1Base
{
	Default
	{
		Speed 7;
		Damage 4;
		-NOGRAVITY;
		Gravity 0.125;
	}

	States
	{
		Spawn:
			FX02 AB 4;
			Loop;
	}
}

class MaceFX4Base : AetheriusProjectileZSC
{
	Default
	{
		Radius 8;
		Height 6;
		Speed 7;
		Damage 18;
		Gravity 0.125;
		Projectile;
		-NOGRAVITY
		+TELESTOMP
		+THRUGHOST
		-NOTELEPORT
		BounceType "HereticCompat";
		SeeSound "";
		Obituary "$OB_MPPMACE";
	}

	States
	{
		Spawn:
			FX02 E 99;
			Loop;
		Death:
			FX02 C 4 A_DeathBallImpact;
			FX02 GHIJ 4 BRIGHT;
			Stop;
	}
	
	//---------------------------------------------------------------------------
	//
	// FUNC P_AutoUseChaosDevice
	//
	//---------------------------------------------------------------------------

	private bool AutoUseChaosDevice (PlayerInfo player)
	{
		Inventory arti = player.mo.FindInventory("ArtiTeleport");

		if (arti != null)
		{
			player.mo.UseInventory (arti);
			player.health = player.mo.health = (player.health+1)/2;
			return true;
		}
		return false;
	}
	
	//----------------------------------------------------------------------------
	//
	// PROC DoSpecialDamage
	//
	//----------------------------------------------------------------------------

	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		if (target.bBoss || target.bDontSquash || target.IsTeammate (self.target))
		{ // Don't allow cheap boss kills and don't instagib teammates
			return damage;
		}
		else if (target.player)
		{ // Player specific checks
			if (target.player.mo.bInvulnerable)
			{ // Can't hurt invulnerable players
				return -1;
			}
			if (AutoUseChaosDevice (target.player))
			{ // Player was saved using chaos device
				return -1;
			}
		}
		return TELEFRAG_DAMAGE; // Something's gonna die
	}

	//----------------------------------------------------------------------------
	//
	// PROC A_DeathBallImpact
	//
	//----------------------------------------------------------------------------

	void A_DeathBallImpact()
	{
		FTranslatedLineTarget t;

		if ((pos.Z <= floorz) && HitFloor ())
		{ // Landed in some sort of liquid
			Destroy ();
			return;
		}
		if (bInFloat)
		{
			if (Vel.Z >= 2)
			{
				// Bounce
				bool newAngle = false;
				double ang = 0;
				if (tracer)
				{
					if (!tracer.bShootable)
					{ // Target died
						tracer = null;
					}
					else
					{ // Seek
						ang = AngleTo(tracer);
						newAngle = true;
					}
				}
				else
				{ // Find new target
					ang = 0.;
					for (int i = 0; i < 16; i++)
					{
						AimLineAttack (ang, 640., t, 0., ALF_NOFRIENDS|ALF_PORTALRESTRICT, null, target);
						if (t.linetarget && target != t.linetarget)
						{
							tracer = t.linetarget;
							ang = t.angleFromSource;
							newAngle = true;
							break;
						}
						ang += 22.5;
					}
				}
				if (newAngle)
				{
					angle = ang;
					VelFromAngle();
				}
				SetState (SpawnState);
				A_PlaySound ("weapons/macestop", CHAN_BODY);
				return;
			}
		}
		Vel = (0,0,0);
		bNoGravity = true;
		Gravity = 1;
		A_PlaySound ("weapons/maceexplode", CHAN_BODY);
	}
}

class LoreShotBase : AetheriusProjectileZSC
{
	Default
	{
		Speed 20;
		Height 14;
		Radius 10;
		Projectile;
		+STRIFEDAMAGE
		Damage 2;
		MaxStepHeight 4;
		SeeSound "loremaster/chain";
		ActiveSound "loremaster/swish";
	}

	States
	{
	Spawn:
		OCLW A 2 A_LoremasterChain;
		Loop;
	Death:
		OCLW A 6;
		Stop;
	}
	
	override int DoSpecialDamage (Actor victim, int damage, Name damagetype)
	{
		
		if (victim != NULL && target != NULL && !victim.bDontThrust)
		{
			Vector3 thrust = victim.Vec3To(target);
			victim.Vel += thrust.Unit() * (255. * 50 / max(victim.Mass, 1));
		}
		return damage;
	}

	void A_LoremasterChain ()
	{
		A_PlaySound ("loremaster/active", CHAN_BODY);
		Spawn("LoreShot2", Pos, ALLOW_REPLACE);
		Spawn("LoreShot2", Vec3Offset(-Vel.x/2., -Vel.y/2., -Vel.z/2.), ALLOW_REPLACE);
		Spawn("LoreShot2", Vec3Offset(-Vel.x, -Vel.y, -Vel.z), ALLOW_REPLACE);
	}
	
}
