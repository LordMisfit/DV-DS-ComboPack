class AetheriusBaseWeaponZSC : Weapon 
{
	// Spreader Aura Level 1 Angles
	const spread1angle1 = -15.0;
	const spread1angle2 = 15.0;
	const spread1horz1 = 0.0;
	const spread1horz2 = 0.0;
	const spread1height1 = 0.0;
	const spread1height2 = 0.0;

	// Spreader Aura Level 2 Angles/Pitches
	const spread2angle1 = -7.5;
	const spread2angle2 = 7.5;
	const spread2horz1 = 0.0;
	const spread2horz2 = 0.0;
	const spread2pitch1 = -7.5;
	const spread2pitch2 = 7.5;
	const spread2height1 = 0.0;
	const spread2height2 = 0.0;

	void A_SceptreDvAvSwing()
	{
		if(CallACS("GetBuffTimer",7) > 0) { A_SetTics(0); }
	}
	
	void A_SceptreSwingShield()
	{
		let baseRange = CallACS("GetSceptreRange", 0);
		let maxpieces = baseRange / 32;
		for (let piece = 0; piece < maxpieces; piece++)
		{
			A_SpawnItemEx(
					piece == 0? "ShieldSpawnerSpinattack2D" : "ShieldSpawnerSpinattack2",
					CallACS("SetShieldPieceDist", baseRange - (piece * 32)),
					0, 0, 0, 0, 0, 0,
					SXF_NOCHECKPOSITION
			);
		}
/*
		int baserange = CallACS("GetSceptreRange",0);

		A_SpawnItemEx ("ShieldSpawnerSpinattack2D", CallACS("SetShieldPieceDist",baserange), 0, 0, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
		A_SpawnItemEx ("ShieldSpawnerSpinattack2", CallACS("SetShieldPieceDist",baserange-32), 0, 0, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
		A_SpawnItemEx ("ShieldSpawnerSpinattack2", CallACS("SetShieldPieceDist",baserange-64), 0, 0, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
		A_SpawnItemEx ("ShieldSpawnerSpinattack2", CallACS("SetShieldPieceDist",baserange-96), 0, 0, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
		A_SpawnItemEx ("ShieldSpawnerSpinattack2", CallACS("SetShieldPieceDist",baserange-128), 0, 0, 0, 0, 0, 0, SXF_NOCHECKPOSITION);
*/
	}
	
	void A_UppercutBonus()
	{
		if (random(1,6) == 1)
		{
			A_GiveInventory("UppercutCritBonus2",1,AAPTR_PLAYER1); 
		}
		else
		{
			A_GiveInventory("UppercutCritBonus1",1,AAPTR_PLAYER1); 
		}

		if (random(1,6) == 1)
		{
			if (random(1,6) == 1)
			{
				A_GiveInventory("UppercutATKBonus2",1,AAPTR_PLAYER1); 
				A_GiveInventory("UppercutDEFBonus2",1,AAPTR_PLAYER1); 
			}
			else
			{
				A_GiveInventory("UppercutATKBonus1",1,AAPTR_PLAYER1); 
				A_GiveInventory("UppercutDEFBonus1",1,AAPTR_PLAYER1); 
			}
		}
	}
 
	// Hell Warrior Shield
	void A_PHellWarShieldOff()
	{
		if (ACS_NamedExecuteWithResult("MiscVarCheckDECORATE",10053) >= 5) { A_SetTics(1); }
		A_TakeInventory("EWShieldDefendMode",0x7FFFFFFF);
		A_TakeInventory("EWShieldDefendModeExtra",0x7FFFFFFF);
		bREFLECTIVE = 0;
		//bSHIELDREFLECT = 0;
	}
	void A_PHellWarShieldOn()
	{
		A_GiveInventory("EWShieldDefendMode",1);
		A_TakeInventory("EWShieldDefendModeExtra",0x7FFFFFFF);
		if (random(1,4) == 1) { A_GiveInventory("EWShieldDefendModeExtra",1); } 
		bREFLECTIVE = 1;
		//bSHIELDREFLECT = 1;
	}
	
 
	// Spread Aura Function [Projectiles]
	void A_SpreadAuraFireProjectile (Class<Actor> missiletype, double angle = 0.0, int ammouseamount = 0, string ammousetype = "", float spawnofs_horz = 0.0, int spawnheight = 0, int flags = 0, double pitch = 0.0) 
	{
		if (CountInv("SpreaderAura2") > 0)
		{
			A_FireProjectile(missiletype,angle+spread2angle2,0,spawnofs_horz+spread2horz2,spawnheight+spread2height2,flags,pitch+spread2pitch2);
			A_FireProjectile(missiletype,angle+spread2angle2,0,spawnofs_horz+spread2horz2,spawnheight+spread2height1,flags,pitch+spread2pitch1);
			A_FireProjectile(missiletype,angle+spread2angle1,0,spawnofs_horz+spread2horz1,spawnheight+spread2height1,flags,pitch+spread2pitch1);
			A_FireProjectile(missiletype,angle+spread2angle1,0,spawnofs_horz+spread2horz1,spawnheight+spread2height2,flags,pitch+spread2pitch2);
		}
		if (CountInv("SpreaderAura1") > 0 || CountInv("SpreaderAura2") > 0)
		{
			A_FireProjectile(missiletype,angle+spread1angle1,0,spawnofs_horz+spread1horz1,spawnheight+spread1height1,flags,pitch);
			A_FireProjectile(missiletype,angle+spread1angle2,0,spawnofs_horz+spread1horz2,spawnheight+spread1height1,flags,pitch);
		}
		A_FireProjectile(missiletype,angle,0,spawnofs_horz,spawnheight,flags,pitch);

		A_TakeInventory(ammousetype,ammouseamount,TIF_NOTAKEINFINITE,AAPTR_DEFAULT);
	}

	// Spread Aura Function [Projectiles w/ AOE]
	void A_SpreadAuraFireProjectileAoE (Class<Actor> missiletype, Class<Actor> missiletypeaoe, double angle = 0.0, int ammouseamount = 0, string ammousetype = "", float spawnofs_horz = 0.0, int spawnheight = 0, int flags = 0, double pitch = 0.0) 
	{
		if (CountInv("SpreaderAura2") > 0)
		{
			A_FireProjectile(missiletypeaoe,angle+spread2angle2,0,spawnofs_horz+spread2horz2,spawnheight+spread2height2,flags,pitch+spread2pitch2);
			A_FireProjectile(missiletypeaoe,angle+spread2angle2,0,spawnofs_horz+spread2horz2,spawnheight+spread2height1,flags,pitch+spread2pitch1);
			A_FireProjectile(missiletypeaoe,angle+spread2angle1,0,spawnofs_horz+spread2horz1,spawnheight+spread2height1,flags,pitch+spread2pitch1);
			A_FireProjectile(missiletypeaoe,angle+spread2angle1,0,spawnofs_horz+spread2horz1,spawnheight+spread2height2,flags,pitch+spread2pitch2);
		}
		if (CountInv("SpreaderAura1") > 0 || CountInv("SpreaderAura2") > 0)
		{
			A_FireProjectile(missiletypeaoe,angle+spread1angle1,0,spawnofs_horz+spread1horz1,spawnheight+spread1height1,flags,pitch);
			A_FireProjectile(missiletypeaoe,angle+spread1angle2,0,spawnofs_horz+spread1horz2,spawnheight+spread1height1,flags,pitch);
		}
		A_FireProjectile(missiletype,angle,0,spawnofs_horz,spawnheight,flags,pitch);

		A_TakeInventory(ammousetype,ammouseamount,TIF_NOTAKEINFINITE,AAPTR_DEFAULT);
	}

	// Spread Aura Function [Melee Punch]
	void A_SpreadAuraCustomPunch (int damage, bool norandom = 0, int flags = 0, string pufftype = "", float range = 0.0, float lifesteal = 0.0, int lifestealmax = 0, string armorbonustype = "", sound meleesound = "", sound misssound = "") 
	{
		if (CountInv("SpreaderAura2") > 0)
		{
			// Angle + 15, Pitch + 0
			A_SetAngle(angle+spread1angle2);
			A_CustomPunch(damage,norandom,flags,pufftype,range,lifesteal,lifestealmax,armorbonustype,meleesound,misssound);
			// Angle + 7.5, Pitch + 7.5
			A_SetAngle(angle-spread2angle2); A_SetPitch(pitch+spread2pitch2);
			A_CustomPunch(damage,norandom,flags,pufftype,range,lifesteal,lifestealmax,armorbonustype,meleesound,misssound);
			// Angle + 7.5, Pitch - 7.5
			A_SetPitch(pitch-spread1angle2); 
			A_CustomPunch(damage,norandom,flags,pufftype,range,lifesteal,lifestealmax,armorbonustype,meleesound,misssound);
			// Angle + 0, Pitch + 0
			A_SetPitch(pitch+spread2pitch2); A_SetAngle(angle-spread2angle2);
			A_CustomPunch(damage,norandom,flags,pufftype,range,lifesteal,lifestealmax,armorbonustype,meleesound,misssound);
			// Angle - 7.5, Pitch - 7.5
			A_SetAngle(angle-spread2angle2); A_SetPitch(pitch-spread2pitch2);
			A_CustomPunch(damage,norandom,flags,pufftype,range,lifesteal,lifestealmax,armorbonustype,meleesound,misssound);
			// Angle - 7.5, Pitch + 7.5
			A_SetPitch(pitch+spread1angle2);
			A_CustomPunch(damage,norandom,flags,pufftype,range,lifesteal,lifestealmax,armorbonustype,meleesound,misssound);
			// Angle - 15, Pitch + 0
			A_SetPitch(pitch-spread2pitch2); A_SetAngle(angle-spread2angle2);
			A_CustomPunch(damage,norandom,flags,pufftype,range,lifesteal,lifestealmax,armorbonustype,meleesound,misssound);
			// Reset
			A_SetAngle(angle+spread1angle2);
		}
		else
		if (CountInv("SpreaderAura1") > 0)
		{
			A_SetAngle(angle+spread1angle2);
			A_CustomPunch(damage,norandom,flags,pufftype,range,lifesteal,lifestealmax,armorbonustype,meleesound,misssound);
			A_SetAngle(angle-spread1angle2);
			A_CustomPunch(damage,norandom,flags,pufftype,range,lifesteal,lifestealmax,armorbonustype,meleesound,misssound);
			A_SetAngle(angle-spread1angle2);
			A_CustomPunch(damage,norandom,flags,pufftype,range,lifesteal,lifestealmax,armorbonustype,meleesound,misssound);
			A_SetAngle(angle+spread1angle2);
		}
		else
		{
			A_CustomPunch(damage,norandom,flags,pufftype,range,lifesteal,lifestealmax,armorbonustype,meleesound,misssound);
		}
	}

	// Spread Aura Function [Melee Chainsaw]
	void A_SpreadAuraSaw (string fullsound, string hitsound = "", int damage = 0, string pufftype = "", int flags = 0, int flagscenter = 0, float range = 0.0, float spread_xy = 0.0, float spread_z = 0.0, float lifesteal = 0.0, int lifestealmax = 0, string armorbonustype = "")
	{
		if (CountInv("SpreaderAura2") > 0)
		{
			// Angle + 15, Pitch + 0
			A_SetAngle(angle+spread1angle2);
			A_Saw(fullsound,hitsound,damage,pufftype,   flags   ,range,spread_xy,spread_z,lifesteal,lifestealmax,armorbonustype);
			// Angle + 7.5, Pitch + 7.5
			A_SetAngle(angle-spread2angle2); A_SetPitch(pitch+spread2pitch2);
			A_Saw(fullsound,hitsound,damage,pufftype,   flags   ,range,spread_xy,spread_z,lifesteal,lifestealmax,armorbonustype);
			// Angle + 7.5, Pitch - 7.5
			A_SetPitch(pitch-spread1angle2); 
			A_Saw(fullsound,hitsound,damage,pufftype,   flags   ,range,spread_xy,spread_z,lifesteal,lifestealmax,armorbonustype);
			// Angle + 0, Pitch + 0
			A_SetPitch(pitch+spread2pitch2); A_SetAngle(angle-spread2angle2);
			A_Saw(fullsound,hitsound,damage,pufftype,flagscenter,range,spread_xy,spread_z,lifesteal,lifestealmax,armorbonustype);
			// Angle - 7.5, Pitch - 7.5
			A_SetAngle(angle-spread2angle2); A_SetPitch(pitch-spread2pitch2);
			A_Saw(fullsound,hitsound,damage,pufftype,   flags   ,range,spread_xy,spread_z,lifesteal,lifestealmax,armorbonustype);
			// Angle - 7.5, Pitch + 7.5
			A_SetPitch(pitch+spread1angle2);
			A_Saw(fullsound,hitsound,damage,pufftype,   flags   ,range,spread_xy,spread_z,lifesteal,lifestealmax,armorbonustype);
			// Angle - 15, Pitch + 0
			A_SetPitch(pitch-spread2pitch2); A_SetAngle(angle-spread2angle2);
			A_Saw(fullsound,hitsound,damage,pufftype,   flags   ,range,spread_xy,spread_z,lifesteal,lifestealmax,armorbonustype);
			// Reset
			A_SetAngle(angle+spread1angle2);
		}
		else
		if (CountInv("SpreaderAura1") > 0)
		{
			A_SetAngle(angle+spread1angle2);
			A_Saw(fullsound,hitsound,damage,pufftype,   flags   ,range,spread_xy,spread_z,lifesteal,lifestealmax,armorbonustype);
			A_SetAngle(angle-spread1angle2);
			A_Saw(fullsound,hitsound,damage,pufftype,flagscenter,range,spread_xy,spread_z,lifesteal,lifestealmax,armorbonustype);
			A_SetAngle(angle-spread1angle2);
			A_Saw(fullsound,hitsound,damage,pufftype,   flags   ,range,spread_xy,spread_z,lifesteal,lifestealmax,armorbonustype);
			A_SetAngle(angle+spread1angle2);
		}
		else
		{
			A_Saw(fullsound,hitsound,damage,pufftype,flagscenter,range,spread_xy,spread_z,lifesteal,lifestealmax,armorbonustype);
		}
	}

	// Spread Aura Function [Hitscan]
	void A_SpreadAuraFireBullets (double spread_horz, double spread_vert, int numbullets, int damage, string pufftype = "", int flags = 0, int flagscenter = 0, float range = 8192, string missile = "", float spawnheight = 0.0, float spawnofs_xy = 0.0, int ammouseamount = 0, string ammousetype = "")
	{
		if (CountInv("SpreaderAura2") > 0)
		{
			// Angle + 15, Pitch + 0
			A_SetAngle(angle+spread1angle2);
			A_FireBullets (spread_horz,spread_vert,numbullets,damage,pufftype,   flags   ,range,missile,spawnheight,spawnofs_xy);
			// Angle + 7.5, Pitch + 7.5
			A_SetAngle(angle-spread2angle2); A_SetPitch(pitch+spread2pitch2);
			A_FireBullets (spread_horz,spread_vert,numbullets,damage,pufftype,   flags   ,range,missile,spawnheight,spawnofs_xy);
			// Angle + 7.5, Pitch - 7.5
			A_SetPitch(pitch-spread1angle2); 
			A_FireBullets (spread_horz,spread_vert,numbullets,damage,pufftype,   flags   ,range,missile,spawnheight,spawnofs_xy);
			// Angle + 0, Pitch + 0
			A_SetPitch(pitch+spread2pitch2); A_SetAngle(angle-spread2angle2);
			A_FireBullets (spread_horz,spread_vert,numbullets,damage,pufftype,flagscenter,range,missile,spawnheight,spawnofs_xy);
			// Angle - 7.5, Pitch - 7.5
			A_SetAngle(angle-spread2angle2); A_SetPitch(pitch-spread2pitch2);
			A_FireBullets (spread_horz,spread_vert,numbullets,damage,pufftype,   flags   ,range,missile,spawnheight,spawnofs_xy);
			// Angle - 7.5, Pitch + 7.5
			A_SetPitch(pitch+spread1angle2);
			A_FireBullets (spread_horz,spread_vert,numbullets,damage,pufftype,   flags   ,range,missile,spawnheight,spawnofs_xy);
			// Angle - 15, Pitch + 0
			A_SetPitch(pitch-spread2pitch2); A_SetAngle(angle-spread2angle2);
			A_FireBullets (spread_horz,spread_vert,numbullets,damage,pufftype,   flags   ,range,missile,spawnheight,spawnofs_xy);
			// Reset
			A_SetAngle(angle+spread1angle2);
		}
		else
		if (CountInv("SpreaderAura1") > 0)
		{
			A_SetAngle(angle+spread1angle2);
			A_FireBullets (spread_horz,spread_vert,numbullets,damage,pufftype,   flags   ,range,missile,spawnheight,spawnofs_xy);
			A_SetAngle(angle-spread1angle2);
			A_FireBullets (spread_horz,spread_vert,numbullets,damage,pufftype,flagscenter,range,missile,spawnheight,spawnofs_xy);
			A_SetAngle(angle-spread1angle2);
			A_FireBullets (spread_horz,spread_vert,numbullets,damage,pufftype,   flags   ,range,missile,spawnheight,spawnofs_xy);
			A_SetAngle(angle+spread1angle2);
		}
		else
		{
			A_FireBullets (spread_horz,spread_vert,numbullets,damage,pufftype,flagscenter,range,missile,spawnheight,spawnofs_xy);
		}
		A_TakeInventory(ammousetype,ammouseamount,TIF_NOTAKEINFINITE,AAPTR_DEFAULT);
	}

	// Spread Aura Function [Railgun]
	void A_SpreadAuraRailAttack (int damage, int spawnofs_xy = 0, int ammouseamount = 0, string ammousetype = "", color ringcolor = 0, color corecolor = 0, int flags = 0, int maxdiff = 0, string pufftype = "", float spread_xy = 0.0, float spread_z = 0.0, int range = 8192, int duration = 35, float sparsity = 1.0, float driftspeed = 1.0, string spawnclass = "", float spawnofs_z = 0.0, int spiraloffset = 270, int limit = 0) 
	{
		if (CountInv("SpreaderAura2") > 0)
		{
			// Angle + 15, Pitch + 0
			A_SetAngle(angle+spread1angle2);
			A_RailAttack (damage,spawnofs_xy,0,ringcolor,corecolor,flags,maxdiff,pufftype,spread_xy,spread_z,range,duration,sparsity,driftspeed,spawnclass,spawnofs_z,spiraloffset,limit);
			// Angle + 7.5, Pitch + 7.5
			A_SetAngle(angle-spread2angle2); A_SetPitch(pitch+spread2pitch2);
			A_RailAttack (damage,spawnofs_xy,0,ringcolor,corecolor,flags,maxdiff,pufftype,spread_xy,spread_z,range,duration,sparsity,driftspeed,spawnclass,spawnofs_z,spiraloffset,limit);
			// Angle + 7.5, Pitch - 7.5
			A_SetPitch(pitch-spread1angle2); 
			A_RailAttack (damage,spawnofs_xy,0,ringcolor,corecolor,flags,maxdiff,pufftype,spread_xy,spread_z,range,duration,sparsity,driftspeed,spawnclass,spawnofs_z,spiraloffset,limit);
			// Angle + 0, Pitch + 0
			A_SetPitch(pitch+spread2pitch2); A_SetAngle(angle-spread2angle2);
			A_RailAttack (damage,spawnofs_xy,0,ringcolor,corecolor,flags,maxdiff,pufftype,spread_xy,spread_z,range,duration,sparsity,driftspeed,spawnclass,spawnofs_z,spiraloffset,limit);
			// Angle - 7.5, Pitch - 7.5
			A_SetAngle(angle-spread2angle2); A_SetPitch(pitch-spread2pitch2);
			A_RailAttack (damage,spawnofs_xy,0,ringcolor,corecolor,flags,maxdiff,pufftype,spread_xy,spread_z,range,duration,sparsity,driftspeed,spawnclass,spawnofs_z,spiraloffset,limit);
			// Angle - 7.5, Pitch + 7.5
			A_SetPitch(pitch+spread1angle2);
			A_RailAttack (damage,spawnofs_xy,0,ringcolor,corecolor,flags,maxdiff,pufftype,spread_xy,spread_z,range,duration,sparsity,driftspeed,spawnclass,spawnofs_z,spiraloffset,limit);
			// Angle - 15, Pitch + 0
			A_SetPitch(pitch-spread2pitch2); A_SetAngle(angle-spread2angle2);
			A_RailAttack (damage,spawnofs_xy,0,ringcolor,corecolor,flags,maxdiff,pufftype,spread_xy,spread_z,range,duration,sparsity,driftspeed,spawnclass,spawnofs_z,spiraloffset,limit);
			// Reset
			A_SetAngle(angle+spread1angle2);
		}
		else
		if (CountInv("SpreaderAura1") > 0)
		{
			A_SetAngle(angle+spread1angle2);
			A_RailAttack (damage,spawnofs_xy,0,ringcolor,corecolor,flags,maxdiff,pufftype,spread_xy,spread_z,range,duration,sparsity,driftspeed,spawnclass,spawnofs_z,spiraloffset,limit);
			A_SetAngle(angle-spread1angle2);
			A_RailAttack (damage,spawnofs_xy,0,ringcolor,corecolor,flags,maxdiff,pufftype,spread_xy,spread_z,range,duration,sparsity,driftspeed,spawnclass,spawnofs_z,spiraloffset,limit);
			A_SetAngle(angle-spread1angle2);
			A_RailAttack (damage,spawnofs_xy,0,ringcolor,corecolor,flags,maxdiff,pufftype,spread_xy,spread_z,range,duration,sparsity,driftspeed,spawnclass,spawnofs_z,spiraloffset,limit);
			A_SetAngle(angle+spread1angle2);
		}
		else
		{
			A_RailAttack (damage,spawnofs_xy,0,ringcolor,corecolor,flags,maxdiff,pufftype,spread_xy,spread_z,range,duration,sparsity,driftspeed,spawnclass,spawnofs_z,spiraloffset,limit);
		}
		A_TakeInventory(ammousetype,ammouseamount,TIF_NOTAKEINFINITE,AAPTR_DEFAULT);
	}

	// Used for Hellcore weapons to allow them to shoot Crisis attacks when the player's health is low. :V
	void A_HellCoreCrisisCheck (void)
	{
		A_TakeInventory("PlayerCanUseCrisisAttacks",9999,AAPTR_PLAYER1); 
		if (CountInv("CriticalHealth",AAPTR_PLAYER1) > 0) 
		{
			A_GiveInventory("PlayerCanUseCrisisAttacks",1,AAPTR_PLAYER1); 
		}
		else 
		{
			if (CountInv("LowHealth",AAPTR_PLAYER1) > 0 && random(1,4) == 4) 
			{
				A_GiveInventory("PlayerCanUseCrisisAttacks",1,AAPTR_PLAYER1); 
			}
		}
	}

	void A_PlayCrisisAtkSound ()
	{
		A_PlaySound("crisisattack",6);
		A_PlaySound("crisisattack2",7);
	}

}

class AetheriusBaseCustomInventoryZSC : CustomInventory 
{
	// Spreader Aura Level 1 Angles
	const spread1angle1 = -15.0;
	const spread1angle2 = 15.0;
	const spread1horz1 = 0.0;
	const spread1horz2 = 0.0;
	const spread1height1 = 0.0;
	const spread1height2 = 0.0;

	// Spreader Aura Level 2 Angles/Pitches
	const spread2angle1 = -7.5;
	const spread2angle2 = 7.5;
	const spread2horz1 = 0.0;
	const spread2horz2 = 0.0;
	const spread2pitch1 = -7.5;
	const spread2pitch2 = 7.5;
	const spread2height1 = 0.0;
	const spread2height2 = 0.0;

	// Spread Aura Function [Projectiles]
	void A_SpreadAuraFireProjectile (Class<Actor> missiletype, double angle = 0.0, int ammouseamount = 0, string ammousetype = "", float spawnofs_horz = 0.0, int spawnheight = 0, int flags = 0, double pitch = 0.0) 
	{
		if (CountInv("SpreaderAura2") > 0)
		{
			A_FireProjectile(missiletype,angle+spread2angle2,0,spawnofs_horz+spread2horz2,spawnheight+spread2height2,flags,pitch+spread2pitch2);
			A_FireProjectile(missiletype,angle+spread2angle2,0,spawnofs_horz+spread2horz2,spawnheight+spread2height1,flags,pitch+spread2pitch1);
			A_FireProjectile(missiletype,angle+spread2angle1,0,spawnofs_horz+spread2horz1,spawnheight+spread2height1,flags,pitch+spread2pitch1);
			A_FireProjectile(missiletype,angle+spread2angle1,0,spawnofs_horz+spread2horz1,spawnheight+spread2height2,flags,pitch+spread2pitch2);
		}
		if (CountInv("SpreaderAura1") > 0 || CountInv("SpreaderAura2") > 0)
		{
			A_FireProjectile(missiletype,angle+spread1angle1,0,spawnofs_horz+spread1horz1,spawnheight+spread1height1,flags,pitch);
			A_FireProjectile(missiletype,angle+spread1angle2,0,spawnofs_horz+spread1horz2,spawnheight+spread1height1,flags,pitch);
		}
		A_FireProjectile(missiletype,angle,0,spawnofs_horz,spawnheight,flags,pitch);

		A_TakeInventory(ammousetype,ammouseamount,TIF_NOTAKEINFINITE,AAPTR_DEFAULT);
	}

}

// Horn Rod FX 2 ------------------------------------------------------------
class HornRodFX2Base : Actor
{
	Default
	{
		Radius 12;
		Height 8;
		Speed 22;
		Damage 10;
		Health 140;
		Projectile;
		RenderStyle "Add";
		SeeSound "weapons/hornrodpowshoot";
		DeathSound "weapons/hornrodpowhit";
		Obituary "$OB_MPPSKULLROD";
	}

	States
	{
	Spawn:	
		FX00 C 3 BRIGHT;
		FX00 D 3 BRIGHT A_SeekerMissile(10, 30);
		FX00 E 3 BRIGHT;
		FX00 F 3 BRIGHT A_SeekerMissile(10, 30);
		Loop;
	Death:
		FX00 H 5 BRIGHT A_AddPlayerRain;
		FX00 I 5 BRIGHT;
		FX00 J 4 BRIGHT;
		FX00 KLM 3 BRIGHT;
		FX00 G 1 A_HideInCeiling;
		FX00 G 1 A_SkullRodStorm;
		Wait;
	}
	
	override int DoSpecialDamage (Actor target, int damage, Name damagetype)
	{
		Sorcerer2 s2 = Sorcerer2(target);
		if (s2 != null && random[HornRodFX2]() < 96)
		{
			// D'Sparil teleports away
			s2.DSparilTeleport ();
			return -1;
		}
		return damage;
	}
	
	//----------------------------------------------------------------------------
	//
	// PROC A_AddPlayerRain
	//
	//----------------------------------------------------------------------------

	void A_AddPlayerRain()
	{
		RainTracker tracker;

		if (target == null || target.health <= 0)
		{
			// Shooter is dead or nonexistant
			return;
		}

		tracker = RainTracker(target.FindInventory("RainTracker"));

		// They player is only allowed two rainstorms at a time. Shooting more
		// than that will cause the oldest one to terminate.
		if (tracker != null)
		{
			if (tracker.Rain1 && tracker.Rain2)
			{
				// Terminate an active rain
				if (tracker.Rain1.health < tracker.Rain2.health)
				{
					if (tracker.Rain1.health > 16)
					{
						tracker.Rain1.health = 16;
					}
					tracker.Rain1 = null;
				}
				else
				{
					if (tracker.Rain2.health > 16)
					{
						tracker.Rain2.health = 16;
					}
					tracker.Rain2 = null;
				}
			}
		}
		else
		{
			tracker = RainTracker(target.GiveInventoryType("RainTracker"));
		}
		// Add rain mobj to list
		if (tracker.Rain1)
		{
			tracker.Rain2 = self;
		}
		else
		{
			tracker.Rain1 = self;
		}
		ActiveSound = "misc/rain";
	}
	
	//----------------------------------------------------------------------------
	//
	// PROC A_HideInCeiling
	//
	//----------------------------------------------------------------------------

	void A_HideInCeiling()
	{
		// This no longer hides in the ceiling. It just makes the actor invisible and keeps it in place.
		// We need its actual position to determine the correct ceiling height in A_SkullRodStorm.
		bInvisible = true;
		bSolid = false;
		bMissile = false;
		Vel = (0,0,0);
	}
	
	//----------------------------------------------------------------------------
	//
	// PROC A_SkullRodStorm [CUSTOMIZED for Aetherius Acid Rain stuff] :V
	//
	//----------------------------------------------------------------------------
	void A_AcidRainDrop(Class<Actor> missiletype, int xradius = 64, int yradius = 64)
	{
		static const Name translations[] =
		{
			"RainPillar1", "RainPillar2", "RainPillar3", "RainPillar4",
			"RainPillar5", "RainPillar6", "RainPillar7", "RainPillar8"
		};

		double xo = random(-xradius,xradius); // ((Random[SkullRodStorm]() & 127) - 64);
		double yo = random(-yradius,yradius); // ((Random[SkullRodStorm]() & 127) - 64);
		Vector3 spawnpos = Vec2OffsetZ(xo, yo, pos.z);
		Actor mo = Spawn(missiletype, spawnpos, ALLOW_REPLACE);
		if (!mo) return;
		
		// Find the ceiling above the spawn location. This may come from 3D floors but will not reach through portals.
		// (should probably be fixed for portals, too.)
		double newz = mo.CurSector.NextHighestCeilingAt(mo.pos.x, mo.pos.y, mo.pos.z, mo.pos.z, FFCF_NOPORTALS) - mo.height;
		mo.SetZ(newz);
    
		if (multiplayer && target.player)
		{
			mo.A_SetTranslation(translations[target.PlayerNumber()]);
		}
		mo.target = target;
		mo.Vel.X = MinVel; // Force collision detection
		mo.Vel.Z = -mo.Speed;
		mo.CheckMissileSpawn (radius);
		if (ActiveSound > 0) A_PlaySound(ActiveSound, CHAN_BODY, 1, true);
	}

	void A_SkullRodStorm(Class<Actor> missiletype = "RainPillar", 
			int xradius =             64,	int yradius =             64, 
			int rainspawnchance1 =   231,	int rainspawnchance2 =    16,	int rainspawnchance3 =     0,	int rainspawnchance4 =     0, 
			int rainspawnchance5 =     0,	int rainspawnchance6 =     0,	int rainspawnchance7 =     0,	int rainspawnchance8 =     0, 
			int rainspawnchance9 =     0,	int rainspawnchance10 =    0,	int rainspawnchance11 =    0,	int rainspawnchance12 =    0, 
			int rainspawnchance13 =    0,	int rainspawnchance14 =    0,	int rainspawnchance15 =    0,	int rainspawnchance16 =    0)
	{
		if (health-- == 0)
		{
			A_StopSound (CHAN_BODY);
			if (target == null)
			{
				// Player left the game
				Destroy ();
				return;
			}
			RainTracker tracker = RainTracker(target.FindInventory("RainTracker"));
			if (tracker != null)
			{
				if (tracker.Rain1 == self)
				{
					tracker.Rain1 = null;
				}
				else if (tracker.Rain2 == self)
				{
					tracker.Rain2 = null;
				}
			}
			Destroy ();
			return;
		}
		if (Random[SkullRodStorm](1,256) <= rainspawnchance1) A_AcidRainDrop(missiletype,xradius,yradius);
		if (Random[SkullRodStorm](1,256) <= rainspawnchance2) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance3) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance4) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance5) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance6) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance7) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance8) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance9) A_AcidRainDrop(missiletype,xradius,yradius);
		if (Random[SkullRodStorm](1,256) <= rainspawnchance10) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance11) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance12) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance13) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance14) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance15) A_AcidRainDrop(missiletype,xradius,yradius); 
		if (Random[SkullRodStorm](1,256) <= rainspawnchance16) A_AcidRainDrop(missiletype,xradius,yradius); 
	}

	
}

class MinigunSlowdownWhenFiring : PowerSpeed
{
	default
	{
		+PowerSpeed.NOTRAIL;
		-Inventory.NOTELEPORTFREEZE;
		Speed 0.2;
		Powerup.Duration 0x7FFFFFFD;
		Inventory.Icon "";
	}
	
	override void Tick()
	{
		Super.Tick();
			
		/* This is so that, if the player's weapon is forcibly switched away from Minigun, its slowdown effect will still go away properly.
		*
		*  This doesn't handle the case where the Minigun is still the player's current weapon, but has stopped firing. That is handled in the Minigun class.
		*/
		if (Owner && Owner.player)
		{
			if (!(Owner.player.ReadyWeapon is "Minigun"))
			{
				Destroy();
				return;
			}
			
			Speed = 0.2 + (CallACS("MiscVarCheckDECORATE",10019) * 0.05) + (CallACS("MiscVarCheckDECORATE",10020) * 0.125);
		}
	}
}